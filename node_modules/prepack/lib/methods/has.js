"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HasName = HasName;
exports.HasProperty = HasProperty;
exports.HasOwnProperty = HasOwnProperty;
exports.OrdinaryHasProperty = OrdinaryHasProperty;
exports.HasCompatibleType = HasCompatibleType;
exports.HasSomeCompatibleType = HasSomeCompatibleType;

var _index = require("./index.js");

var _index2 = require("../values/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 12.2.1.2 Static Semantics: HasName
// 14.1.9 Static Semantics: HasName
// 14.2.7 Static Semantics: HasName
// 14.5.6 Static Semantics: HasName
// 14.2.7 Static Semantics: HasName

function HasName(realm, ast) {
  // 12.2.1.2 Static Semantics: HasName
  // CoverParenthesizedExpressionAndArrowParameterList

  // 14.2.7 Static Semantics: HasName
  if (ast.type === "ArrowFunctionExpression") return false;

  // 14.1.9 Static Semantics: HasName
  if (ast.type === "FunctionExpression") {
    // FunctionExpression: function (FormalParameters) {FunctionBody}
    if (ast.id === null)
      // 1. Return false.
      return false;
    // FunctionExpression: functionBindingIdentifier (FormalParameters) {FunctionBody}
    if (ast.id !== null)
      // 2. Return true
      return true;
  }

  // 14.5.6 Static Semantics: HasName
  if (ast.type === "ClassExpression") {
    // ClassExpression : class ClassTail
    if (ast.id === null)
      //1. Return false.
      return false;
    // ClassExpression : class BindingIdentifier ClassTail
    if (ast.id !== null)
      //1. return true;
      return true;
  }
  // 14.4.7 Static Semantics: HasName
  // GeneratorExpression
  throw Error("Unexpected AST node type  : " + ast.type);
}

// ECMA262 7.3.10
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function HasProperty(realm, O, P) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant2.default)(O instanceof _index2.ObjectValue || O instanceof _index2.AbstractObjectValue, "expected object");

  // 2. Assert: IsPropertyKey(P) is true.
  (0, _invariant2.default)((0, _index.IsPropertyKey)(realm, P), "expected property key");

  // 3. Return ? O.[[HasProperty]](P).
  return O.$HasProperty(P);
}

// ECMA262 7.3.11
function HasOwnProperty(realm, O, P) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant2.default)(O instanceof _index2.ObjectValue || O instanceof _index2.AbstractObjectValue, "not an object");

  // 2. Assert: IsPropertyKey(P) is true.
  (0, _invariant2.default)((0, _index.IsPropertyKey)(realm, P), "not a valid property key");

  // 3. Let desc be ? O.[[GetOwnProperty]](P).
  var desc = O.$GetOwnProperty(P);

  // 4. If desc is undefined, return false.
  if (desc === undefined) return false;
  (0, _index.ThrowIfMightHaveBeenDeleted)(desc.value);

  // 5. Return true.
  return true;
}

// ECMA262 9.1.7.1
function OrdinaryHasProperty(realm, O, P) {
  // 1. Assert: IsPropertyKey(P) is true.
  (0, _invariant2.default)(typeof P === "string" || (0, _index.IsPropertyKey)(realm, P), "expected property key");

  // 2. Let hasOwn be ? O.[[GetOwnProperty]](P).
  var hasOwn = O.$GetOwnProperty(P);

  // 3. If hasOwn is not undefined, return true.
  if (hasOwn !== undefined) {
    (0, _index.ThrowIfMightHaveBeenDeleted)(hasOwn.value);
    return true;
  }

  // 4. Let parent be ? O.[[GetPrototypeOf]]().
  var parent = O.$GetPrototypeOf();

  // 5. If parent is not null, then
  if (!(parent instanceof _index2.NullValue)) {
    (0, _invariant2.default)(parent instanceof _index2.ObjectValue);

    // a. Return ? parent.[[HasProperty]](P).
    return parent.$HasProperty(P);
  }

  // 6. Return false.
  return false;
}

// Checks if the given value is equal to or a subtype of the given type.
// If the value is an abstract value without precise type information,
// an introspection error is thrown.
function HasCompatibleType(realm, value, type) {
  var valueType = value.getType();
  if (valueType === _index2.Value) {
    (0, _invariant2.default)(value instanceof _index2.AbstractValue);
    throw _index2.AbstractValue.createIntrospectionErrorThrowCompletion(value);
  }
  return _index2.Value.isTypeCompatibleWith(valueType, type);
}

function HasSomeCompatibleType(realm, value) {
  var valueType = value.getType();
  if (valueType === _index2.Value) {
    (0, _invariant2.default)(value instanceof _index2.AbstractValue);
    throw _index2.AbstractValue.createIntrospectionErrorThrowCompletion(value);
  }

  for (var _len = arguments.length, manyTypes = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    manyTypes[_key - 2] = arguments[_key];
  }

  return manyTypes.some(_index2.Value.isTypeCompatibleWith.bind(null, valueType));
}
//# sourceMappingURL=has.js.map