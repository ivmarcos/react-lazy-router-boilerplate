{"version":3,"sources":["../../src/methods/abstract.js"],"names":["SplitMatch","RequireObjectCoercible","AbstractRelationalComparison","AbstractEqualityComparison","StrictEqualityComparison","StrictEqualityComparisonPartial","SameValueZero","SameValueZeroPartial","SameValue","SameValuePartial","SameValueNonNumber","SamePropertyKey","Add","InstanceofOperator","OrdinaryHasInstance","Type","SymbolDescriptiveString","UpdateEmpty","URIReserved","URIAlpha","DecimalDigit","URIMark","URIUnescaped","realm","S","q","R","r","length","s","i","arg","createErrorThrowCompletion","intrinsics","TypeError","x","y","LeftFirst","px","py","value","startsWith","false","true","k","charCodeAt","m","n","nx","ny","isNaN","undefined","Object","is","getType","throwIfNotConcrete","values","meetValues","isTop","getElements","size","a","b","subtract","NaN","anum","bnum","O","C","mightBeObject","instOfHandler","SymbolHasInstance","BC","$BoundTargetFunction","P","$GetPrototypeOf","val","mightNotBeObject","createIntrospectionErrorThrowCompletion","sym","desc","$Description","completionRecord"],"mappings":"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","file":"abstract.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { BoundFunctionValue, EmptyValue, NumberValue, SymbolValue, StringValue, NullValue, ObjectValue, Value, BooleanValue, UndefinedValue, ConcreteValue, AbstractValue } from \"../values/index.js\";\nimport { ToPrimitive, ToNumber, ToBooleanPartial } from \"./to.js\";\nimport { Call } from \"./call.js\";\nimport { IsCallable } from \"./is.js\";\nimport { Completion, ReturnCompletion, ThrowCompletion } from \"../completions.js\";\nimport { GetMethod, Get } from \"./get.js\";\nimport { HasCompatibleType, HasSomeCompatibleType } from \"./has.js\";\nimport { ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\n\nexport const URIReserved = \";/?:@&=+$,\";\nexport const URIAlpha = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nexport const DecimalDigit = \"0123456789\";\nexport const URIMark = \"-_.!~*'()\";\nexport const URIUnescaped = URIAlpha + DecimalDigit + URIMark;\n\n// ECMA262 21.1.3.17.1\nexport function SplitMatch(realm: Realm, S: string, q: number, R: string): false | number {\n  // 1. Assert: Type(R) is String.\n  invariant(typeof R === \"string\", \"expected a string\");\n\n  // 2. Let r be the number of code units in R.\n  let r = R.length;\n\n  // 3. Let s be the number of code units in S.\n  let s = S.length;\n\n  // 4. If q+r > s, return false.\n  if (q + r > s) return false;\n\n  // 5. If there exists an integer i between 0 (inclusive) and r (exclusive) such that the code unit at index\n  //    q+i of S is different from the code unit at index i of R, return false.\n  for (let i = 0; i < r; i++) {\n    if (S[q + i] !== R[i]) {\n      return false;\n    }\n  }\n\n  // 6. Return q+r.\n  return q + r;\n}\n\n// ECMA262 7.2.1\nexport function RequireObjectCoercible<T: Value>(realm: Realm, arg: T): T {\n  if (HasSomeCompatibleType(realm, arg, NullValue, UndefinedValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"null or undefined\");\n  } else {\n    return arg;\n  }\n}\n\n// ECMA262 7.2.12 Abstract Relational Comparison\nexport function AbstractRelationalComparison(realm: Realm, x: ConcreteValue, y: ConcreteValue, LeftFirst: boolean): BooleanValue | UndefinedValue {\n  let px, py;\n\n  // 1. If the LeftFirst flag is true, then\n  if (LeftFirst) {\n    // a. Let px be ? ToPrimitive(x, hint Number).\n    px = ToPrimitive(realm, x, \"number\");\n\n    // b. Let py be ? ToPrimitive(y, hint Number).\n    py = ToPrimitive(realm, y, \"number\");\n  } else { // 2. Else the order of evaluation needs to be reversed to preserve left to right evaluation\n    // a. Let py be ? ToPrimitive(y, hint Number).\n    py = ToPrimitive(realm, y, \"number\");\n\n    // b. Let px be ? ToPrimitive(x, hint Number).\n    px = ToPrimitive(realm, x, \"number\");\n  }\n\n  // 3. If both px and py are Strings, then\n  if (px instanceof StringValue && py instanceof StringValue) {\n    // a. If py is a prefix of px, return false. (A String value p is a prefix of String value q if q can be the result of concatenating p and some other String r. Note that any String is a prefix of itself, because r may be the empty String.)\n    if (px.value.startsWith(py.value)) return realm.intrinsics.false;\n\n    // b. If px is a prefix of py, return true.\n    if (py.value.startsWith(px.value)) return realm.intrinsics.true;\n\n    // c. Let k be the smallest nonnegative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)\n    let k = 0;\n    while (px.value.charCodeAt(k) === py.value.charCodeAt(k)) {\n      k += 1;\n    }\n\n    // d. Let m be the integer that is the code unit value at index k within px.\n    let m = px.value.charCodeAt(k);\n\n    // e. Let n be the integer that is the code unit value at index k within py.\n    let n = py.value.charCodeAt(k);\n\n    // f. If m < n, return true. Otherwise, return false.\n    return m < n ? realm.intrinsics.true : realm.intrinsics.false;\n  } else { // 4. Else,\n    // a. Let nx be ? ToNumber(px). Because px and py are primitive values evaluation order is not important.\n    let nx = ToNumber(realm, px);\n\n    // b. Let ny be ? ToNumber(py).\n    let ny = ToNumber(realm, py);\n\n    // c. If nx is NaN, return undefined.\n    if (isNaN(nx)) return realm.intrinsics.undefined;\n\n    // d. If ny is NaN, return undefined.\n    if (isNaN(ny)) return realm.intrinsics.undefined;\n\n    // e. If nx and ny are the same Number value, return false.\n    if (Object.is(nx, ny)) {\n      return realm.intrinsics.false;\n    }\n\n    // f. If nx is +0 and ny is -0, return false.\n    if (Object.is(nx, +0) && Object.is(ny, -0)) {\n      return realm.intrinsics.false;\n    }\n\n    // g. If nx is -0 and ny is +0, return false.\n    if (Object.is(nx, -0) && Object.is(ny, +0)) {\n      return realm.intrinsics.false;\n    }\n\n    // h. If nx is +∞, return false.\n    // i. If ny is +∞, return true.\n    // j. If ny is -∞, return false.\n    // k. If nx is -∞, return true.\n\n    // i. If the mathematical value of nx is less than the mathematical value of ny —note that these\n    //    mathematical values are both finite and not both zero—return true. Otherwise, return false.\n    if (nx < ny) {\n      return realm.intrinsics.true;\n    } else {\n      return realm.intrinsics.false;\n    }\n  }\n}\n\n// ECMA262 7.2.13\nexport function AbstractEqualityComparison(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. If Type(x) is the same as Type(y), then\n  if (x.getType() === y.getType()) {\n    // a. Return the result of performing Strict Equality Comparison x === y.\n    return StrictEqualityComparison(realm, x, y);\n  }\n\n  // 2. If x is null and y is undefined, return true.\n  if (x instanceof NullValue && y instanceof UndefinedValue) {\n    return true;\n  }\n\n  // 3. If x is undefined and y is null, return true.\n  if (x instanceof UndefinedValue && y instanceof NullValue) {\n    return true;\n  }\n\n  // 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y).\n  if (x instanceof NumberValue && y instanceof StringValue) {\n    return AbstractEqualityComparison(realm, x, new NumberValue(realm, ToNumber(realm, y)));\n  }\n\n  // 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y.\n  if (x instanceof StringValue && y instanceof NumberValue) {\n    return AbstractEqualityComparison(realm, new NumberValue(realm, ToNumber(realm, x)), y);\n  }\n\n  // 6. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.\n  if (x instanceof BooleanValue) {\n    return AbstractEqualityComparison(realm, new NumberValue(realm, ToNumber(realm, x)), y);\n  }\n\n  // 7. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).\n  if (y instanceof BooleanValue) {\n    return AbstractEqualityComparison(realm, x, new NumberValue(realm, ToNumber(realm, y)));\n  }\n\n  // 8. If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).\n  if ((x instanceof StringValue || x instanceof NumberValue || x instanceof SymbolValue) && y instanceof ObjectValue) {\n    return AbstractEqualityComparison(realm, x, ToPrimitive(realm, y));\n  }\n\n  // 9. If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.\n  if (x instanceof ObjectValue && (y instanceof StringValue || y instanceof NumberValue || y instanceof SymbolValue)) {\n    return AbstractEqualityComparison(realm, ToPrimitive(realm, x), y);\n  }\n\n  // 10. Return false.\n  return false;\n}\n\n// ECMA262 7.2.14 Strict Equality Comparison\nexport function StrictEqualityComparison(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. If Type(x) is different from Type(y), return false.\n  if (x.getType() !== y.getType()) {\n    return false;\n  }\n\n  // 2. If Type(x) is Number, then\n  if (x instanceof NumberValue && y instanceof NumberValue) {\n    // a. If x is NaN, return false.\n    if (isNaN(x.value)) return false;\n\n    // b. If y is NaN, return false.\n    if (isNaN(y.value)) return false;\n\n    // c. If x is the same Number value as y, return true.\n    // d. If x is +0 and y is -0, return true. (handled by c)\n    // e. If x is -0 and y is +0, return true. (handled by c)\n    if (x.value === y.value) return true;\n\n    // f. Return false.\n    return false;\n  }\n\n  // 3. Return SameValueNonNumber(x, y).\n  return SameValueNonNumber(realm, x, y);\n}\n\nexport function StrictEqualityComparisonPartial(realm: Realm, x: Value, y: Value): boolean {\n  return StrictEqualityComparison(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());\n}\n\n// ECMA262 7.2.10\nexport function SameValueZero(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. If Type(x) is different from Type(y), return false.\n  if (x.getType() !== y.getType()) {\n    return false;\n  }\n\n  // 2. If Type(x) is Number, then\n  if (x instanceof NumberValue) {\n    invariant(y instanceof NumberValue);\n\n    // a. If x is NaN and y is NaN, return true.\n    if (isNaN(x.value) && isNaN(y.value)) return true;\n\n    // b. If x is +0 and y is -0, return true.\n    if (Object.is(x.value, +0) && Object.is(y.value, -0)) return true;\n\n    // c. If x is -0 and y is +0, return true.\n    if (Object.is(x.value, -0) && Object.is(y.value, +0)) return true;\n\n    // d. If x is the same Number value as y, return true.\n    if (x.value === y.value) return true;\n\n    // e. Return false.\n    return false;\n  }\n\n  // 3. Return SameValueNonNumber(x, y).\n  return SameValueNonNumber(realm, x, y);\n}\n\nexport function SameValueZeroPartial(realm: Realm, x: Value, y: Value): boolean {\n  return SameValueZero(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());\n}\n\n// ECMA262 7.2.9\nexport function SameValue(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. If Type(x) is different from Type(y), return false.\n  if (x.getType() !== y.getType()) return false;\n\n  // 2. If Type(x) is Number, then\n  if (x instanceof NumberValue && y instanceof NumberValue) {\n    // a. If x is NaN and y is NaN, return true.\n    if (isNaN(x.value) && isNaN(y.value)) return true;\n\n    // b. If x is +0 and y is -0, return false.\n    if (Object.is(x.value, +0) && Object.is(y.value, -0)) return false;\n\n    // c. If x is -0 and y is +0, return false.\n    if (Object.is(x.value, -0) && Object.is(y.value, +0)) return false;\n\n    // d. If x is the same Number value as y, return true.\n    if (x.value === y.value) return true;\n\n    // e. Return false.\n    return false;\n  }\n\n  // 3. Return SameValueNonNumber(x, y).\n  return SameValueNonNumber(realm, x, y);\n}\n\nexport function SameValuePartial(realm: Realm, x: Value, y: Value): boolean {\n  if (x instanceof AbstractValue || y instanceof AbstractValue) {\n    let values = ValuesDomain.meetValues(realm, x, y);\n    if (!values.isTop()) return values.getElements().size === 1;\n  }\n\n  return SameValue(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());\n}\n\n// ECMA262 7.2.11\nexport function SameValueNonNumber(realm: Realm, x: ConcreteValue, y: ConcreteValue): boolean {\n  // 1. Assert: Type(x) is not Number.\n  invariant(!(x instanceof NumberValue), \"numbers not allowed\");\n\n  // 2. Assert: Type(x) is the same as Type(y).\n  invariant(x.getType() === y.getType(), \"must be same type\");\n\n  // 3. If Type(x) is Undefined, return true.\n  if (x instanceof UndefinedValue) return true;\n\n  // 4. If Type(x) is Null, return true.\n  if (x instanceof NullValue) return true;\n\n  // 5. If Type(x) is String, then\n  if (x instanceof StringValue && y instanceof StringValue) {\n    // a. If x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.\n    return x.value === y.value;\n  }\n\n  // 6. If Type(x) is Boolean, then\n  if (x instanceof BooleanValue && y instanceof BooleanValue) {\n    // a. If x and y are both true or both false, return true; otherwise, return false.\n    return x.value === y.value;\n  }\n\n  // 7. If Type(x) is Symbol, then\n  if (x instanceof SymbolValue) {\n    // a. If x and y are both the same Symbol value, return true; otherwise, return false.\n    return x === y;\n  }\n\n  // 8. Return true if x and y are the same Object value. Otherwise, return false.\n  return x === y;\n}\n\n// Checks if two property keys are identical.\nexport function SamePropertyKey(realm: Realm, x: PropertyKeyValue, y: PropertyKeyValue) {\n  if (typeof x === \"string\" && typeof y === \"string\") {\n    return x === y;\n  }\n  if (x instanceof StringValue && y instanceof StringValue) {\n    return x.value === y.value;\n  }\n  if (x instanceof SymbolValue && y instanceof SymbolValue) {\n    return x === y;\n  }\n  return false;\n}\n\n// ECMA262 12.8.5 Applying the Additive Operators to Numbers\nexport function Add(realm: Realm, a: number, b: number, subtract?: boolean = false): NumberValue {\n  // If either operand is NaN, the result is NaN.\n  if (isNaN(a) || isNaN(b)) {\n    return realm.intrinsics.NaN;\n  }\n\n  // The sum of two infinities of opposite sign is NaN.\n  // The sum of two infinities of the same sign is the infinity of that sign.\n  // The sum of an infinity and a finite value is equal to the infinite operand.\n  // The sum of two negative zeroes is -0. The sum of two positive zeroes, or of two zeroes of opposite sign, is +0.\n  // The sum of a zero and a nonzero finite value is equal to the nonzero operand.\n  // The sum of two nonzero finite values of the same magnitude and opposite sign is +0.\n\n  let anum = a;\n  let bnum = b;\n\n  // The - operator performs subtraction when applied to two operands of numeric type,\n  // producing the difference of its operands; the left operand is the minuend and the right\n  // operand is the subtrahend. Given numeric operands a and b, it is always the case that\n  // a-b produces the same result as a+(-b).\n  if (subtract) {\n    bnum = -bnum;\n  }\n\n  return new NumberValue(realm, anum + bnum);\n}\n\n// ECMA262 12.10.4\nexport function InstanceofOperator(realm: Realm, O: Value, C: Value): boolean {\n  // 1. If Type(C) is not Object, throw a TypeError exception.\n  if (!C.mightBeObject()) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Expecting a function in instanceof check\");\n  }\n\n  // 2. Let instOfHandler be ? GetMethod(C, @@hasInstance).\n  let instOfHandler = GetMethod(realm, C, realm.intrinsics.SymbolHasInstance);\n\n  // 3. If instOfHandler is not undefined, then\n  if (!(instOfHandler instanceof UndefinedValue)) {\n    // a. Return ToBoolean(? Call(instOfHandler, C, « O »)).\n    return ToBooleanPartial(realm, Call(realm, instOfHandler, C, [O]));\n  }\n\n  // 4. If IsCallable(C) is false, throw a TypeError exception.\n  if (IsCallable(realm, C) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Expecting a function in instanceof check\");\n  }\n\n  // 5. Return ? OrdinaryHasInstance(C, O).\n  return OrdinaryHasInstance(realm, C, O);\n}\n\n// ECMA262 7.3.19\nexport function OrdinaryHasInstance(realm: Realm, C: Value, O: Value): boolean {\n  // 1. If IsCallable(C) is false, return false.\n  if (IsCallable(realm, C) === false) return false;\n  invariant(C instanceof ObjectValue);\n\n  // 2. If C has a [[BoundTargetFunction]] internal slot, then\n  if (C instanceof BoundFunctionValue) {\n    // a. Let BC be the value of C's [[BoundTargetFunction]] internal slot.\n    let BC = C.$BoundTargetFunction;\n\n    // b. Return ? InstanceofOperator(O, BC).\n    return InstanceofOperator(realm, O, BC);\n  }\n\n  // 3. If Type(O) is not Object, return false.\n  O = O.throwIfNotConcrete();\n  if (!(O instanceof ObjectValue)) return false;\n\n  // 4. Let P be ? Get(C, \"prototype\").\n  let P = Get(realm, C, \"prototype\").throwIfNotConcrete();\n\n  // 5. If Type(P) is not Object, throw a TypeError exception.\n  if (!(P instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(P) is not Object\");\n  }\n\n  // 6. Repeat\n  while (true) {\n    // a. Let O be ? O.[[GetPrototypeOf]]().\n    O = O.$GetPrototypeOf();\n\n    // b. If O is null, return false.\n    if (O instanceof NullValue) return false;\n\n    // c. If SameValue(P, O) is true, return true.\n    if (SameValue(realm, P, O) === true) return true;\n  }\n\n  return false;\n}\n\n//\nexport function Type(realm: Realm, val: Value): string {\n  if (val instanceof UndefinedValue) {\n    return \"Undefined\";\n  } else if (val instanceof NullValue) {\n    return \"Null\";\n  } else if (HasCompatibleType(realm, val, BooleanValue)) {\n    return \"Boolean\";\n  } else if (HasCompatibleType(realm, val, StringValue)) {\n    return \"String\";\n  } else if (HasCompatibleType(realm, val, SymbolValue)) {\n    return \"Symbol\";\n  } else if (HasCompatibleType(realm, val, NumberValue)) {\n    return \"Number\";\n  } else if (!val.mightNotBeObject()) {\n    return \"Object\";\n  } else {\n    invariant(val instanceof AbstractValue);\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(val);\n  }\n}\n\n// ECMA262 19.4.3.2.1\nexport function SymbolDescriptiveString(realm: Realm, sym: SymbolValue): string {\n  // 1. Assert: Type(sym) is Symbol.\n  invariant(sym instanceof SymbolValue, \"expected symbol\");\n\n  // 2. Let desc be sym's [[Description]] value.\n  let desc = sym.$Description;\n\n  // 3. If desc is undefined, let desc be the empty string.\n  if (!desc) desc = \"\";\n\n  // 4. Assert: Type(desc) is String.\n  invariant(typeof desc === \"string\", \"expected string\");\n\n  // 5. Return the result of concatenating the strings \"Symbol(\", desc, and \")\".\n  return `Symbol(${desc})`;\n}\n\n// ECMA262 6.2.2.5\nexport function UpdateEmpty(realm: Realm, completionRecord: Value | Completion, value: Value): Value | Completion {\n  // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n  if (completionRecord instanceof ReturnCompletion || completionRecord instanceof ThrowCompletion) {\n    invariant(completionRecord.value, \"expected completion record to have a value\");\n  }\n\n  // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n  if (completionRecord instanceof EmptyValue) return value;\n  if (completionRecord instanceof Value ||\n    (completionRecord.value && !(completionRecord.value instanceof EmptyValue))) return completionRecord;\n\n  // 3. Return Completion{[[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.'\n  completionRecord.value = value;\n  return completionRecord;\n\n}\n"]}