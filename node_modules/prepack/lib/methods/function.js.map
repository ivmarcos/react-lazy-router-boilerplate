{"version":3,"sources":["../../src/methods/function.js"],"names":["FindVarScopedDeclarations","FunctionDeclarationInstantiation","SetFunctionName","FunctionInitialize","GeneratorFunctionCreate","AddRestrictedFunctionProperties","$Call","$Construct","FunctionAllocate","BoundFunctionCreate","PerformEval","EvaluateStatements","FunctionCreate","EvalDeclarationInstantiation","MakeMethod","t","ast_node","FindVarScopedDeclarationsFor","ast","level","statements","type","body","astIfStatement","consequent","alternate","astForStatement","init","astForInStatement","left","astForOfStatement","cases","switchCase","concat","astTryStatement","block","finalizer","push","handler","kind","decls","statement","realm","func","argumentsList","calleeContext","getRunningContext","env","lexicalEnvironment","envRec","environmentRecord","code","$ECMAScriptCode","undefined","strict","$Strict","formals","$FormalParameters","parameterNames","Object","create","param","paramBindings","getBindingIdentifiers","name","hasDuplicates","identifiers","length","keys","simpleParameterList","hasParameterExpressions","varNames","node","varDeclarations","lexicalNames","functionNames","functionsToInitialize","reverse","d","fn","indexOf","unshift","argumentsObjectNeeded","$ThisMode","paramName","alreadyDeclared","HasBinding","CreateMutableBinding","InitializeBinding","intrinsics","ao","CreateImmutableBinding","iteratorRecord","i","value","lhs","varEnv","varEnvRec","instantiatedVarNames","slice","n","variableEnvironment","initialValue","GetBindingValue","lexEnv","lexEnvRec","lexDeclarations","dn","f","fo","evaluate","SetMutableBinding","empty","F","prefix","getExtensible","description","$Description","emptyString","enumerable","writable","configurable","ParameterList","Body","Scope","isNewObject","len","FormalParameter","Strict","$Environment","$ScriptOrModule","functionPrototype","Generator","thrower","ThrowTypeError","desc","get","set","thisArgument","argsList","InternalCall","tracerIndex","tracer","tracers","nextIndex","detourResult","detourCall","$FunctionKind","callerContext","result","t1","beforeCall","popContext","t2","afterCall","newTarget","InternalConstruct","$ConstructorKind","constructorEnv","mightBeObject","throwIfNotConcreteObject","mightBeUndefined","throwIfNotConcrete","envRecThisBinding","GetThisBinding","functionKind","needsConstruct","$Prototype","setExtensible","$Realm","$BoundCall","target","$BoundTargetFunction","boundThis","$BoundThis","boundArgs","$BoundArguments","args","$BoundConstruct","targetFunction","proto","$GetPrototypeOf","obj","x","evalRealm","strictCaller","direct","script","program","blockStatement","directives","strictEval","ctx","$GlobalEnv","suspend","evalCxt","setFunction","setRealm","ScriptOrModule","pushContext","e","directive","resume","blockValue","strictCode","blockEnv","res","evaluateAbstractCompletion","get_captured_effects","stop_effect_capture","_c","_g","b","p","_o","restoreBindings","restoreProperties","apply_effects","joined_effects","prototype","FunctionPrototype","allocKind","HasLexicalDeclaration","SyntaxError","thisLex","thisEnvRec","createErrorThrowCompletion","parent","declaredFunctionNames","fnDefinable","CanDeclareGlobalFunction","TypeError","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","s","CreateGlobalFunctionBinding","bindingExists","CreateGlobalVarBinding","homeObject","$HomeObject"],"mappings":";;;;;;;;8QAAA;;;;;;;;;QAiDgBA,yB,GAAAA,yB;QAsEAC,gC,GAAAA,gC;QAiVAC,e,GAAAA,e;QAyCAC,kB,GAAAA,kB;QAqDAC,uB,GAAAA,uB;QAYAC,+B,GAAAA,+B;QAiBAC,K,GAAAA,K;QA8DAC,U,GAAAA,U;QA8FAC,gB,GAAAA,gB;QAsGAC,mB,GAAAA,mB;QA6CAC,W,GAAAA,W;QAiIAC,kB,GAAAA,kB;QAoDAC,c,GAAAA,c;QAsCAC,4B,GAAAA,4B;QAuNAC,U,GAAAA,U;;AAtxChB;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;IAAYC,C;;;;;;AAmBL,SAASf,yBAAT,CAAmCgB,QAAnC,EAA0E;AAC/E,WAASC,4BAAT,CAAsCC,GAAtC,EAAsDC,KAAtD,EAAqE;AACnE,QAAIC,aAAa,EAAjB;AACA,YAAQF,IAAIG,IAAZ;AACA,WAAK,SAAL;AACED,qBAAeF,GAAF,CAA+BI,IAA5C;AACA;AACF,WAAK,gBAAL;AACEF,qBAAeF,GAAF,CAAsCI,IAAnD;AACA;AACF,WAAK,kBAAL;AACEF,qBAAa,CAAGF,GAAF,CAAwCI,IAAzC,CAAb;AACA;AACF,WAAK,gBAAL;AACEF,qBAAa,CAAGF,GAAF,CAAsCI,IAAvC,CAAb;AACA;AACF,WAAK,aAAL;AACE,YAAIC,iBAAwCL,GAA5C;AACAE,qBAAa,CAACG,eAAeC,UAAhB,EAA4BD,eAAeE,SAA3C,CAAb;AACA;AACF,WAAK,cAAL;AACE,YAAIC,kBAA0CR,GAA9C;AACAE,qBAAa,CAACM,gBAAgBC,IAAjB,EAAuBD,gBAAgBJ,IAAvC,CAAb;AACA;AACF,WAAK,gBAAL;AACE,YAAIM,oBAA8CV,GAAlD;AACAE,qBAAa,CAACQ,kBAAkBC,IAAnB,EAAyBD,kBAAkBN,IAA3C,CAAb;AACA;AACF,WAAK,gBAAL;AACE,YAAIQ,oBAA8CZ,GAAlD;AACAE,qBAAa,CAACU,kBAAkBD,IAAnB,EAAyBC,kBAAkBR,IAA3C,CAAb;AACA;AACF,WAAK,kBAAL;AACEF,qBAAa,CAAGF,GAAF,CAAwCI,IAAzC,CAAb;AACA;AACF,WAAK,eAAL;AACEF,qBAAa,CAAGF,GAAF,CAAqCI,IAAtC,CAAb;AACA;AACF,WAAK,iBAAL;AAAA;AAAA;AAAA;;AAAA;AACE,+BAAyBJ,GAAF,CAAuCa,KAA9D,8HAAqE;AAAA,gBAA5DC,UAA4D;;AACnEZ,yBAAaA,WAAWa,MAAX,CAAkBD,WAAWR,UAA7B,CAAb;AACD;AAHH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIE;AACF,WAAK,cAAL;AACE,YAAIU,kBAA0ChB,GAA9C;AACAE,qBAAa,CAACc,gBAAgBC,KAAjB,CAAb;AACA,YAAID,gBAAgBE,SAApB,EAA+BhB,WAAWiB,IAAX,CAAgBH,gBAAgBE,SAAhC;AAC/B,YAAIF,gBAAgBI,OAApB,EAA6BlB,WAAWiB,IAAX,CAAgBH,gBAAgBI,OAAhB,CAAwBhB,IAAxC;AAC7B;AACF,WAAK,qBAAL;AACE,eAAOJ,IAAIqB,IAAJ,KAAa,KAAb,GAAqB,CAACrB,GAAD,CAArB,GAA6B,EAApC;AACF,WAAK,qBAAL;AACE,eAAOC,QAAQ,CAAR,GAAY,CAACD,GAAD,CAAZ,GAAoB,EAA3B;AACF;AACE,eAAO,EAAP;AAnDF;;AAsDA,QAAIsB,QAAQ,EAAZ;AAxDmE;AAAA;AAAA;;AAAA;AAyDnE,4BAAsBpB,UAAtB,mIAAkC;AAAA,YAAzBqB,SAAyB;;AAChC,YAAIA,SAAJ,EAAe;AACbD,kBAAQA,MAAMP,MAAN,CAAahB,6BAA6BwB,SAA7B,EAAwCtB,QAAQ,CAAhD,CAAb,CAAR;AACD;AACF;AA7DkE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+DnE,WAAOqB,KAAP;AACD;AACD,SAAOvB,6BAA6BD,QAA7B,EAAuC,CAAvC,CAAP;AACD;;AAED;AACO,SAASf,gCAAT,CAA0CyC,KAA1C,EAAwDC,IAAxD,EAA6EC,aAA7E,EAAsH;AAC3H;AACA,MAAIC,gBAAgBH,MAAMI,iBAAN,EAApB;;AAEA;AACA,MAAIC,MAAMF,cAAcG,kBAAxB;;AAEA;AACA,MAAIC,SAASF,IAAIG,iBAAjB;;AAEA;AACA,MAAIC,OAAOR,KAAKS,eAAhB;AACA,2BAAUD,SAASE,SAAnB;;AAEA;AACA,MAAIC,SAASX,KAAKY,OAAlB;;AAEA;AACA,MAAIC,UAAUb,KAAKc,iBAAnB;AACA,2BAAUD,YAAYH,SAAtB;;AAEA;AACA,MAAIK,iBAAiBC,OAAOC,MAAP,CAAc,IAAd,CAArB;AAtB2H;AAAA;AAAA;;AAAA;AAuB3H,0BAAkBJ,OAAlB,mIAA2B;AAAA,UAAlBK,OAAkB;;AACzB,UAAIC,gBAAgB/C,EAAEgD,qBAAF,CAAwBF,OAAxB,EAA+B,IAA/B,CAApB;;AAEA,WAAK,IAAIG,KAAT,IAAiBF,aAAjB,EAAgC;AAC9BJ,uBAAeM,KAAf,IAAuB,CAACN,eAAeM,KAAf,KAAwB,EAAzB,EAA6B/B,MAA7B,CAAoC6B,cAAcE,KAAd,CAApC,CAAvB;AACD;AACF;;AAED;AA/B2H;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgC3H,MAAIC,gBAAgB,KAApB;AACA,OAAK,IAAID,IAAT,IAAiBN,cAAjB,EAAiC;AAC/B,QAAIQ,cAAcR,eAAeM,IAAf,CAAlB;AACA,QAAIE,YAAYC,MAAZ,GAAqB,CAAzB,EAA4BF,gBAAgB,IAAhB;AAC7B;AACDP,mBAAiBC,OAAOS,IAAP,CAAYV,cAAZ,CAAjB;;AAEA;AACA,MAAIW,sBAAsB,IAA1B;AAxC2H;AAAA;AAAA;;AAAA;AAyC3H,0BAAkBb,OAAlB,mIAA2B;AAAA,UAAlBK,OAAkB;;AACzB,UAAIA,QAAMxC,IAAN,KAAe,YAAnB,EAAiC;AAC/BgD,8BAAsB,KAAtB;AACA;AACD;AACF;;AAED;AAhD2H;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiD3H,MAAIC,0BAA0B,KAA9B;AACA,2BAAUd,YAAYH,SAAtB;AAlD2H;AAAA;AAAA;;AAAA;AAmD3H,0BAAkBG,OAAlB,mIAA2B;AAAA,UAAlBK,OAAkB;;AACzB,UAAI,gCAAmBnB,KAAnB,EAA0BmB,OAA1B,CAAJ,EAAsC;AACpCS,kCAA0B,IAA1B;AACA;AACD;AACF;;AAED;AA1D2H;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA2D3H,MAAIC,WAAW,EAAf;AACA,0BAASpB,IAAT,EAAe,UAAUqB,IAAV,EAAgB;AAC7B,QAAIA,KAAKnD,IAAL,KAAc,qBAAd,IAAuCmD,KAAKjC,IAAL,KAAc,KAAzD,EAAgE;AAC9DgC,iBAAWA,SAAStC,MAAT,CAAgB0B,OAAOS,IAAP,CAAYrD,EAAEgD,qBAAF,CAAwBS,IAAxB,CAAZ,CAAhB,CAAX;AACD;;AAED,QAAIA,KAAKnD,IAAL,KAAc,oBAAd,IAAsCmD,KAAKnD,IAAL,KAAc,qBAAxD,EAA+E;AAC7E,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAVD;;AAYA;AACA,MAAIoD,kBAAkBzE,0BAA0BmD,IAA1B,CAAtB;;AAEA;AACA,MAAIuB,eAAe,EAAnB;;AAEA;AACA,MAAIC,gBAAgB,EAApB;;AAEA;AACA,MAAIC,wBAAwB,EAA5B;;AAEA;AApF2H;AAAA;AAAA;;AAAA;AAqF3H,0BAAcH,gBAAgBI,OAAhB,EAAd,mIAAyC;AAAA,UAAhCC,CAAgC;;AACvC;AACA,UAAIA,EAAEzD,IAAF,KAAW,qBAAf,EAAsC;AACpC;AACA,iCAAUyD,EAAEzD,IAAF,KAAW,qBAAX,IAAoCyD,EAAEzD,IAAF,KAAW,sBAAzD;AACA;AACA,YAAI0D,KAAK,wBAAWrC,KAAX,EAAkBoC,CAAlB,EAAqB,CAArB,CAAT;AACA;AACA,YAAIH,cAAcK,OAAd,CAAsBD,EAAtB,IAA4B,CAAhC,EAAmC;AACjC;AACAJ,wBAAcM,OAAd,CAAsBF,EAAtB;AACA;AACA;AACAH,gCAAsBK,OAAtB,CAA8BH,CAA9B;AACD;AACF;AACF;;AAED;AAvG2H;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwG3H,MAAII,wBAAwB,IAA5B;;AAEA;AACA,MAAIvC,KAAKwC,SAAL,KAAmB,SAAvB,EAAkC;AAChC;AACA;AACAD,4BAAwB,KAAxB;AACD,GAJD,MAIO,IAAIxB,eAAesB,OAAf,CAAuB,WAAvB,KAAuC,CAA3C,EAA8C;AAAE;AACrD;AACAE,4BAAwB,KAAxB;AACD,GAHM,MAGA,IAAIZ,4BAA4B,KAAhC,EAAuC;AAAE;AAC9C;AACA,QAAIK,cAAcK,OAAd,CAAsB,WAAtB,KAAsC,CAAtC,IAA2CN,aAAaM,OAAb,CAAqB,WAArB,KAAqC,CAApF,EAAuF;AACrF;AACAE,8BAAwB,IAAxB;AACD;AACF;;AAED;AA1H2H;AAAA;AAAA;;AAAA;AA2H3H,0BAAsBxB,cAAtB,mIAAsC;AAAA,UAA7B0B,SAA6B;;AACpC;AACA,UAAIC,kBAAkBpC,OAAOqC,UAAP,CAAkBF,SAAlB,CAAtB;;AAEA;;AAEA;AACA,UAAIC,oBAAoB,KAAxB,EAA+B;AAC7B;AACApC,eAAOsC,oBAAP,CAA4BH,SAA5B,EAAuC,KAAvC;;AAEA;AACA,YAAInB,kBAAkB,IAAtB,EAA4B;AAC1B;AACAhB,iBAAOuC,iBAAP,CAAyBJ,SAAzB,EAAoC1C,MAAM+C,UAAN,CAAiBpC,SAArD;AACD;AACF;AACF;;AAED;AA9I2H;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+I3H,MAAI6B,0BAA0B,IAA9B,EAAoC;AAClC,QAAIQ,WAAJ;;AAEA;AACA,QAAIpC,WAAW,IAAX,IAAmBe,wBAAwB,KAA/C,EAAsD;AACpD;AACAqB,WAAK,2CAA8BhD,KAA9B,EAAqCE,aAArC,CAAL;AACD,KAHD,MAGO;AAAE;AACP;AACA;AACA,+BAAUY,YAAYH,SAAtB;AACAqC,WAAK,yCAA4BhD,KAA5B,EAAmCC,IAAnC,EAAyCa,OAAzC,EAAkDZ,aAAlD,EAAiEK,MAAjE,CAAL;AACD;;AAED;AACA,QAAIK,WAAW,IAAf,EAAqB;AACnB;AACAL,aAAO0C,sBAAP,CAA8B,WAA9B,EAA2C,KAA3C;AACD,KAHD,MAGO;AAAE;AACP;AACA1C,aAAOsC,oBAAP,CAA4B,WAA5B,EAAyC,KAAzC;AACD;;AAED;AACAtC,WAAOuC,iBAAP,CAAyB,WAAzB,EAAsCE,EAAtC;;AAEA;AACAhC,mBAAerB,IAAf,CAAoB,WAApB;AACD;;AAED;AACA,MAAIuD,iBAAiB,CAArB;;AAEA;AACA,MAAI3B,kBAAkB,IAAtB,EAA4B;AAC1B;AACA,6BAAUT,YAAYH,SAAtB;AACA,SAAK,IAAIwC,IAAI,CAAb,EAAgBA,IAAIrC,QAAQW,MAA5B,EAAoC,EAAE0B,CAAtC,EAAyC;AACvC,UAAIhC,QAAQL,QAAQqC,CAAR,CAAZ;;AAEA,cAAQhC,MAAMxC,IAAd;AACA,aAAK,YAAL;AACE,cAAIyE,QAAQlD,cAAcgD,cAAd,KAAiClD,MAAM+C,UAAN,CAAiBpC,SAA9D;AACA,YAAEuC,cAAF;AACA,cAAIG,MAAM,4BAAerD,KAAf,EAAsBmB,MAAMG,IAA5B,EAAkCV,MAAlC,CAAV;AACA,oCAASZ,KAAT,EAAgBqD,GAAhB,EAAqBD,KAArB;AACA;AACF;AACE,gBAAM,iCAAoB,uBAAgBpD,KAAhB,EAAuB,yDAAvB,CAApB,CAAN;AARF;AAUD;AACF,GAjBD,MAiBO;AAAE;AACP;AACA,6BAAUc,YAAYH,SAAtB;AACA,SAAK,IAAIwC,KAAI,CAAb,EAAgBA,KAAIrC,QAAQW,MAA5B,EAAoC,EAAE0B,EAAtC,EAAyC;AACvC,UAAIhC,SAAQL,QAAQqC,EAAR,CAAZ;;AAEA,cAAQhC,OAAMxC,IAAd;AACA,aAAK,YAAL;AACE,cAAIyE,SAAQlD,cAAcgD,cAAd,KAAiClD,MAAM+C,UAAN,CAAiBpC,SAA9D;AACA,YAAEuC,cAAF;AACA3C,iBAAOuC,iBAAP,CAAyB3B,OAAMG,IAA/B,EAAqC8B,MAArC;AACA;AACF;AACE,gBAAM,iCAAoB,uBAAgBpD,KAAhB,EAAuB,yDAAvB,CAApB,CAAN;AAPF;AASD;AACF;;AAGD;AACA,MAAIsD,eAAJ;AAAA,MAAYC,kBAAZ;AACA,MAAI3B,4BAA4B,KAAhC,EAAuC;AACrC;AACA;AACA,QAAI4B,uBAAuBxC,eAAeyC,KAAf,EAA3B;;AAEA;AALqC;AAAA;AAAA;;AAAA;AAMrC,4BAAc5B,QAAd,mIAAwB;AAAA,YAAf6B,CAAe;;AACtB;AACA,YAAIF,qBAAqBlB,OAArB,CAA6BoB,CAA7B,IAAkC,CAAtC,EAAyC;AACvC;AACAF,+BAAqB7D,IAArB,CAA0B+D,CAA1B;;AAEA;AACAnD,iBAAOsC,oBAAP,CAA4Ba,CAA5B,EAA+B,KAA/B;;AAEA;AACAnD,iBAAOuC,iBAAP,CAAyBY,CAAzB,EAA4B1D,MAAM+C,UAAN,CAAiBpC,SAA7C;AACD;AACF;;AAED;AApBqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBrC2C,aAASjD,GAAT;;AAEA;AACAkD,gBAAYhD,MAAZ;AACD,GAzBD,MAyBO;AAAE;AACP;;AAEA;AACA+C,aAAS,uCAA0BtD,KAA1B,EAAiCK,GAAjC,CAAT;;AAEA;AACAkD,gBAAYD,OAAO9C,iBAAnB;;AAEA;AACAL,kBAAcwD,mBAAd,GAAqCL,MAArC;;AAEA;AACA,QAAIE,wBAAuB,EAA3B;;AAEA;AAfK;AAAA;AAAA;;AAAA;AAgBL,4BAAc3B,QAAd,mIAAwB;AAAA,YAAf6B,EAAe;;AACtB;AACA,YAAIF,sBAAqBlB,OAArB,CAA6BoB,EAA7B,IAAkC,CAAtC,EAAyC;AACvC;AACAF,gCAAqB7D,IAArB,CAA0B+D,EAA1B;;AAEA;AACAH,oBAAUV,oBAAV,CAA+Ba,EAA/B,EAAkC,KAAlC;;AAEA;AACA,cAAIE,qBAAJ;AACA,cAAI5C,eAAesB,OAAf,CAAuBoB,EAAvB,IAA4B,CAA5B,IAAiCzB,cAAcK,OAAd,CAAsBoB,EAAtB,IAA2B,CAAhE,EAAmE;AACjEE,2BAAe5D,MAAM+C,UAAN,CAAiBpC,SAAhC;AACD,WAFD,MAEO;AAAE;AACP;AACAiD,2BAAerD,OAAOsD,eAAP,CAAuBH,EAAvB,EAA0B,KAA1B,CAAf;AACD;;AAED;AACAH,oBAAUT,iBAAV,CAA4BY,EAA5B,EAA+BE,YAA/B;;AAEA;AACD;AACF;AAvCI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwCN;;AAED;;AAEA,MAAIE,eAAJ;;AAEA;AACA,MAAIlD,WAAW,KAAf,EAAsB;AACpB;AACAkD,aAAS,uCAA0B9D,KAA1B,EAAiCsD,MAAjC,CAAT;;AAEA;AACD,GALD,MAKO;AAAE;AACPQ,aAASR,MAAT;AACD;;AAED;AACA,MAAIS,YAAYD,OAAOtD,iBAAvB;;AAEA;AACAL,gBAAcG,kBAAd,GAAmCwD,MAAnC;;AAEA;AACA,MAAIE,kBAAkB,EAAtB;;AAEA;AAjT2H;AAAA;AAAA;;AAAA;AAkT3H,2BAAcA,eAAd,wIAA+B;AAAA,UAAtB5B,EAAsB;;AAC7B;AACA;AAF6B;AAAA;AAAA;;AAAA;AAG7B,+BAAe,wBAAWpC,KAAX,EAAkBoC,EAAlB,CAAf,wIAAqC;AAAA,cAA5B6B,EAA4B;;AACnC;AACA,cAAI7B,GAAEvC,IAAF,KAAW,OAAf,EAAwB;AACtB;AACAkE,sBAAUd,sBAAV,CAAiCgB,EAAjC,EAAqC,IAArC;AACD,WAHD,MAGO;AAAE;AACP;AACAF,sBAAUlB,oBAAV,CAA+BoB,EAA/B,EAAmC,KAAnC;AACD;AACF;AAZ4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAa9B;;AAED;AAjU2H;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAkU3H,2BAAc/B,qBAAd,wIAAqC;AAAA,UAA5BgC,CAA4B;;AACnC;AACA,UAAI7B,MAAK,wBAAWrC,KAAX,EAAkBkE,CAAlB,EAAqB,CAArB,CAAT;AACA;AACA,UAAIC,KAAKL,OAAOM,QAAP,CAAgBF,CAAhB,EAAmBtD,MAAnB,CAAT;AACA,+BAAUuD,0BAAV;AACA;AACAZ,gBAAUc,iBAAV,CAA4BhC,GAA5B,EAAgC8B,EAAhC,EAAoC,KAApC;AACD;;AAED;AA5U2H;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6U3H,SAAOnE,MAAM+C,UAAN,CAAiBuB,KAAxB;AACD;;AAED;AACO,SAAS9G,eAAT,CAAyBwC,KAAzB,EAAuCuE,CAAvC,EAAuDjD,IAAvD,EAA+EkD,MAA/E,EAAyG;AAC9G;AACA,2BAAUD,EAAEE,aAAF,EAAV,EAA6B,+DAA7B;;AAEA;AACA,2BAAU,OAAOnD,IAAP,KAAgB,QAAhB,IAA4BA,kCAA5B,IAA2DA,kCAArE,EAAkG,wCAAlG;AACA,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8BA,OAAO,uBAAgBtB,KAAhB,EAAuBsB,IAAvB,CAAP;;AAE9B;AACA,2BAAUkD,WAAW7D,SAAX,IAAwB,OAAO6D,MAAP,KAAkB,QAApD,EAA8D,0CAA9D;;AAEA;AACA,MAAIlD,kCAAJ,EAAiC;AAC/B;AACA,QAAIoD,cAAcpD,KAAKqD,YAAvB;;AAEA;AACA,QAAID,gBAAgB/D,SAApB,EAA+B;AAC7BW,aAAOtB,MAAM+C,UAAN,CAAiB6B,WAAxB;AACD,KAFD,MAEO;AAAE;AACP,+BAAUF,gBAAgB,IAA1B;AACApD,aAAO,uBAAgBtB,KAAhB,QAA2B0E,WAA3B,OAAP;AACD;AACF;;AAED;AACA,MAAIF,MAAJ,EAAY;AACV;AACAlD,WAAO,uBAAgBtB,KAAhB,EAA0BwE,MAA1B,SAAoClD,KAAK8B,KAAzC,CAAP;AACD;;AAED;AACA,SAAO,mCAAsBpD,KAAtB,EAA6BuE,CAA7B,EAAgC,MAAhC,EAAwC;AAC7CnB,WAAO9B,IADsC;AAE7CuD,gBAAY,KAFiC;AAG7CC,cAAU,KAHmC;AAI7CC,kBAAc;AAJ+B,GAAxC,CAAP;AAMD;;AAED;AACO,SAAStH,kBAAT,CAA4BuC,KAA5B,EAA0CuE,CAA1C,EAA4D1E,IAA5D,EAAiGmF,aAAjG,EAAsIC,IAAtI,EAAqKC,KAArK,EAA+M;AACpN;AACA,2BAAUlF,MAAMmF,WAAN,CAAkBZ,CAAlB,CAAV;;AAEA;AACA,2BAAUA,EAAEE,aAAF,EAAV,EAA6B,kDAA7B;;AAEA;AACA,MAAIW,MAAM,CAAV;AARoN;AAAA;AAAA;;AAAA;AASpN,2BAA4BJ,aAA5B,wIAA2C;AAAA,UAAlCK,eAAkC;;AACzC,UAAIA,gBAAgB1G,IAAhB,KAAyB,mBAA7B,EAAkD;AAChD;AACD;AACDyG,aAAO,CAAP;AACD;;AAED;AAhBoN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiBpN,qCAAsBpF,KAAtB,EAA6BuE,CAA7B,EAAgC,QAAhC,EAA0C;AACxCnB,WAAO,uBAAgBpD,KAAhB,EAAuBoF,GAAvB,CADiC;AAExCN,cAAU,KAF8B;AAGxCD,gBAAY,KAH4B;AAIxCE,kBAAc;AAJ0B,GAA1C;;AAOA;AACA,MAAIO,SAASf,EAAE1D,OAAf;;AAEA;AACA0D,IAAEgB,YAAF,GAAiBL,KAAjB;;AAEA;AACAX,IAAExD,iBAAF,GAAsBiE,aAAtB;;AAEA;AACAT,IAAE7D,eAAF,GAAoBuE,IAApB;;AAEA;AACAV,IAAEiB,eAAF,GAAoB,qCAAwBxF,KAAxB,CAApB;;AAEA;AACA,MAAIH,SAAS,OAAb,EAAsB;AACpB0E,MAAE9B,SAAF,GAAc,SAAd;AACD,GAFD,MAEO,IAAI6C,WAAW,IAAf,EAAqB;AAAE;AAC5Bf,MAAE9B,SAAF,GAAc,QAAd;AACD,GAFM,MAEA;AAAE;AACP8B,MAAE9B,SAAF,GAAc,QAAd;AACD;;AAED;AACA,SAAO8B,CAAP;AACD;;AAED;AACO,SAAS7G,uBAAT,CAAiCsC,KAAjC,EAA+CH,IAA/C,EAA0EmF,aAA1E,EAA+GC,IAA/G,EAA8IC,KAA9I,EAAyKI,MAAzK,EAAyM;AAC9M;AACA,MAAIG,oBAAoBzF,MAAM+C,UAAN,CAAiB2C,SAAzC;;AAEA;AACA,MAAInB,IAAIzG,iBAAiBkC,KAAjB,EAAwByF,iBAAxB,EAA2CH,MAA3C,EAAmD,WAAnD,CAAR;;AAEA;AACA,SAAO7H,mBAAmBuC,KAAnB,EAA0BuE,CAA1B,EAA6B1E,IAA7B,EAAmCmF,aAAnC,EAAkDC,IAAlD,EAAwDC,KAAxD,CAAP;AACD;;AAED;AACO,SAASvH,+BAAT,CAAyC4G,CAAzC,EAA2DvE,KAA3D,EAAyE;AAC9E;AACA;AACA,MAAI2F,UAAU3F,MAAM+C,UAAN,CAAiB6C,cAA/B;AACA,2BAAUD,OAAV;;AAEA,MAAIE,OAAO;AACTC,SAAKH,OADI;AAETI,SAAKJ,OAFI;AAGTd,gBAAY,KAHH;AAITE,kBAAc;AAJL,GAAX;AAMA;AACA,SAAO,mCAAsB/E,KAAtB,EAA6BuE,CAA7B,EAAgC,WAAhC,EAA6CsB,IAA7C,CAAP;AACD;;AAED;AACO,SAASjI,KAAT,CAAeoC,KAAf,EAA6BuE,CAA7B,EAA+CyB,YAA/C,EAAoEC,QAApE,EAAmG;AACxG,SAAOC,aAAalG,KAAb,EAAoBuE,CAApB,EAAuByB,YAAvB,EAAqCC,QAArC,EAA+C,CAA/C,CAAP;AACD;;AAED,SAASC,YAAT,CAAsBlG,KAAtB,EAAoCuE,CAApC,EAAsDyB,YAAtD,EAA2EC,QAA3E,EAAmGE,WAAnG,EAA+H;AAC7H;AACA,2BAAU5B,iCAAV,EAAsC,yBAAtC;;AAEA;;AAJ6H;AAM3H,QAAI6B,SAASpG,MAAMqG,OAAN,CAAcF,WAAd,CAAb;AACA,QAAIG,YAAY,EAAEH,WAAlB;AACA,QAAII,eAAeH,OAAOI,UAAP,CAAkBjC,CAAlB,EAAqByB,YAArB,EAAmCC,QAAnC,EAA6CtF,SAA7C,EAAwD;AAAA,aAAMuF,aAAalG,KAAb,EAAoBuE,CAApB,EAAuByB,YAAvB,EAAqCC,QAArC,EAA+CK,SAA/C,CAAN;AAAA,KAAxD,CAAnB;AACA,QAAIC,oCAAJ,EAAmC;AAAA,WAAOA;AAAP;AATwF;;AAK7H,SAAOJ,cAAcnG,MAAMqG,OAAN,CAAc5E,MAAnC,EAA2C;AAAA;;AAAA;AAK1C;;AAED;AACA,MAAI8C,EAAEkC,aAAF,KAAoB,kBAAxB,EAA4C,MAAM,iCAAoB,uBAAgBzG,KAAhB,EAAuB,WAAvB,CAApB,CAAN;;AAE5C;AACA,MAAI0G,gBAAgB1G,MAAMI,iBAAN,EAApB;;AAEA;AACA,MAAID,gBAAgB,kCAAuBH,KAAvB,EAA8BuE,CAA9B,EAAiC5D,SAAjC,CAApB;;AAEA,MAAIgG,eAAJ;AACA,MAAI;AAAA;AAAA;AAAA;;AAAA;AACF,6BAAe3G,MAAMqG,OAArB;AAAA,YAASO,EAAT;;AACEA,WAAGC,UAAH,CAActC,CAAd,EAAiByB,YAAjB,EAA+BC,QAA/B,EAAyCtF,SAAzC;AADF,OADE,CAIF;AAJE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKF,6BAAUX,MAAMI,iBAAN,OAA8BD,aAAxC,EAAuD,mDAAvD;;AAEA;AACA,oCAAqBH,KAArB,EAA4BuE,CAA5B,EAA+BpE,aAA/B,EAA8C6F,YAA9C;;AAEA;AACAW,aAAS,oCAAyB3G,KAAzB,EAAgCuE,CAAhC,EAAmC0B,QAAnC,CAAT;AACD,GAZD,SAYU;AACR;AACAjG,UAAM8G,UAAN,CAAiB3G,aAAjB;AACA,6BAAUH,MAAMI,iBAAN,OAA8BsG,aAAxC;;AAHQ;AAAA;AAAA;;AAAA;AAKR,6BAAe1G,MAAMqG,OAArB;AAAA,YAASU,EAAT;;AACEA,WAAGC,SAAH,CAAazC,CAAb,EAAgByB,YAAhB,EAA8BC,QAA9B,EAAwCtF,SAAxC,EAAmDgG,MAAnD;AADF;AALQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOT;;AAED;AACA,MAAIA,+CAAJ,EAAwC;AACtC,WAAOA,OAAOvD,KAAd;AACD;;AAED;AACA,MAAIuD,+CAAJ,EAAwC;AACtC,UAAMA,MAAN;AACD;;AAED;AACA,SAAO3G,MAAM+C,UAAN,CAAiBpC,SAAxB;AACD;;AAED;AACO,SAAS9C,UAAT,CAAoBmC,KAApB,EAAkCuE,CAAlC,EAAoDrE,aAApD,EAAiF+G,SAAjF,EAAsH;AAC3H,SAAOC,kBAAkBlH,KAAlB,EAAyBuE,CAAzB,EAA4BrE,aAA5B,EAA2C+G,SAA3C,EAAsDtG,SAAtD,EAAiE,CAAjE,CAAP;AACD;;AAED,SAASuG,iBAAT,CAA2BlH,KAA3B,EAAyCuE,CAAzC,EAA2DrE,aAA3D,EAAwF+G,SAAxF,EAAgHjB,YAAhH,EAAkJG,WAAlJ,EAAoL;AAClL;AACA,2BAAU5B,iCAAV,EAAsC,mBAAtC;;AAEA;AACA,2BAAU0C,uCAAV,EAA4C,iBAA5C;;AAEA;AACA,MAAIP,gBAAgB1G,MAAMI,iBAAN,EAApB;;AAEA;AACA,MAAIP,OAAO0E,EAAE4C,gBAAb;;AAEA;AACA,MAAInB,iBAAiBrF,SAAjB,IAA8Bd,SAAS,MAA3C,EAAmD;AACjD;AACAmG,mBAAe,2CAA8BhG,KAA9B,EAAqCiH,SAArC,EAAgD,iBAAhD,CAAf;AACD;;AAED;;AAnBkL;AAqBhL,QAAIb,SAASpG,MAAMqG,OAAN,CAAcF,WAAd,CAAb;AACA,QAAIG,YAAY,EAAEH,WAAlB;AACA,QAAII,eAAeH,OAAOI,UAAP,CAAkBjC,CAAlB,EAAqByB,YAArB,EAAmC9F,aAAnC,EAAkD+G,SAAlD,EAA6D;AAAA,aAAMC,kBAAkBlH,KAAlB,EAAyBuE,CAAzB,EAA4BrE,aAA5B,EAA2C+G,SAA3C,EAAsDjB,YAAtD,EAAoEM,SAApE,CAAN;AAAA,KAA7D,CAAnB;AACA,QAAIC,0CAAJ,EAAyC;AAAA,WAAOA;AAAP;AACzC,6BAAUA,iBAAiB5F,SAA3B;AAzBgL;;AAoBlL,SAAOwF,cAAcnG,MAAMqG,OAAN,CAAc5E,MAAnC,EAA2C;AAAA;;AAAA;AAM1C;;AAED;AACA,MAAItB,gBAAgB,kCAAuBH,KAAvB,EAA8BuE,CAA9B,EAAiC0C,SAAjC,CAApB;;AAEA;AACA,2BAAUjH,MAAMI,iBAAN,OAA8BD,aAAxC,EAAuD,8CAAvD;;AAEA,MAAIwG,eAAJ;AAAA,MAAYpG,eAAZ;AACA,MAAI;AAAA;AAAA;AAAA;;AAAA;AACF,6BAAeP,MAAMqG,OAArB;AAAA,YAASO,EAAT;;AACEA,WAAGC,UAAH,CAActC,CAAd,EAAiByB,YAAjB,EAA+B9F,aAA/B,EAA8C+G,SAA9C;AADF,OADE,CAIF;AAJE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKF,QAAIpH,SAAS,MAAb,EAAqB;AACnB,+BAAUmG,YAAV,EAAwB,yCAAxB;AACA,sCAAqBhG,KAArB,EAA4BuE,CAA5B,EAA+BpE,aAA/B,EAA8C6F,YAA9C;AACD;;AAED;AACA,QAAIoB,iBAAiBjH,cAAcG,kBAAnC;;AAEA;AACAC,aAAS6G,eAAe5G,iBAAxB;;AAEA;AACAmG,aAAS,oCAAyB3G,KAAzB,EAAgCuE,CAAhC,EAAmCrE,aAAnC,CAAT;AACD,GAlBD,SAkBU;AACR;AACAF,UAAM8G,UAAN,CAAiB3G,aAAjB;AACA,6BAAUH,MAAMI,iBAAN,OAA8BsG,aAAxC;;AAHQ;AAAA;AAAA;;AAAA;AAKR,6BAAe1G,MAAMqG,OAArB;AAAA,YAASU,EAAT;;AACEA,WAAGC,SAAH,CAAazC,CAAb,EAAgByB,YAAhB,EAA8B9F,aAA9B,EAA6C+G,SAA7C,EAAwDN,MAAxD;AADF;AALQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOT;;AAED;AACA,MAAIA,+CAAJ,EAAwC;AACtC;AACA,QAAIA,OAAOvD,KAAP,CAAaiE,aAAb,EAAJ,EAAkC;AAChC,aAAOV,OAAOvD,KAAP,CAAakE,wBAAb,EAAP;AACD;;AAED;AACA,QAAIzH,SAAS,MAAb,EAAqB;AACnB,+BAAUmG,YAAV,EAAwB,yCAAxB;AACA,aAAOA,YAAP;AACD;;AAED;AACA,QAAI,CAACW,OAAOvD,KAAP,CAAamE,gBAAb,EAAL,EACE,MAAM,iCAAoB,uBAAgBvH,KAAhB,EAAuB,WAAvB,CAApB,CAAN;AACF2G,WAAOvD,KAAP,CAAaoE,kBAAb;AACD,GAhBD,MAgBO,IAAIb,+CAAJ,EAAwC;AAAE;AAC/C,UAAMA,MAAN;AACD;;AAED;AACA,MAAIc,oBAAoBlH,OAAOmH,cAAP,EAAxB;AACA,2BAAUD,+CAAV;AACA,SAAOA,iBAAP;AACD;;AAED;AACO,SAAS3J,gBAAT,CAA0BkC,KAA1B,EAAwCyF,iBAAxC,EAAwE7E,MAAxE,EAAyF+G,YAAzF,EAAkK;AACvK;AACA,2BAAUlC,+CAAV,EAAoD,4CAApD;;AAEA;AACA,2BAAUkC,iBAAiB,QAAjB,IAA6BA,iBAAiB,iBAA9C,IAAmEA,iBAAiB,WAA9F,EAA2G,sBAA3G;;AAEA;AACA,MAAIC,uBAAJ;AACA,MAAID,iBAAiB,QAArB,EAA+B;AAC7BC,qBAAiB,IAAjB;AACD,GAFD,MAEO;AAAE;AACPA,qBAAiB,KAAjB;AACD;;AAED;AACA,MAAID,iBAAiB,iBAArB,EAAwC;AACtCA,mBAAe,QAAf;AACD;;AAED;AACA,MAAIpD,IAAI,yBAAkBvE,KAAlB,CAAR;;AAEA;;AAEA;AACAuE,IAAE3G,KAAF,GAAU,UAACoI,YAAD,EAAeC,QAAf,EAA4B;AACpC,WAAOrI,MAAMoC,KAAN,EAAauE,CAAb,EAAgByB,YAAhB,EAA8BC,QAA9B,CAAP;AACD,GAFD;;AAIA;AACA,MAAI2B,mBAAmB,IAAvB,EAA6B;AAC3B;AACArD,MAAE1G,UAAF,GAAe,UAACqC,aAAD,EAAgB+G,SAAhB,EAA8B;AAC3C,aAAOpJ,WAAWmC,KAAX,EAAkBuE,CAAlB,EAAqBrE,aAArB,EAAoC+G,SAApC,CAAP;AACD,KAFD;;AAIA;AACA1C,MAAE4C,gBAAF,GAAqB,MAArB;AACD;;AAED;AACA5C,IAAE1D,OAAF,GAAYD,MAAZ;;AAEA;AACA2D,IAAEkC,aAAF,GAAkBkB,YAAlB;;AAEA;AACApD,IAAEsD,UAAF,GAAepC,iBAAf;;AAEA;AACAlB,IAAEuD,aAAF,CAAgB,IAAhB;;AAEA;AACAvD,IAAEwD,MAAF,GAAW/H,KAAX;;AAEA;AACA,SAAOuE,CAAP;AACD;;AAED;AACA,SAASyD,UAAT,CAAoBhI,KAApB,EAAkCuE,CAAlC,EAAyDyB,YAAzD,EAA8E9F,aAA9E,EAAkH;AAChH;AACA,MAAI+H,SAAS1D,EAAE2D,oBAAf;;AAEA;AACA,MAAIC,YAAY5D,EAAE6D,UAAlB;;AAEA;AACA,MAAIC,YAAY9D,EAAE+D,eAAlB;;AAEA;AACA;AACA,MAAIC,OAAOF,UAAU9I,MAAV,CAAiBW,aAAjB,CAAX;;AAEA;AACA,SAAO,gBAAKF,KAAL,EAAYiI,MAAZ,EAAoBE,SAApB,EAA+BI,IAA/B,CAAP;AACD;;AAED;AACA,SAASC,eAAT,CAAyBxI,KAAzB,EAAuCuE,CAAvC,EAA8DrE,aAA9D,EAA2F+G,SAA3F,EAAgI;AAC9H;AACA,MAAIgB,SAAS1D,EAAE2D,oBAAf;;AAEA;AACA,2BAAUD,OAAOpK,UAAP,KAAsB8C,SAAhC,EAA2C,0CAA3C;;AAEA;AACA,MAAI0H,YAAY9D,EAAE+D,eAAlB;;AAEA;AACA;AACA,MAAIC,OAAOF,UAAU9I,MAAV,CAAiBW,aAAjB,CAAX;;AAEA;AACA,MAAI,yBAAUF,KAAV,EAAiBuE,CAAjB,EAAoB0C,SAApB,CAAJ,EAAoCA,YAAYgB,MAAZ;;AAEpC;AACA,SAAO,0BAAUjI,KAAV,EAAiBiI,MAAjB,EAAyBM,IAAzB,EAA+BtB,SAA/B,CAAP;AACD;;AAED;AACO,SAASlJ,mBAAT,CAA6BiC,KAA7B,EAA2CyI,cAA3C,EAAwEN,SAAxE,EAA0FE,SAA1F,EAAgI;AACrI;AACA,2BAAUI,4CAAV,EAAiD,oBAAjD;;AAEA;AACA,MAAIC,QAAQD,eAAeE,eAAf,EAAZ;;AAEA;AACA,MAAIC,MAAM,8BAAuB5I,KAAvB,CAAV;;AAEA;;AAEA;AACA4I,MAAIhL,KAAJ,GAAY,UAACoI,YAAD,EAAeC,QAAf,EAA4B;AACtC,WAAO+B,WAAWhI,KAAX,EAAkB4I,GAAlB,EAAuB5C,YAAvB,EAAqCC,QAArC,CAAP;AACD,GAFD;;AAIA;AACA,MAAIwC,eAAe5K,UAAnB,EAA+B;AAC7B;AACA+K,QAAI/K,UAAJ,GAAiB,UAACmI,YAAD,EAAeC,QAAf,EAA4B;AAC3C,aAAOuC,gBAAgBxI,KAAhB,EAAuB4I,GAAvB,EAA4B5C,YAA5B,EAA0CC,QAA1C,CAAP;AACD,KAFD;AAGD;;AAED;AACA2C,MAAIf,UAAJ,GAAiBa,KAAjB;;AAEA;AACAE,MAAId,aAAJ,CAAkB,IAAlB;;AAEA;AACAc,MAAIV,oBAAJ,GAA2BO,cAA3B;;AAEA;AACAG,MAAIR,UAAJ,GAAiBD,SAAjB;;AAEA;AACAS,MAAIN,eAAJ,GAAsBD,SAAtB;;AAEA;AACA,SAAOO,GAAP;AACD;;AAED;AACO,SAAS5K,WAAT,CAAqBgC,KAArB,EAAmC6I,CAAnC,EAA6CC,SAA7C,EAA+DC,YAA/D,EAAsFC,MAAtF,EAA8G;AACnH;AACA,MAAIA,WAAW,KAAf,EAAsB,yBAAUD,iBAAiB,KAA3B,EAAkC,6CAAlC;;AAEtB;AACA,MAAI,EAAEF,+BAAF,CAAJ,EAAiC,OAAOA,CAAP;;AAEjC;AACA;AACA;AACA;AACA;AACA,MAAIrK,MAAM,qBAAMwB,KAAN,EAAa6I,EAAEzF,KAAf,EAAsB,MAAtB,EAA8B,QAA9B,CAAV;AACA,MAAI6F,SAASzK,IAAI0K,OAAjB;;AAEA;AACA,MAAI,CAACD,OAAOrK,IAAZ,EAAkB,OAAOoB,MAAM+C,UAAN,CAAiBpC,SAAxB;;AAElB;AACA,MAAI/B,OAAOP,EAAE8K,cAAF,CAAiBF,OAAOrK,IAAxB,EAA8BqK,OAAOG,UAArC,CAAX;;AAEA;AACA,MAAIC,mBAAJ;AACA,MAAIN,YAAJ,EAAkB;AAChBM,iBAAa,IAAb;AACD,GAFD,MAEO;AAAE;AACPA,iBAAa,sBAASJ,MAAT,CAAb;AACD;;AAED;AACA;AACA;AACA,MAAIK,MAAMtJ,MAAMI,iBAAN,EAAV;;AAEA;AACA,MAAI0D,eAAJ;AAAA,MAAYR,eAAZ;AACA,MAAI0F,MAAJ,EAAY;AACV;AACAlF,aAAS,uCAA0B9D,KAA1B,EAAiCsJ,IAAIhJ,kBAArC,CAAT;;AAEA;AACAgD,aAASgG,IAAI3F,mBAAb;AACD,GAND,MAMO;AAAE;AACP;AACAG,aAAS,uCAA0B9D,KAA1B,EAAiC8I,UAAUS,UAA3C,CAAT;;AAEA;AACAjG,aAASwF,UAAUS,UAAnB;AACD;;AAED;AACA,MAAIF,UAAJ,EAAgB/F,SAASQ,MAAT;;AAEhB;AACAwF,MAAIE,OAAJ;;AAEA;AACA,MAAIC,UAAU,6BAAd;;AAEA;AACAA,UAAQC,WAAR,CAAoB,IAApB;;AAEA;AACAD,UAAQE,QAAR,CAAiBb,SAAjB;;AAEA;AACAW,UAAQG,cAAR,GAAyBN,IAAIM,cAA7B;;AAEA;AACAH,UAAQ9F,mBAAR,GAA8BL,MAA9B;;AAEA;AACAmG,UAAQnJ,kBAAR,GAA6BwD,MAA7B;;AAEA;AACA9D,QAAM6J,WAAN,CAAkBJ,OAAlB;;AAEA,MAAI9C,eAAJ;AACA,MAAI;AACF;AACA,6BAAUrD,MAAV;AACA,QAAI;AACFqD,eAASxI,6BAA6B6B,KAA7B,EAAoCpB,IAApC,EAA0C0E,MAA1C,EAAkDQ,MAAlD,EAA0DuF,UAA1D,CAAT;AACD,KAFD,CAEE,OAAOS,CAAP,EAAU;AACV,UAAIA,0CAAJ,EAAmC;AACjCnD,iBAASmD,CAAT;AACD,OAFD,MAEO;AACL,cAAMA,CAAN;AACD;AACF;AACD,6BAAUnD,kCAA2BA,+CAArC;;AAEA;AACA,QAAIA,8BAAJ,EAA6B;AAC3B;AACA,UAAIsC,OAAOG,UAAX,EAAuB;AAAA;AAAA;AAAA;;AAAA;AACrB,iCAAsBH,OAAOG,UAA7B,wIAAyC;AAAA,gBAAhCW,SAAgC;;AACvCpD,qBAAS,uBAAgB3G,KAAhB,EAAuB+J,UAAU3G,KAAV,CAAgBA,KAAvC,CAAT;AACD;AAHoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAItB;;AAED;AACAuD,eAAS1I,mBAAmBgL,OAAOrK,IAA1B,EAAgC+H,MAAhC,EAAwC0C,UAAxC,EAAoDvF,MAApD,EAA4D9D,KAA5D,CAAT;AACD;;AAED;AACA,QAAI2G,mCAAJ,EAAkC;AAChC;AACAA,eAAS3G,MAAM+C,UAAN,CAAiBpC,SAA1B;AACD;AACF,GAhCD,SAgCU;AACR;AACA8I,YAAQD,OAAR;AACAxJ,UAAM8G,UAAN,CAAiB2C,OAAjB;AACD;;AAED;AACA,2BAAUzJ,MAAMI,iBAAN,OAA8BkJ,GAAxC;AACAA,MAAIU,MAAJ;;AAEA;AACA,MAAIrD,8BAAJ,EAA6B;AAC3B,WAAOA,MAAP;AACD,GAFD,MAEO;AACL,6BAAUA,+CAAV;AACA,UAAMA,MAAN;AACD;AACF;;AAEM,SAAS1I,kBAAT,CACHW,IADG,EAC8BqL,UAD9B,EAEHC,UAFG,EAEkBC,QAFlB,EAEgDnK,KAFhD,EAEoG;AAAA;AAAA;AAAA;;AAAA;AACzG,2BAAiBpB,IAAjB,wIAAuB;AAAA,UAAdkD,IAAc;;AACrB,UAAIA,KAAKnD,IAAL,KAAc,qBAAlB,EAAyC;AACvC,YAAIyL,MAAMD,SAASE,0BAAT,CAAoCvI,IAApC,EAA0CoI,UAA1C,CAAV;AACA,iCAAU,EAAEE,qCAAF,CAAV;AACA,YAAI,EAAEA,gCAAF,CAAJ,EAAkC;AAChC,cAAIH,eAAetJ,SAAf,IAA4BsJ,kCAAhC,EAA6D;AAC3D,gBAAIG,4CAAJ,EACE,MAAM,yBAAYpK,KAAZ,EAAmBoK,GAAnB,EAAwBH,cAAcjK,MAAM+C,UAAN,CAAiBuB,KAAvD,CAAN;AACF,qCAAU8F,gDAAmCA,2BAA7C;AACAH,yBAAaG,GAAb;AACD,WALD,MAKO;AACL,qCAAUH,2DAAV;AACA,gBAAIG,4CAAJ,EAAqC;AACnC,kBAAIN,IAAI9J,MAAMsK,oBAAN,EAAR;AACA,uCAAUR,MAAMnJ,SAAhB;AACAX,oBAAMuK,mBAAN;;AAHmC,sCAIVT,CAJU;AAAA,kBAI9BU,EAJ8B;AAAA,kBAI1BC,EAJ0B;AAAA,kBAItBC,CAJsB;AAAA,kBAInBC,CAJmB;AAAA,kBAIhBC,EAJgB;;AAKnCJ,iBAAIC,GAAIG;AACR5K,oBAAM6K,eAAN,CAAsBH,CAAtB;AACA1K,oBAAM8K,iBAAN,CAAwBH,CAAxB;AACA,kBAAIP,wDAAJ,EAAiD;AAC/CpK,sBAAM+K,aAAN,CAAoBjB,CAApB;AACA,sBAAMM,GAAN;AACD;AACD,uCAAUH,2DAAV;AACAH,gBAAE,CAAF,IAAOM,GAAP;AACA,kBAAIY,iBAAiB,8DAAiDhL,KAAjD,EAAwDiK,UAAxD,EAAoEG,GAApE,EAAyEN,CAAzE,CAArB;AACA9J,oBAAM+K,aAAN,CAAoBC,cAApB;AACA,oBAAMA,eAAe,CAAf,CAAN;AACD,aAjBD,MAiBO;AACL,kBAAIZ,2BAAJ,EACEH,WAAW7G,KAAX,GAAmBgH,GAAnB,CADF,KAEK;AACH,yCAAUH,2DAAV;AACA,yCAAUG,oDAAV;AACAH,6BAAa,2CAA8BjK,KAA9B,EAAqCiK,UAArC,EAAiDG,GAAjD,CAAb;AACD;AACF;AACF;AACF;AACF;AACF;;AAED;AA5CyG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6CzG,SAAOH,cAAcjK,MAAM+C,UAAN,CAAiBuB,KAAtC;AAED;;AAED;AACO,SAASpG,cAAT,CAAwB8B,KAAxB,EAAsCH,IAAtC,EAA2EmF,aAA3E,EAAgHC,IAAhH,EAA+IC,KAA/I,EAA0KI,MAA1K,EAA2L2F,SAA3L,EAAoN;AACzN;AACA,MAAI,CAACA,SAAL,EAAgB;AACd;AACAA,gBAAYjL,MAAM+C,UAAN,CAAiBmI,iBAA7B;AACD;;AAED;AACA,MAAIC,kBAAJ;AACA,MAAItL,SAAS,QAAb,EAAuB;AACrBsL,gBAAY,iBAAZ;AACD,GAFD,MAEO;AAAE;AACPA,gBAAY,QAAZ;AACD;;AAED;AACA,MAAI5G,IAAIzG,iBAAiBkC,KAAjB,EAAwBiL,SAAxB,EAAmC3F,MAAnC,EAA2C6F,SAA3C,CAAR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAI,CAAC7F,MAAD,IAAWzF,SAAS,QAAxB,EAAkC;AAChC,uCAAsBG,KAAtB,EAA6BuE,CAA7B,EAAgC,WAAhC,EAA6C;AAC3CnB,aAAOpD,MAAM+C,UAAN,CAAiBpC,SADmB;AAE3CkE,kBAAY,KAF+B;AAG3CC,gBAAU,IAHiC;AAI3CC,oBAAc;AAJ6B,KAA7C;AAMD;;AAED;AACA,SAAOtH,mBAAmBuC,KAAnB,EAA0BuE,CAA1B,EAA6B1E,IAA7B,EAAmCmF,aAAnC,EAAkDC,IAAlD,EAAwDC,KAAxD,CAAP;AACD;;AAED;AACO,SAAS/G,4BAAT,CAAsC6B,KAAtC,EAAoDpB,IAApD,EAAmF0E,MAAnF,EAA+GQ,MAA/G,EAA2IlD,MAA3I,EAA4J;AACjK;AACA,MAAIiB,WAAW,EAAf;AACA,0BAASjD,IAAT,EAAe,UAAUkD,IAAV,EAAgB;AAC7B,QAAIA,KAAKnD,IAAL,KAAc,qBAAd,IAAuCmD,KAAKjC,IAAL,KAAc,KAAzD,EAAgE;AAC9DgC,iBAAWA,SAAStC,MAAT,CAAgB0B,OAAOS,IAAP,CAAYrD,EAAEgD,qBAAF,CAAwBS,IAAxB,CAAZ,CAAhB,CAAX;AACD;;AAED,QAAIA,KAAKnD,IAAL,KAAc,oBAAd,IAAsCmD,KAAKnD,IAAL,KAAc,qBAAxD,EAA+E;AAC7E,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GAVD;;AAYA;AACA,MAAIoD,kBAAkBzE,0BAA0BsB,IAA1B,CAAtB;;AAEA;AACA,MAAImF,YAAYD,OAAOtD,iBAAvB;;AAEA;AACA,MAAI+C,YAAYD,OAAO9C,iBAAvB;;AAEA;AACA,MAAI,CAACI,MAAL,EAAa;AACX;AACA,QAAI2C,yDAAJ,EAAkD;AAChD;AADgD;AAAA;AAAA;;AAAA;AAEhD,+BAAiB1B,QAAjB,wIAA2B;AAAA,cAAlBP,IAAkB;;AACzB;AACA,cAAIiC,UAAU6H,qBAAV,CAAgC9J,IAAhC,CAAJ,EAA2C;AACzC,kBAAM,iCACJ,0BAAUtB,KAAV,EAAiBA,MAAM+C,UAAN,CAAiBsI,WAAlC,EACG,CAAC,uBAAgBrL,KAAhB,EAAuBsB,OAAO,8BAA9B,CAAD,CADH,CADI,CAAN;AAID;AACD;AACD;AAX+C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYjD;AACD;AACA,QAAIgK,UAAUxH,MAAd;AACA;AACA;AACA,WAAOwH,YAAYhI,MAAnB,EAA2B;AACzB;AACA,UAAIiI,aAAaD,QAAQ9K,iBAAzB;AACA;AACA,UAAI,EAAE+K,0DAAF,CAAJ,EAAsD;AACpD;AACA;AAFoD;AAAA;AAAA;;AAAA;AAGpD,iCAAiB1J,QAAjB,wIAA2B;AAAA,gBAAlBP,MAAkB;;AACzB;AACA,gBAAIiK,WAAW3I,UAAX,CAAsBtB,MAAtB,CAAJ,EAAiC;AAC/B;AACA,oBAAMtB,MAAMwL,0BAAN,CAAiCxL,MAAM+C,UAAN,CAAiBsI,WAAlD,EACJ/J,SAAO,8BADH,CAAN;AAEA;AACD;AACD;AACD;AAZmD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAarD;AACD;AACAgK,gBAAUA,QAAQG,MAAlB;AACA,+BAAUH,YAAY,IAAtB;AACD;AACF;;AAED;AACA,MAAIpJ,wBAAwB,EAA5B;;AAEA;AACA,MAAIwJ,wBAAwB,EAA5B;;AAEA;AA1EiK;AAAA;AAAA;;AAAA;AA2EjK,2BAAc3J,gBAAgBI,OAAhB,EAAd,wIAAyC;AAAA,UAAhCC,CAAgC;;AACvC;AACA,UAAIA,EAAEzD,IAAF,KAAW,qBAAf,EAAsC;AACpC;AACA,iCAAUyD,EAAEzD,IAAF,KAAW,qBAAX,IAAoCyD,EAAEzD,IAAF,KAAW,sBAAzD;AACA;AACA;AACA,YAAI0D,KAAK,wBAAWrC,KAAX,EAAkBoC,CAAlB,EAAqB,CAArB,CAAT;AACA;AACA,YAAIsJ,sBAAsBpJ,OAAtB,CAA8BD,EAA9B,IAAoC,CAAxC,EAA2C;AACzC;AACA,cAAIkB,yDAAJ,EAAkD;AAChD;AACA,gBAAIoI,cAAcpI,UAAUqI,wBAAV,CAAmCvJ,EAAnC,CAAlB;AACA;AACA,gBAAI,CAACsJ,WAAL,EAAkB;AAChB,oBAAM3L,MAAMwL,0BAAN,CAAiCxL,MAAM+C,UAAN,CAAiB8I,SAAlD,EACJxJ,KAAK,mBADD,CAAN;AAED;AACF;AACD;AACAqJ,gCAAsB/L,IAAtB,CAA2B0C,EAA3B;AACA;AACAH,gCAAsBK,OAAtB,CAA8BH,CAA9B;AACD;AACF;AACF;;AAED;;AAEA;AAzGiK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0GjK,MAAI0J,mBAAmB,EAAvB;;AAEA;AA5GiK;AAAA;AAAA;;AAAA;AA6GjK,2BAAc/J,eAAd,wIAA+B;AAAA,UAAtBK,GAAsB;;AAC7B;AACA,UAAIA,IAAEzD,IAAF,KAAW,qBAAf,EAAsC;AACpC;AADoC;AAAA;AAAA;;AAAA;AAEpC,iCAAe,wBAAWqB,KAAX,EAAkBoC,GAAlB,CAAf,wIAAqC;AAAA,gBAA5B2J,EAA4B;;AACnC;AACA,gBAAIL,sBAAsBpJ,OAAtB,CAA8ByJ,EAA9B,IAAoC,CAAxC,EAA2C;AACzC;AACA,kBAAIxI,yDAAJ,EAAkD;AAChD;AACA,oBAAIyI,cAAczI,UAAU0I,mBAAV,CAA8BF,EAA9B,CAAlB;AACA;AACA,oBAAI,CAACC,WAAL,EAAkB;AAChB,wBAAMhM,MAAMwL,0BAAN,CAAiCxL,MAAM+C,UAAN,CAAiB8I,SAAlD,EACJE,KAAK,mBADD,CAAN;AAED;AACF;AACD;AACA,kBAAID,iBAAiBxJ,OAAjB,CAAyByJ,EAAzB,IAA+B,CAAnC,EAAsC;AACpC;AACAD,iCAAiBnM,IAAjB,CAAsBoM,EAAtB;AACD;AACF;AACF;AArBmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBrC;AACF;;AAED;;AAEA;AA1IiK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA2IjK,MAAI/H,kBAAkB,EAAtB;AA3IiK;AAAA;AAAA;;AAAA;AA4IjK,2BAAcpF,KAAKA,IAAnB,wIAAyB;AAAA,UAAhBsN,CAAgB;;AACvB,UAAIA,EAAEvN,IAAF,KAAW,qBAAX,IAAoCuN,EAAErM,IAAF,KAAW,KAAnD,EAA0D;AACxDmE,wBAAgBrE,IAAhB,CAAqBuM,CAArB;AACD;AACF;;AAED;AAlJiK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAmJjK,2BAAclI,eAAd,wIAA+B;AAAA,UAAtB5B,GAAsB;;AAC7B;AACA;AAF6B;AAAA;AAAA;;AAAA;AAG7B,+BAAe,wBAAWpC,KAAX,EAAkBoC,GAAlB,CAAf,wIAAqC;AAAA,cAA5B6B,EAA4B;;AACnC;AACA,cAAI7B,IAAEvC,IAAF,KAAW,OAAf,EAAuB;AACrB;AACAkE,sBAAUd,sBAAV,CAAiCgB,EAAjC,EAAqC,IAArC;AACD,WAHD,MAGO;AAAE;AACP;AACAF,sBAAUlB,oBAAV,CAA+BoB,EAA/B,EAAmC,KAAnC;AACD;AACF;AAZ4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAa9B;;AAED;AAlKiK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAmKjK,2BAAc/B,qBAAd,wIAAqC;AAAA,UAA5BgC,CAA4B;;AACnC;AACA,UAAI7B,OAAK,wBAAWrC,KAAX,EAAkBkE,CAAlB,EAAqB,CAArB,CAAT;AACA;AACA,UAAIC,KAAKL,OAAOM,QAAP,CAAgBF,CAAhB,EAAmBtD,MAAnB,CAAT;AACA,+BAAUuD,0BAAV;AACA;AACA,UAAIZ,yDAAJ,EAAkD;AAChD;AACAA,kBAAU4I,2BAAV,CAAsC9J,IAAtC,EAA0C8B,EAA1C,EAA8C,IAA9C;AACD,OAHD,MAGO;AAAE;AACP;AACA,YAAIiI,gBAAgB7I,UAAUX,UAAV,CAAqBP,IAArB,CAApB;AACA;AACA,YAAI,CAAC+J,aAAL,EAAoB;AAClB;AACA7I,oBAAUV,oBAAV,CAA+BR,IAA/B,EAAmC,IAAnC;AACA;AACA;AACAkB,oBAAUT,iBAAV,CAA4BT,IAA5B,EAAgC8B,EAAhC;AACD,SAND,MAMO;AAAE;AACP;AACAZ,oBAAUc,iBAAV,CAA4BhC,IAA5B,EAAgC8B,EAAhC,EAAoC,KAApC;AACD;AACF;AACF;;AAED;AA9LiK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AA+LjK,2BAAe2H,gBAAf,wIAAiC;AAAA,UAAxBC,GAAwB;;AAC/B;AACA,UAAIxI,yDAAJ,EAAkD;AAChD;AACAA,kBAAU8I,sBAAV,CAAiCN,GAAjC,EAAqC,IAArC;AACD,OAHD,MAGO;AAAE;AACP;AACA,YAAIK,iBAAgB7I,UAAUX,UAAV,CAAqBmJ,GAArB,CAApB;AACA;AACA,YAAI,CAACK,cAAL,EAAoB;AAClB;AACA7I,oBAAUV,oBAAV,CAA+BkJ,GAA/B,EAAmC,IAAnC;AACA;AACA;AACAxI,oBAAUT,iBAAV,CAA4BiJ,GAA5B,EAAgC/L,MAAM+C,UAAN,CAAiBpC,SAAjD;AACD;AACF;AACF;;AAED;AAlNiK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmNjK,SAAOX,MAAM+C,UAAN,CAAiBuB,KAAxB;AACD;;AAED;AACO,SAASlG,UAAT,CAAoB4B,KAApB,EAAkCuE,CAAlC,EAAoD+H,UAApD,EAA6E;AAClF;AACA,2BAAUtM,MAAMmF,WAAN,CAAkBZ,CAAlB,CAAV;;AAEA;AACA,2BAAUA,iCAAV,EAAsC,qCAAtC;;AAEA;AACA,2BAAU+H,wCAAV,EAA6C,6BAA7C;;AAEA;AACA/H,IAAEgI,WAAF,GAAgBD,UAAhB;;AAEA;AACA,SAAOtM,MAAM+C,UAAN,CAAiBpC,SAAxB;AACD","file":"function.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { ThrowCompletion, ReturnCompletion, AbruptCompletion, NormalCompletion, PossiblyNormalCompletion, IntrospectionThrowCompletion } from \"../completions.js\";\nimport { ExecutionContext } from \"../realm.js\";\nimport { GlobalEnvironmentRecord, ObjectEnvironmentRecord, Reference } from \"../environment.js\";\nimport { Value, BoundFunctionValue, EmptyValue, FunctionValue, ObjectValue, StringValue, SymbolValue, NumberValue } from \"../values/index.js\";\nimport { DefinePropertyOrThrow, NewDeclarativeEnvironment, ResolveBinding } from \"./index.js\";\nimport { OrdinaryCreateFromConstructor, CreateUnmappedArgumentsObject, CreateMappedArgumentsObject } from \"./create.js\";\nimport { OrdinaryCallEvaluateBody, OrdinaryCallBindThis, PrepareForOrdinaryCall, Call } from \"./call.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { joinPossiblyNormalCompletionWithAbruptCompletion, joinPossiblyNormalCompletions,\n  BoundNames, ContainsExpression, GetActiveScriptOrModule, UpdateEmpty } from \"../methods/index.js\";\nimport { PutValue } from \"./properties.js\";\nimport traverse from \"../traverse.js\";\nimport invariant from \"../invariant.js\";\nimport parse from \"../utils/parse.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNode,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeBlockStatement,\n  BabelNodeProgram,\n  BabelNodeDoWhileStatement,\n  BabelNodeWhileStatement,\n  BabelNodeLabeledStatement,\n  BabelNodeWithStatement,\n  BabelNodeSwitchStatement,\n  BabelNodeIfStatement,\n  BabelNodeForStatement,\n  BabelNodeForInStatement,\n  BabelNodeForOfStatement,\n  BabelNodeTryStatement\n} from \"babel-types\";\n\nexport function FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode> {\n  function FindVarScopedDeclarationsFor(ast: BabelNode, level: number) {\n    let statements = [];\n    switch (ast.type) {\n    case 'Program':\n      statements = ((ast: any): BabelNodeProgram).body;\n      break;\n    case 'BlockStatement':\n      statements = ((ast: any): BabelNodeBlockStatement).body;\n      break;\n    case 'DoWhileStatement':\n      statements = [((ast: any): BabelNodeDoWhileStatement).body];\n      break;\n    case 'WhileStatement':\n      statements = [((ast: any): BabelNodeWhileStatement).body];\n      break;\n    case 'IfStatement':\n      let astIfStatement: BabelNodeIfStatement = (ast: any);\n      statements = [astIfStatement.consequent, astIfStatement.alternate];\n      break;\n    case 'ForStatement':\n      let astForStatement: BabelNodeForStatement = (ast: any);\n      statements = [astForStatement.init, astForStatement.body];\n      break;\n    case 'ForInStatement':\n      let astForInStatement: BabelNodeForInStatement = (ast: any);\n      statements = [astForInStatement.left, astForInStatement.body];\n      break;\n    case 'ForOfStatement':\n      let astForOfStatement: BabelNodeForOfStatement = (ast: any);\n      statements = [astForOfStatement.left, astForOfStatement.body];\n      break;\n    case 'LabeledStatement':\n      statements = [((ast: any): BabelNodeLabeledStatement).body];\n      break;\n    case 'WithStatement':\n      statements = [((ast: any): BabelNodeWithStatement).body];\n      break;\n    case 'SwitchStatement':\n      for (let switchCase of ((ast: any): BabelNodeSwitchStatement).cases) {\n        statements = statements.concat(switchCase.consequent);\n      }\n      break;\n    case 'TryStatement':\n      let astTryStatement: BabelNodeTryStatement = (ast: any);\n      statements = [astTryStatement.block];\n      if (astTryStatement.finalizer) statements.push(astTryStatement.finalizer);\n      if (astTryStatement.handler) statements.push(astTryStatement.handler.body);\n      break;\n    case 'VariableDeclaration':\n      return ast.kind === \"var\" ? [ast] : [];\n    case 'FunctionDeclaration':\n      return level < 2 ? [ast] : [];\n    default:\n      return [];\n    }\n\n    let decls = [];\n    for (let statement of statements) {\n      if (statement) {\n        decls = decls.concat(FindVarScopedDeclarationsFor(statement, level + 1));\n      }\n    }\n\n    return decls;\n  }\n  return FindVarScopedDeclarationsFor(ast_node, 0);\n}\n\n// ECMA262 9.2.12\nexport function FunctionDeclarationInstantiation(realm: Realm, func: FunctionValue, argumentsList: Array<Value>): EmptyValue {\n  // 1. Let calleeContext be the running execution context.\n  let calleeContext = realm.getRunningContext();\n\n  // 2. Let env be the LexicalEnvironment of calleeContext.\n  let env = calleeContext.lexicalEnvironment;\n\n  // 3. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 4. Let code be the value of the [[ECMAScriptCode]] internal slot of func.\n  let code = func.$ECMAScriptCode;\n  invariant(code !== undefined);\n\n  // 5. Let strict be the value of the [[Strict]] internal slot of func.\n  let strict = func.$Strict;\n\n  // 6. Let formals be the value of the [[FormalParameters]] internal slot of func.\n  let formals = func.$FormalParameters;\n  invariant(formals !== undefined);\n\n  // 7. Let parameterNames be the BoundNames of formals.\n  let parameterNames = Object.create(null);\n  for (let param of formals) {\n    let paramBindings = t.getBindingIdentifiers(param, true);\n\n    for (let name in paramBindings) {\n      parameterNames[name] = (parameterNames[name] || []).concat(paramBindings[name]);\n    }\n  }\n\n  // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.\n  let hasDuplicates = false;\n  for (let name in parameterNames) {\n    let identifiers = parameterNames[name];\n    if (identifiers.length > 1) hasDuplicates = true;\n  }\n  parameterNames = Object.keys(parameterNames);\n\n  // 9. Let simpleParameterList be IsSimpleParameterList of formals.\n  let simpleParameterList = true;\n  for (let param of formals) {\n    if (param.type !== \"Identifier\") {\n      simpleParameterList = false;\n      break;\n    }\n  }\n\n  // 10. Let hasParameterExpressions be ContainsExpression of formals.\n  let hasParameterExpressions = false;\n  invariant(formals !== undefined);\n  for (let param of formals) {\n    if (ContainsExpression(realm, param)) {\n      hasParameterExpressions = true;\n      break;\n    }\n  }\n\n  // 11. Let varNames be the VarDeclaredNames of code.\n  let varNames = [];\n  traverse(code, function (node) {\n    if (node.type === \"VariableDeclaration\" && node.kind === \"var\") {\n      varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n    }\n\n    if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n\n    return false;\n  });\n\n  // 12. Let varDeclarations be the VarScopedDeclarations of code.\n  let varDeclarations = FindVarScopedDeclarations(code);\n\n  // 13. Let lexicalNames be the LexicallyDeclaredNames of code.\n  let lexicalNames = [];\n\n  // 14. Let functionNames be an empty List.\n  let functionNames = [];\n\n  // 15. Let functionsToInitialize be an empty List.\n  let functionsToInitialize = [];\n\n  // 16. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n      // ii. Let fn be the sole element of the BoundNames of d.\n      let fn = BoundNames(realm, d)[0];\n      // iii. If fn is not an element of functionNames, then\n      if (functionNames.indexOf(fn) < 0) {\n        // 1. Insert fn as the first element of functionNames.\n        functionNames.unshift(fn);\n        // 2. NOTE If there are multiple FunctionDeclarations or GeneratorDeclarations for the same name, the last declaration is used.\n        // 3. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 17. Let argumentsObjectNeeded be true.\n  let argumentsObjectNeeded = true;\n\n  // 18. If the value of the [[realmMode]] internal slot of func is lexical, then\n  if (func.$ThisMode === \"lexical\") {\n    // a. NOTE Arrow functions never have an arguments objects.\n    // b. Let argumentsObjectNeeded be false.\n    argumentsObjectNeeded = false;\n  } else if (parameterNames.indexOf(\"arguments\") >= 0) { // 19. Else if \"arguments\" is an element of parameterNames, then\n    // a. Let argumentsObjectNeeded be false.\n    argumentsObjectNeeded = false;\n  } else if (hasParameterExpressions === false) { // 20. Else if hasParameterExpressions is false, then\n    // a. If \"arguments\" is an element of functionNames or if \"arguments\" is an element of lexicalNames, then\n    if (functionNames.indexOf(\"arguments\") >= 0 || lexicalNames.indexOf(\"arguments\") >= 0) {\n      // i. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = true;\n    }\n  }\n\n  // 21. For each String paramName in parameterNames, do\n  for (let paramName of parameterNames) {\n    // a. Let alreadyDeclared be envRec.HasBinding(paramName).\n    let alreadyDeclared = envRec.HasBinding(paramName);\n\n    // b. NOTE Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n\n    // c. If alreadyDeclared is false, then\n    if (alreadyDeclared === false) {\n      // i. Perform ! envRec.CreateMutableBinding(paramName, false).\n      envRec.CreateMutableBinding(paramName, false);\n\n      // ii. If hasDuplicates is true, then\n      if (hasDuplicates === true) {\n        // 1. Perform ! envRec.InitializeBinding(paramName, undefined).\n        envRec.InitializeBinding(paramName, realm.intrinsics.undefined);\n      }\n    }\n  }\n\n  // 22. If argumentsObjectNeeded is true, then\n  if (argumentsObjectNeeded === true) {\n    let ao;\n\n    // a. If strict is true or if simpleParameterList is false, then\n    if (strict === true || simpleParameterList === false) {\n      // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).\n      ao = CreateUnmappedArgumentsObject(realm, argumentsList);\n    } else { // b. Else,\n      // i. NOTE mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n      // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).\n      invariant(formals !== undefined);\n      ao = CreateMappedArgumentsObject(realm, func, formals, argumentsList, envRec);\n    }\n\n    // c. If strict is true, then\n    if (strict === true) {\n      // i. Perform ! envRec.CreateImmutableBinding(\"arguments\", false).\n      envRec.CreateImmutableBinding(\"arguments\", false);\n    } else { // d. Else,\n      // i. Perform ! envRec.CreateMutableBinding(\"arguments\", false).\n      envRec.CreateMutableBinding(\"arguments\", false);\n    }\n\n    // e. Call envRec.InitializeBinding(\"arguments\", ao).\n    envRec.InitializeBinding(\"arguments\", ao);\n\n    // f. Append \"arguments\" to parameterNames.\n    parameterNames.push(\"arguments\");\n  }\n\n  // 23. Let iteratorRecord be Record {[[Iterator]]: CreateListIterator(argumentsList), [[Done]]: false}.\n  let iteratorRecord = 0;\n\n  // 24. If hasDuplicates is true, then\n  if (hasDuplicates === true) {\n    // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.\n    invariant(formals !== undefined);\n    for (let i = 0; i < formals.length; ++i) {\n      let param = formals[i];\n\n      switch (param.type) {\n      case \"Identifier\":\n        let value = argumentsList[iteratorRecord] || realm.intrinsics.undefined;\n        ++iteratorRecord;\n        let lhs = ResolveBinding(realm, param.name, strict);\n        PutValue(realm, lhs, value);\n        break;\n      default:\n        throw new ThrowCompletion(new StringValue(realm, \"only plain identifiers are supported in parameter lists\"));\n      }\n    }\n  } else { // 25. Else,\n    // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.\n    invariant(formals !== undefined);\n    for (let i = 0; i < formals.length; ++i) {\n      let param = formals[i];\n\n      switch (param.type) {\n      case \"Identifier\":\n        let value = argumentsList[iteratorRecord] || realm.intrinsics.undefined;\n        ++iteratorRecord;\n        envRec.InitializeBinding(param.name, value);\n        break;\n      default:\n        throw new ThrowCompletion(new StringValue(realm, \"only plain identifiers are supported in parameter lists\"));\n      }\n    }\n  }\n\n\n  // 26. If hasParameterExpressions is false, then\n  let varEnv, varEnvRec;\n  if (hasParameterExpressions === false) {\n    // a. NOTE Only a single lexical environment is needed for the parameters and top-level vars.\n    // b. Let instantiatedVarNames be a copy of the List parameterNames.\n    let instantiatedVarNames = parameterNames.slice();\n\n    // c. For each n in varNames, do\n    for (let n of varNames) {\n      // i. If n is not an element of instantiatedVarNames, then\n      if (instantiatedVarNames.indexOf(n) < 0) {\n        // 1. Append n to instantiatedVarNames.\n        instantiatedVarNames.push(n);\n\n        // 2. Perform ! envRec.CreateMutableBinding(n, false).\n        envRec.CreateMutableBinding(n, false);\n\n        // 3. Call envRec.InitializeBinding(n, undefined).\n        envRec.InitializeBinding(n, realm.intrinsics.undefined);\n      }\n    }\n\n    // e. Let varEnv be env.\n    varEnv = env;\n\n    // f. Let varEnvRec be envRec.\n    varEnvRec = envRec;\n  } else { // 27. Else,\n    // a. NOTE A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n\n    // b. Let varEnv be NewDeclarativeEnvironment(env).\n    varEnv = NewDeclarativeEnvironment(realm, env);\n\n    // c. Let varEnvRec be varEnv's EnvironmentRecord.\n    varEnvRec = varEnv.environmentRecord;\n\n    // d. Set the VariableEnvironment of calleeContext to varEnv.\n    calleeContext.variableEnvironment  = varEnv;\n\n    // e. Let instantiatedVarNames be a new empty List.\n    let instantiatedVarNames = [];\n\n    // f. For each n in varNames, do\n    for (let n of varNames) {\n      // i. If n is not an element of instantiatedVarNames, then\n      if (instantiatedVarNames.indexOf(n) < 0) {\n        // 1. Append n to instantiatedVarNames.\n        instantiatedVarNames.push(n);\n\n        // 2. Perform ! varEnvRec.CreateMutableBinding(n, false).\n        varEnvRec.CreateMutableBinding(n, false);\n\n        // 3. If n is not an element of parameterNames or if n is an element of functionNames, let initialValue be undefined.\n        let initialValue;\n        if (parameterNames.indexOf(n) < 0 || functionNames.indexOf(n) < 0) {\n          initialValue = realm.intrinsics.undefined;\n        } else { // 4. Else,\n          // a. Let initialValue be ! envRec.GetBindingValue(n, false).\n          initialValue = envRec.GetBindingValue(n, false);\n        }\n\n        // 5. Call varEnvRec.InitializeBinding(n, initialValue).\n        varEnvRec.InitializeBinding(n, initialValue);\n\n        // 6. NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.\n      }\n    }\n  }\n\n  // 28. NOTE: Annex B.3.3.1 adds additional steps at realm point.\n\n  let lexEnv;\n\n  // 29. If strict is false, then\n  if (strict === false) {\n    // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).\n    lexEnv = NewDeclarativeEnvironment(realm, varEnv);\n\n    // b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval (see 12.3.4.1) can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. realm is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n  } else { // 30. Else, let lexEnv be varEnv.\n    lexEnv = varEnv;\n  }\n\n  // 31. Let lexEnvRec be lexEnv's EnvironmentRecord.\n  let lexEnvRec = lexEnv.environmentRecord;\n\n  // 32. Set the LexicalEnvironment of calleeContext to lexEnv.\n  calleeContext.lexicalEnvironment = lexEnv;\n\n  // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.\n  let lexDeclarations = [];\n\n  // 34. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of BoundNames(realm, d)) {\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\") {\n        // 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).\n        lexEnvRec.CreateImmutableBinding(dn, true);\n      } else { // ii. Else,\n        // 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).\n        lexEnvRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 35. For each parsed grammar phrase f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = BoundNames(realm, f)[0];\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n    let fo = lexEnv.evaluate(f, strict);\n    invariant(fo instanceof Value);\n    // c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n    varEnvRec.SetMutableBinding(fn, fo, false);\n  }\n\n  // 36. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\n// ECMA262 9.2.11\nexport function SetFunctionName(realm: Realm, F: ObjectValue, name: PropertyKeyValue, prefix?: string): boolean {\n  // 1. Assert: F is an extensible object that does not have a name own property.\n  invariant(F.getExtensible(), \"expected object to be extensible and not have a name property\");\n\n  // 2. Assert: Type(name) is either Symbol or String.\n  invariant(typeof name === \"string\" || name instanceof StringValue || name instanceof SymbolValue, \"expected name to be a string or symbol\");\n  if (typeof name === \"string\") name = new StringValue(realm, name);\n\n  // 3. Assert: If prefix was passed, then Type(prefix) is String.\n  invariant(prefix === undefined || typeof prefix === \"string\", \"expected prefix to be a string if passed\");\n\n  // 4. If Type(name) is Symbol, then\n  if (name instanceof SymbolValue) {\n    // a. Let description be name's [[Description]] value.\n    let description = name.$Description;\n\n    // b. If description is undefined, let name be the empty String.\n    if (description === undefined) {\n      name = realm.intrinsics.emptyString;\n    } else { // c. Else, let name be the concatenation of \"[\", description, and \"]\".\n      invariant(description !== null);\n      name = new StringValue(realm, `[${description}]`);\n    }\n  }\n\n  // 5. If prefix was passed, then\n  if (prefix) {\n    // a. Let name be the concatenation of prefix, code unit 0x0020 (SPACE), and name.\n    name = new StringValue(realm, `${prefix} ${name.value}`);\n  }\n\n  // 6. Return ! DefinePropertyOrThrow(F, \"name\", PropertyDescriptor{[[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n  return DefinePropertyOrThrow(realm, F, \"name\", {\n    value: name,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  });\n}\n\n// ECMA262 9.2.3\nexport function FunctionInitialize(realm: Realm, F: FunctionValue, kind: \"normal\" | \"method\" | \"arrow\", ParameterList: Array<BabelNodeLVal>, Body: BabelNodeBlockStatement, Scope: LexicalEnvironment): FunctionValue {\n  // Note that F is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(F));\n\n  // 1. Assert: F is an extensible object that does not have a length own property.\n  invariant(F.getExtensible(), \"expected to be extensible and no length property\");\n\n  // 2. Let len be the ExpectedArgumentCount of ParameterList.\n  let len = 0;\n  for (let FormalParameter of ParameterList) {\n    if (FormalParameter.type === 'AssignmentPattern') {\n      break;\n    }\n    len += 1;\n  }\n\n  // 3. Perform ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor{[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n  DefinePropertyOrThrow(realm, F, \"length\", {\n    value: new NumberValue(realm, len),\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  // 4. Let Strict be the value of the [[Strict]] internal slot of F.\n  let Strict = F.$Strict;\n\n  // 5. Set the [[Environment]] internal slot of F to the value of Scope.\n  F.$Environment = Scope;\n\n  // 6. Set the [[FormalParameters]] internal slot of F to ParameterList.\n  F.$FormalParameters = ParameterList;\n\n  // 7. Set the [[ECMAScriptCode]] internal slot of F to Body.\n  F.$ECMAScriptCode = Body;\n\n  // 8. Set the [[ScriptOrModule]] internal slot of F to GetActiveScriptOrModule().\n  F.$ScriptOrModule = GetActiveScriptOrModule(realm);\n\n  // 9. If kind is Arrow, set the [[realmMode]] internal slot of F to lexical.\n  if (kind === \"arrow\") {\n    F.$ThisMode = \"lexical\";\n  } else if (Strict === true) { // 10. Else if Strict is true, set the [[realmMode]] internal slot of F to strict.\n    F.$ThisMode = \"strict\";\n  } else { // 11. Else set the [[realmMode]] internal slot of F to global.\n    F.$ThisMode = \"global\";\n  }\n\n  // Return F.\n  return F;\n}\n\n// ECMA262 9.2.6\nexport function GeneratorFunctionCreate(realm: Realm, kind: \"normal\" | \"method\", ParameterList: Array<BabelNodeLVal>, Body: BabelNodeBlockStatement, Scope: LexicalEnvironment, Strict: boolean): FunctionValue {\n  // 1. Let functionPrototype be the intrinsic object %Generator%.\n  let functionPrototype = realm.intrinsics.Generator;\n\n  // 2. Let F be FunctionAllocate(functionPrototype, Strict, \"generator\").\n  let F = FunctionAllocate(realm, functionPrototype, Strict, \"generator\");\n\n  // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n  return FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n}\n\n// ECMA262 9.2.7\nexport function AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm) {\n  // 1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.\n  // 2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].\n  let thrower = realm.intrinsics.ThrowTypeError;\n  invariant(thrower);\n\n  let desc = {\n    get: thrower,\n    set: thrower,\n    enumerable: false,\n    configurable: true\n  };\n  // 3. Return ! DefinePropertyOrThrow(F, \"arguments\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n  return DefinePropertyOrThrow(realm, F, \"arguments\", desc);\n}\n\n// ECMA262 9.2.1\nexport function $Call(realm: Realm, F: FunctionValue, thisArgument: Value, argsList: Array<Value>): Value {\n  return InternalCall(realm, F, thisArgument, argsList, 0);\n}\n\nfunction InternalCall(realm: Realm, F: FunctionValue, thisArgument: Value, argsList: Array<Value>, tracerIndex: number): Value {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function value\");\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argsList, undefined, () => InternalCall(realm, F, thisArgument, argsList, nextIndex));\n    if (detourResult instanceof Value) return detourResult;\n  }\n\n  // 2. If F's [[FunctionKind]] internal slot is \"classConstructor\", throw a TypeError exception.\n  if (F.$FunctionKind === \"classConstructor\") throw new ThrowCompletion(new StringValue(realm, \"TypeError\"));\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, undefined);\n\n  let result;\n  try {\n    for (let t1 of realm.tracers)\n      t1.beforeCall(F, thisArgument, argsList, undefined);\n\n    // 5. Assert: calleeContext is now the running execution context.\n    invariant(realm.getRunningContext() === calleeContext, \"calleeContext should be current execution context\");\n\n    // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n\n    // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argsList);\n  } finally {\n    // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers)\n      t2.afterCall(F, thisArgument, argsList, undefined, result);\n  }\n\n  // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).\n  if (result instanceof ReturnCompletion) {\n    return result.value;\n  }\n\n  // 10. ReturnIfAbrupt(result).\n  if (result instanceof AbruptCompletion) {\n    throw result;\n  }\n\n  // 11. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 9.2.2\nexport function $Construct(realm: Realm, F: FunctionValue, argumentsList: Array<Value>, newTarget: ObjectValue): ObjectValue {\n  return InternalConstruct(realm, F, argumentsList, newTarget, undefined, 0);\n}\n\nfunction InternalConstruct(realm: Realm, F: FunctionValue, argumentsList: Array<Value>, newTarget: ObjectValue, thisArgument: void | ObjectValue, tracerIndex: number): ObjectValue {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function\");\n\n  // 2. Assert: Type(newTarget) is Object.\n  invariant(newTarget instanceof ObjectValue, \"expected object\");\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let kind be F's [[ConstructorKind]] internal slot.\n  let kind = F.$ConstructorKind;\n\n  // 5. If kind is \"base\", then\n  if (thisArgument === undefined && kind === \"base\") {\n    // a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n    thisArgument = OrdinaryCreateFromConstructor(realm, newTarget, \"ObjectPrototype\");\n  }\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argumentsList, newTarget, () => InternalConstruct(realm, F, argumentsList, newTarget, thisArgument, nextIndex));\n    if (detourResult instanceof ObjectValue) return detourResult;\n    invariant(detourResult === undefined);\n  }\n\n  // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, newTarget);\n\n  // 7. Assert: calleeContext is now the running execution context.\n  invariant(realm.getRunningContext() === calleeContext, \"expected calleeContext to be running context\");\n\n  let result, envRec;\n  try {\n    for (let t1 of realm.tracers)\n      t1.beforeCall(F, thisArgument, argumentsList, newTarget);\n\n    // 8. If kind is \"base\", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n    }\n\n    // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.\n    let constructorEnv = calleeContext.lexicalEnvironment;\n\n    // 10. Let envRec be constructorEnv's EnvironmentRecord.\n    envRec = constructorEnv.environmentRecord;\n\n    // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argumentsList);\n  } finally {\n    // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers)\n      t2.afterCall(F, thisArgument, argumentsList, newTarget, result);\n  }\n\n  // 13. If result.[[Type]] is return, then\n  if (result instanceof ReturnCompletion) {\n    // a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).\n    if (result.value.mightBeObject()) {\n      return result.value.throwIfNotConcreteObject();\n    }\n\n    // b. If kind is \"base\", return NormalCompletion(thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      return thisArgument;\n    }\n\n    // c. If result.[[Value]] is not undefined, throw a TypeError exception.\n    if (!result.value.mightBeUndefined())\n      throw new ThrowCompletion(new StringValue(realm, \"TypeError\"));\n    result.value.throwIfNotConcrete();\n  } else if (result instanceof AbruptCompletion) { // 14. Else, ReturnIfAbrupt(result).\n    throw result;\n  }\n\n  // 15. Return ? envRec.GetThisBinding().\n  let envRecThisBinding = envRec.GetThisBinding();\n  invariant(envRecThisBinding instanceof ObjectValue);\n  return envRecThisBinding;\n}\n\n// ECMA262 9.2.3\nexport function FunctionAllocate(realm: Realm, functionPrototype: ObjectValue, strict: boolean, functionKind: \"normal\" | \"non-constructor\" | \"generator\"): FunctionValue {\n  // 1. Assert: Type(functionPrototype) is Object.\n  invariant(functionPrototype instanceof ObjectValue, \"expected functionPrototype to be an object\");\n\n  // 2. Assert: functionKind is either \"normal\", \"non-constructor\" or \"generator\".\n  invariant(functionKind === \"normal\" || functionKind === \"non-constructor\" || functionKind === \"generator\", \"invalid functionKind\");\n\n  // 3. If functionKind is \"normal\", let needsConstruct be true.\n  let needsConstruct;\n  if (functionKind === \"normal\") {\n    needsConstruct = true;\n  } else { // 4. Else, let needsConstruct be false.\n    needsConstruct = false;\n  }\n\n  // 5. If functionKind is \"non-constructor\", let functionKind be \"normal\".\n  if (functionKind === \"non-constructor\") {\n    functionKind = \"normal\";\n  }\n\n  // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.\n  let F = new FunctionValue(realm);\n\n  // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n  // 8. Set F's [[Call]] internal method to the definition specified in 9.2.1.\n  F.$Call = (thisArgument, argsList) => {\n    return $Call(realm, F, thisArgument, argsList);\n  };\n\n  // 9. If needsConstruct is true, then\n  if (needsConstruct === true) {\n    // a. Set F's [[Construct]] internal method to the definition specified in 9.2.2.\n    F.$Construct = (argumentsList, newTarget) => {\n      return $Construct(realm, F, argumentsList, newTarget);\n    };\n\n    // b. Set the [[ConstructorKind]] internal slot of F to \"base\".\n    F.$ConstructorKind = \"base\";\n  }\n\n  // 10. Set the [[Strict]] internal slot of F to strict.\n  F.$Strict = strict;\n\n  // 11. Set the [[FunctionKind]] internal slot of F to functionKind.\n  F.$FunctionKind = functionKind;\n\n  // 12. Set the [[Prototype]] internal slot of F to functionPrototype.\n  F.$Prototype = functionPrototype;\n\n  // 13. Set the [[Extensible]] internal slot of F to true.\n  F.setExtensible(true);\n\n  // 14. Set the [[Realm]] internal slot of F to the current Realm Record.\n  F.$Realm = realm;\n\n  // 15. Return F.\n  return F;\n}\n\n// ECMA262 9.4.1.1\nfunction $BoundCall(realm: Realm, F: BoundFunctionValue, thisArgument: Value, argumentsList: Array<Value>): Value {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Let boundThis be the value of F's [[BoundThis]] internal slot.\n  let boundThis = F.$BoundThis;\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. Return ? Call(target, boundThis, args).\n  return Call(realm, target, boundThis, args);\n}\n\n// ECMA262 9.4.1.2\nfunction $BoundConstruct(realm: Realm, F: BoundFunctionValue, argumentsList: Array<Value>, newTarget: ObjectValue): ObjectValue {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Assert: target has a [[Construct]] internal method.\n  invariant(target.$Construct !== undefined, \"doesn't have a construct internal method\");\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. If SameValue(F, newTarget) is true, let newTarget be target.\n  if (SameValue(realm, F, newTarget)) newTarget = target;\n\n  // 6. Return ? Construct(target, args, newTarget).\n  return Construct(realm, target, args, newTarget);\n}\n\n// ECMA262 9.4.1.3\nexport function BoundFunctionCreate(realm: Realm, targetFunction: ObjectValue, boundThis: Value, boundArgs: Array<Value>): ObjectValue {\n  // 1. Assert: Type(targetFunction) is Object.\n  invariant(targetFunction instanceof ObjectValue, \"expected an object\");\n\n  // 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().\n  let proto = targetFunction.$GetPrototypeOf();\n\n  // 3. Let obj be a newly created object.\n  let obj = new BoundFunctionValue(realm);\n\n  // 4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n  // 5. Set the [[Call]] internal method of obj as described in 9.4.1.1.\n  obj.$Call = (thisArgument, argsList) => {\n    return $BoundCall(realm, obj, thisArgument, argsList);\n  };\n\n  // 6. If targetFunction has a [[Construct]] internal method, then\n  if (targetFunction.$Construct) {\n    // a. Set the [[Construct]] internal method of obj as described in 9.4.1.2.\n    obj.$Construct = (thisArgument, argsList) => {\n      return $BoundConstruct(realm, obj, thisArgument, argsList);\n    };\n  }\n\n  // 7. Set the [[Prototype]] internal slot of obj to proto.\n  obj.$Prototype = proto;\n\n  // 8. Set the [[Extensible]] internal slot of obj to true.\n  obj.setExtensible(true);\n\n  // 9. Set the [[BoundTargetFunction]] internal slot of obj to targetFunction.\n  obj.$BoundTargetFunction = targetFunction;\n\n  // 10. Set the [[BoundThis]] internal slot of obj to the value of boundThis.\n  obj.$BoundThis = boundThis;\n\n  // 11. Set the [[BoundArguments]] internal slot of obj to boundArgs.\n  obj.$BoundArguments = boundArgs;\n\n  // 12. Return obj.\n  return obj;\n}\n\n// ECMA262 18.2.1.1\nexport function PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value {\n  // 1. Assert: If direct is false, then strictCaller is also false.\n  if (direct === false) invariant(strictCaller === false, \"strictCaller is only allowed on direct eval\");\n\n  // 2. If Type(x) is not String, return x.\n  if (!(x instanceof StringValue)) return x;\n\n  // 3. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode text\n  //    as described in 6.1.4, for the goal symbol Script. If the parse fails, throw a SyntaxError exception. If any\n  //    early errors are detected, throw a SyntaxError or a ReferenceError exception, depending on the type of the\n  //    error (but see also clause 16). Parsing and early error detection may be interweaved in an implementation\n  //    dependent manner.\n  let ast = parse(realm, x.value, \"eval\", \"script\");\n  let script = ast.program;\n\n  // 4. If script Contains ScriptBody is false, return undefined.\n  if (!script.body) return realm.intrinsics.undefined;\n\n  // 5. Let body be the ScriptBody of script.\n  let body = t.blockStatement(script.body, script.directives);\n\n  // 6. If strictCaller is true, let strictEval be true.\n  let strictEval;\n  if (strictCaller) {\n    strictEval = true;\n  } else { // 7. Else, let strictEval be IsStrict of script.\n    strictEval = IsStrict(script);\n  }\n\n  // 8. Let ctx be the running execution context. If direct is true, ctx will be the execution context that\n  //    performed the direct eval. If direct is false, ctx will be the execution context for the invocation of\n  //    the eval function.\n  let ctx = realm.getRunningContext();\n\n  // 9. If direct is true, then\n  let lexEnv, varEnv;\n  if (direct) {\n    // a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).\n    lexEnv = NewDeclarativeEnvironment(realm, ctx.lexicalEnvironment);\n\n    // b. Let varEnv be ctx's VariableEnvironment.\n    varEnv = ctx.variableEnvironment;\n  } else { // 10. Else,\n    // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).\n    lexEnv = NewDeclarativeEnvironment(realm, evalRealm.$GlobalEnv);\n\n    // b. Let varEnv be evalRealm.[[GlobalEnv]].\n    varEnv = evalRealm.$GlobalEnv;\n  }\n\n  // 11. If strictEval is true, let varEnv be lexEnv.\n  if (strictEval) varEnv = lexEnv;\n\n  // 12. If ctx is not already suspended, suspend ctx.\n  ctx.suspend();\n\n  // 13. Let evalCxt be a new ECMAScript code execution context.\n  let evalCxt = new ExecutionContext();\n\n  // 14. Set the evalCxt's Function to null.\n  evalCxt.setFunction(null);\n\n  // 15. Set the evalCxt's Realm to evalRealm.\n  evalCxt.setRealm(evalRealm);\n\n  // 16. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.\n  evalCxt.ScriptOrModule = ctx.ScriptOrModule;\n\n  // 17. Set the evalCxt's VariableEnvironment to varEnv.\n  evalCxt.variableEnvironment = varEnv;\n\n  // 18. Set the evalCxt's LexicalEnvironment to lexEnv.\n  evalCxt.lexicalEnvironment = lexEnv;\n\n  // 19. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.\n  realm.pushContext(evalCxt);\n\n  let result;\n  try {\n    // 20. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).\n    invariant(varEnv);\n    try {\n      result = EvalDeclarationInstantiation(realm, body, varEnv, lexEnv, strictEval);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        result = e;\n      } else {\n        throw e;\n      }\n    }\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // 21. If result.[[Type]] is normal, then\n    if (result instanceof Value) {\n      // Evaluate expressions that passed for directives.\n      if (script.directives) {\n        for (let directive of script.directives) {\n          result = new StringValue(realm, directive.value.value);\n        }\n      }\n\n      // a. Let result be the result of evaluating body.\n      result = EvaluateStatements(script.body, result, strictEval, lexEnv, realm);\n    }\n\n    // 22. If result.[[Type]] is normal and result.[[Value]] is empty, then\n    if (result instanceof EmptyValue) {\n      // a. Let result be NormalCompletion(undefined).\n      result = realm.intrinsics.undefined;\n    }\n  } finally {\n    // 23. Suspend evalCxt and remove it from the execution context stack.\n    evalCxt.suspend();\n    realm.popContext(evalCxt);\n  }\n\n  // 24. Resume the context that is now on the top of the execution context stack as the running execution context.\n  invariant(realm.getRunningContext() === ctx);\n  ctx.resume();\n\n  // 25. Return Completion(result).\n  if (result instanceof Value) {\n    return result;\n  } else {\n    invariant(result instanceof AbruptCompletion);\n    throw result;\n  }\n}\n\nexport function EvaluateStatements(\n    body: Array<BabelNodeStatement>, blockValue: void | NormalCompletion | Value,\n    strictCode: boolean, blockEnv: LexicalEnvironment, realm: Realm): NormalCompletion | Value | Reference {\n  for (let node of body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let res = blockEnv.evaluateAbstractCompletion(node, strictCode);\n      invariant(!(res instanceof Reference));\n      if (!(res instanceof EmptyValue)) {\n        if (blockValue === undefined || blockValue instanceof Value) {\n          if (res instanceof AbruptCompletion)\n            throw UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty);\n          invariant(res instanceof NormalCompletion || res instanceof Value);\n          blockValue = res;\n        } else {\n          invariant(blockValue instanceof PossiblyNormalCompletion);\n          if (res instanceof AbruptCompletion) {\n            let e = realm.get_captured_effects();\n            invariant(e !== undefined);\n            realm.stop_effect_capture();\n            let [_c, _g, b, p, _o] = e;\n            _c; _g; _o;\n            realm.restoreBindings(b);\n            realm.restoreProperties(p);\n            if (res instanceof IntrospectionThrowCompletion) {\n              realm.apply_effects(e);\n              throw res;\n            }\n            invariant(blockValue instanceof PossiblyNormalCompletion);\n            e[0] = res;\n            let joined_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, blockValue, res, e);\n            realm.apply_effects(joined_effects);\n            throw joined_effects[0];\n          } else {\n            if (res instanceof Value)\n              blockValue.value = res;\n            else {\n              invariant(blockValue instanceof PossiblyNormalCompletion);\n              invariant(res instanceof PossiblyNormalCompletion);\n              blockValue = joinPossiblyNormalCompletions(realm, blockValue, res);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // 7. Return blockValue.\n  return blockValue || realm.intrinsics.empty;\n\n}\n\n// ECMA262 9.2.5\nexport function FunctionCreate(realm: Realm, kind: \"normal\" | \"arrow\" | \"method\", ParameterList: Array<BabelNodeLVal>, Body: BabelNodeBlockStatement, Scope: LexicalEnvironment, Strict: boolean, prototype?: ObjectValue) {\n  // 1. If the prototype argument was not passed, then\n  if (!prototype) {\n    // a. Let prototype be the intrinsic object %FunctionPrototype%.\n    prototype = realm.intrinsics.FunctionPrototype;\n  }\n\n  // 2. If kind is not Normal, let allocKind be \"non-constructor\".\n  let allocKind;\n  if (kind !== \"normal\") {\n    allocKind = \"non-constructor\";\n  } else { // 3. Else, let allocKind be \"normal\".\n    allocKind = \"normal\";\n  }\n\n  // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).\n  let F = FunctionAllocate(realm, prototype, Strict, allocKind);\n\n  // ECMAScript 2016, section 17:\n  //   \"Every other data property described in clauses 18 through 26 and in Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified.\"\n  // Because we call `AddRestrictedFunctionProperties` on `FunctionPrototype`, accessing property \"arguments\" will raise a `TypeError` by default.\n  // However, in non-strict mode this behavior is not desired, so we will add them as own properties of each `FunctionValue`, in accordance with ECMA 17.\n  // Note: \"arguments\" ***MUST NOT*** be set if the function is in strict mode or is an arrow, method, constructor, or generator function.\n  //   See 16.2 \"Forbidden Extensions\"\n  if (!Strict && kind === \"normal\") {\n    DefinePropertyOrThrow(realm, F, \"arguments\", {\n      value: realm.intrinsics.undefined,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n  return FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n}\n\n// ECMA262 18.2.1.2\nexport function EvalDeclarationInstantiation(realm: Realm, body: BabelNodeBlockStatement, varEnv: LexicalEnvironment, lexEnv: LexicalEnvironment, strict: boolean) {\n  // 1. Let varNames be the VarDeclaredNames of body.\n  let varNames = [];\n  traverse(body, function (node) {\n    if (node.type === \"VariableDeclaration\" && node.kind === \"var\") {\n      varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n    }\n\n    if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n\n    return false;\n  });\n\n  // 2. Let varDeclarations be the VarScopedDeclarations of body.\n  let varDeclarations = FindVarScopedDeclarations(body);\n\n  // 3. Let lexEnvRec be lexEnv's EnvironmentRecord.\n  let lexEnvRec = lexEnv.environmentRecord;\n\n  // 4. Let varEnvRec be varEnv's EnvironmentRecord.\n  let varEnvRec = varEnv.environmentRecord;\n\n  // 5. If strict is false, then\n  if (!strict) {\n    // a. If varEnvRec is a global Environment Record, then\n    if (varEnvRec instanceof GlobalEnvironmentRecord) {\n      // i. For each name in varNames, do\n      for (let name of varNames) {\n        // 1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n        if (varEnvRec.HasLexicalDeclaration(name)) {\n          throw new ThrowCompletion(\n            Construct(realm, realm.intrinsics.SyntaxError,\n               [new StringValue(realm, name + \" global object is restricted\")])\n          );\n        }\n        // 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.\n      }\n    }\n    // b. Let thisLex be lexEnv.\n    let thisLex = lexEnv;\n    // c. Assert: The following loop will terminate.\n    // d. Repeat while thisLex is not the same as varEnv,\n    while (thisLex !== varEnv) {\n      // i. Let thisEnvRec be thisLex's EnvironmentRecord.\n      let thisEnvRec = thisLex.environmentRecord;\n      // ii. If thisEnvRec is not an object Environment Record, then\n      if (!(thisEnvRec instanceof ObjectEnvironmentRecord)) {\n        // 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n        // 2. For each name in varNames, do\n        for (let name of varNames) {\n          // a. If thisEnvRec.HasBinding(name) is true, then\n          if (thisEnvRec.HasBinding(name)) {\n            // i. Throw a SyntaxError exception.\n            throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError,\n              name + \" global object is restricted\");\n            // ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.\n          }\n          // b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n        }\n      }\n      // iii. Let thisLex be thisLex's outer environment reference.\n      thisLex = thisLex.parent;\n      invariant(thisLex !== null);\n    }\n  }\n\n  // 6. Let functionsToInitialize be a new empty List.\n  let functionsToInitialize = [];\n\n  // 7. Let declaredFunctionNames be a new empty List.\n  let declaredFunctionNames = [];\n\n  // 8. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n      // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n      // iii. Let fn be the sole element of the BoundNames of d.\n      let fn = BoundNames(realm, d)[0];\n      // iv. If fn is not an element of declaredFunctionNames, then\n      if (declaredFunctionNames.indexOf(fn) < 0) {\n        // 1. If varEnvRec is a global Environment Record, then\n        if (varEnvRec instanceof GlobalEnvironmentRecord) {\n          // a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).\n          let fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn);\n          // b. If fnDefinable is false, throw a TypeError exception.\n          if (!fnDefinable) {\n            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError,\n              fn + \" is not definable\");\n          }\n        }\n        // 2. Append fn to declaredFunctionNames.\n        declaredFunctionNames.push(fn);\n        // 3. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 9. NOTE: Annex B.3.3.3 adds additional steps at this point.\n\n  // 10. Let declaredVarNames be a new empty List.\n  let declaredVarNames = [];\n\n  // 11. For each d in varDeclarations, do\n  for (let d of varDeclarations) {\n    // a. If d is a VariableDeclaration or a ForBinding, then\n    if (d.type === \"VariableDeclaration\") {\n      // i. For each String vn in the BoundNames of d, do\n      for (let vn of BoundNames(realm, d)) {\n        // 1. If vn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(vn) < 0) {\n          // a. If varEnvRec is a global Environment Record, then\n          if (varEnvRec instanceof GlobalEnvironmentRecord) {\n            // i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).\n            let vnDefinable = varEnvRec.CanDeclareGlobalVar(vn);\n            // ii. If vnDefinable is false, throw a TypeError exception.\n            if (!vnDefinable) {\n              throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError,\n                vn + \" is not definable\");\n            }\n          }\n          // b. If vn is not an element of declaredVarNames, then\n          if (declaredVarNames.indexOf(vn) < 0) {\n            // i. Append vn to declaredVarNames.\n            declaredVarNames.push(vn);\n          }\n        }\n      }\n    }\n  }\n\n  // 12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.\n\n  // 13. Let lexDeclarations be the LexicallyScopedDeclarations of body.\n  let lexDeclarations = [];\n  for (let s of body.body) {\n    if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n      lexDeclarations.push(s);\n    }\n  }\n\n  // 14. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE Lexically declared names are only instantiated here but not initialized.\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of BoundNames(realm, d)) {\n      // c. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\"){\n        // i. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).\n        lexEnvRec.CreateImmutableBinding(dn, true);\n      } else { // d. Else,\n        // i. Perform ? lexEnvRec.CreateMutableBinding(dn, false).\n        lexEnvRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 15. For each production f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = BoundNames(realm, f)[0];\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n    let fo = lexEnv.evaluate(f, strict);\n    invariant(fo instanceof Value);\n    // c. If varEnvRec is a global Environment Record, then\n    if (varEnvRec instanceof GlobalEnvironmentRecord) {\n      // i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).\n      varEnvRec.CreateGlobalFunctionBinding(fn, fo, true);\n    } else { // d. Else,\n      // i. Let bindingExists be varEnvRec.HasBinding(fn).\n      let bindingExists = varEnvRec.HasBinding(fn);\n      // ii. If bindingExists is false, then\n      if (!bindingExists) {\n        // 1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).\n        varEnvRec.CreateMutableBinding(fn, true);\n        // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n        // 3. Perform ! varEnvRec.InitializeBinding(fn, fo).\n        varEnvRec.InitializeBinding(fn, fo);\n      } else { // iii. Else,\n        // 1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n        varEnvRec.SetMutableBinding(fn, fo, false);\n      }\n    }\n  }\n\n  // 16. For each String vn in declaredVarNames, in list order do\n  for (let vn of declaredVarNames) {\n    // a. If varEnvRec is a global Environment Record, then\n    if (varEnvRec instanceof GlobalEnvironmentRecord) {\n      // i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).\n      varEnvRec.CreateGlobalVarBinding(vn, true);\n    } else { // b. Else,\n      // i. Let bindingExists be varEnvRec.HasBinding(vn).\n      let bindingExists = varEnvRec.HasBinding(vn);\n      // ii. If bindingExists is false, then\n      if (!bindingExists) {\n        // 1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).\n        varEnvRec.CreateMutableBinding(vn, true);\n        // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n        // 3. Perform ! varEnvRec.InitializeBinding(vn, undefined).\n        varEnvRec.InitializeBinding(vn, realm.intrinsics.undefined);\n      }\n    }\n  }\n\n  // 17. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\n// ECMA 9.2.10\nexport function MakeMethod(realm: Realm, F: FunctionValue, homeObject: ObjectValue) {\n  // Note that F is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(F));\n\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"F is an ECMAScript function object.\");\n\n  // 2. Assert: Type(homeObject) is Object.\n  invariant(homeObject instanceof ObjectValue, \"Type(homeObject) is Object.\");\n\n  // 3. Set the [[HomeObject]] internal slot of F to homeObject.\n  F.$HomeObject = homeObject;\n\n  // 4. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n"]}