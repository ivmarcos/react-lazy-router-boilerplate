"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MakeConstructor = MakeConstructor;
exports.Construct = Construct;
exports.SpeciesConstructor = SpeciesConstructor;

var _index = require("../values/index.js");

var _is = require("./is.js");

var _create = require("./create.js");

var _properties = require("./properties.js");

var _get = require("./get.js");

var _has = require("./has.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ECMA262 9.2.8
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function MakeConstructor(realm, F, writablePrototype, prototype) {
  // 1. Assert: F is an ECMAScript function object.
  (0, _invariant2.default)(F instanceof _index.FunctionValue, "expected function value");

  // 2. Assert: F has a [[Construct]] internal method.
  (0, _invariant2.default)(F.$Construct !== undefined, "expected construct internal method");

  // 3. Assert: F is an extensible object that does not have a prototype own property.
  (0, _invariant2.default)(F.getExtensible(), "expected extensible object that doesn't have prototype own property");

  // 4. If the writablePrototype argument was not provided, let writablePrototype be true.
  if (writablePrototype === null || writablePrototype === undefined) {
    writablePrototype = true;
  }

  // 5. If the prototype argument was not provided, then
  if (!prototype) {
    // a. Let prototype be ObjectCreate(%ObjectPrototype%).
    prototype = (0, _create.ObjectCreate)(realm, realm.intrinsics.ObjectPrototype);
    prototype.originalConstructor = F;

    // b. Perform ! DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor{[[Value]]: F, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: true }).
    (0, _properties.DefinePropertyOrThrow)(realm, prototype, "constructor", {
      value: F,
      writable: writablePrototype,
      enumerable: false,
      configurable: true
    });
  }

  // 6. Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: false}).
  (0, _properties.DefinePropertyOrThrow)(realm, F, "prototype", {
    value: prototype,
    writable: writablePrototype,
    enumerable: false,
    configurable: false
  });

  // 7. Return NormalCompletion(undefined).
  return realm.intrinsics.undefined;
}

// ECMA262 7.3.13
function Construct(realm, F, argumentsList, newTarget) {
  // If newTarget was not passed, let newTarget be F.
  if (!newTarget) newTarget = F;

  // If argumentsList was not passed, let argumentsList be a new empty List.
  if (!argumentsList) argumentsList = [];

  // Assert: IsConstructor(F) is true.
  (0, _invariant2.default)((0, _is.IsConstructor)(realm, F), "expected constructor");

  // Assert: IsConstructor(newTarget) is true.
  (0, _invariant2.default)((0, _is.IsConstructor)(realm, newTarget), "expected constructor");

  // Return ? F.[[Construct]](argumentsList, newTarget).
  (0, _invariant2.default)(F.$Construct !== undefined, "no construct method on realm value");
  return F.$Construct(argumentsList, newTarget);
}

// ECMA262 7.3.20
function SpeciesConstructor(realm, O, defaultConstructor) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant2.default)(O instanceof _index.ObjectValue, "Type(O) is Object");

  // 2. Let C be ? Get(O, "constructor").
  var C = (0, _get.Get)(realm, O, "constructor");

  // 3. If C is undefined, return defaultConstructor.
  if (C instanceof _index.UndefinedValue) return defaultConstructor;

  // 4. If Type(C) is not Object, throw a TypeError exception.
  if (!(C instanceof _index.ObjectValue || C instanceof _index.AbstractObjectValue)) {
    C.throwIfNotConcrete();
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(C) is not an object");
  }

  // 5. Let S be ? Get(C, @@species).
  var S = (0, _get.Get)(realm, C, realm.intrinsics.SymbolSpecies);

  // 6. If S is either undefined or null, return defaultConstructor.
  if ((0, _has.HasSomeCompatibleType)(realm, S, _index.UndefinedValue, _index.NullValue)) return defaultConstructor;

  // 7. If IsConstructor(S) is true, return S.
  if ((0, _is.IsConstructor)(realm, S)) {
    (0, _invariant2.default)(S instanceof _index.ObjectValue);
    return S;
  }

  // 8. Throw a TypeError exception.
  throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Throw a TypeError exception");
}
//# sourceMappingURL=construct.js.map