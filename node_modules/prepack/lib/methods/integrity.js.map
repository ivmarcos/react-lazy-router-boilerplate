{"version":3,"sources":["../../src/methods/integrity.js"],"names":["OrdinaryPreventExtensions","SetIntegrityLevel","TestIntegrityLevel","realm","O","setExtensible","level","status","$PreventExtensions","keys","$OwnPropertyKeys","k","configurable","currentDesc","$GetOwnProperty","value","desc","writable"],"mappings":"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","file":"integrity.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { ObjectValue } from \"../values/index.js\";\nimport { IsExtensible, IsDataDescriptor, IsAccessorDescriptor, ThrowIfMightHaveBeenDeleted } from \"./index.js\";\nimport { DefinePropertyOrThrow } from \"./properties.js\";\nimport invariant from \"../invariant.js\";\n\ntype IntegrityLevels = \"sealed\" | \"frozen\";\n\n// ECMA262 9.1.4.1\nexport function OrdinaryPreventExtensions(realm: Realm, O: ObjectValue): boolean {\n  // 1. Set the value of the [[Extensible]] internal slot of O to false.\n  O.setExtensible(false);\n\n  // 2. Return true.\n  return true;\n}\n\n// ECMA262 7.3.14\nexport function SetIntegrityLevel(realm: Realm, O: ObjectValue, level: IntegrityLevels): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue, \"expected an object\");\n\n  // 2. Assert: level is either \"sealed\" or \"frozen\".\n  invariant(level === \"sealed\" || level === \"frozen\", \"invalid level\");\n\n  // 3. Let status be ? O.[[PreventExtensions]]().\n  let status = O.$PreventExtensions();\n\n  // 4. If status is false, return false.\n  if (status === false) return false;\n\n  // 5. Let keys be ? O.[[OwnPropertyKeys]]().\n  let keys = O.$OwnPropertyKeys();\n\n  // 6. If level is \"sealed\", then\n  if (level === \"sealed\") {\n    // a. Repeat for each element k of keys,\n    for (let k of keys) {\n      // i. Perform ? DefinePropertyOrThrow(O, k, PropertyDescriptor{[[Configurable]]: false}).\n      DefinePropertyOrThrow(realm, O, k, {\n        configurable: false\n      });\n    }\n  } else if (level === \"frozen\") { // 7. Else level is \"frozen\",\n    // a. Repeat for each element k of keys,\n    for (let k of keys) {\n      // i. Let currentDesc be ? O.[[GetOwnProperty]](k).\n      let currentDesc = O.$GetOwnProperty(k);\n\n      // ii. If currentDesc is not undefined, then\n      if (currentDesc) {\n        ThrowIfMightHaveBeenDeleted(currentDesc.value);\n        let desc;\n\n        // 1. If IsAccessorDescriptor(currentDesc) is true, then\n        if (IsAccessorDescriptor(realm, currentDesc)) {\n          // a. Let desc be the PropertyDescriptor{[[Configurable]]: false}.\n          desc = { configurable: false };\n        } else { // 2. Else,\n          // b. Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.\n          desc = { configurable: false, writable: false };\n        }\n\n        // 3. Perform ? DefinePropertyOrThrow(O, k, desc).\n        DefinePropertyOrThrow(realm, O, k, desc);\n      }\n    }\n  }\n\n  // 8. Return true.\n  return true;\n}\n\n// ECMA262 7.3.15\nexport function TestIntegrityLevel(realm: Realm, O: ObjectValue, level: IntegrityLevels): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue, \"expected an object\");\n\n  // 2. Assert: level is either \"sealed\" or \"frozen\".\n  invariant(level === \"sealed\" || level === \"frozen\", \"invalid level\");\n\n  // 3. Let status be ? IsExtensible(O).\n  let status = IsExtensible(realm, O);\n\n  // 4. If status is true, return false.\n  if (status === true) return false;\n\n  // 5. NOTE If the object is extensible, none of its properties are examined.\n\n  // 6. Let keys be ? O.[[OwnPropertyKeys]]().\n  let keys = O.$OwnPropertyKeys();\n\n  // 7. Repeat for each element k of keys,\n  for (let k of keys) {\n    // a. Let currentDesc be ? O.[[GetOwnProperty]](k).\n    let currentDesc = O.$GetOwnProperty(k);\n\n    // b. If currentDesc is not undefined, then\n    if (currentDesc) {\n      ThrowIfMightHaveBeenDeleted(currentDesc.value);\n\n      // i. If currentDesc.[[Configurable]] is true, return false.\n      if (currentDesc.configurable === true) return false;\n\n      // ii. If level is \"frozen\" and IsDataDescriptor(currentDesc) is true, then\n      if (level === \"frozen\" && IsDataDescriptor(realm, currentDesc) === true) {\n        // 1. If currentDesc.[[Writable]] is true, return false.\n        if (currentDesc.writable === true) return false;\n      }\n    }\n  }\n\n  // 8. Return true.\n  return true;\n}\n"]}