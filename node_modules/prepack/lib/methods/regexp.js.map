{"version":3,"sources":["../../src/methods/regexp.js"],"names":["RegExpCreate","RegExpAlloc","RegExpInitialize","RegExpExec","RegExpBuiltinExec","AdvanceStringIndex","EscapeRegExpPattern","realm","P","F","obj","intrinsics","RegExp","newTarget","$RegExpMatcher","undefined","$OriginalSource","$OriginalFlags","writable","enumerable","configurable","pattern","flags","isNewObject","i","length","indexOf","charAt","createErrorThrowCompletion","SyntaxError","j","BMP","computedFlags","matcher","S","lastIndex","match","exec","endIndex","index","captures","e","zero","R","result","TypeError","throwIfNotConcrete","global","sticky","fullUnicode","matchSucceeded","r","null","n","A","lengthOfA","value","matchIndex","matchedSubstr","substr","captureI","capturedValue","unicode","Math","pow","first","charCodeAt","second","replace"],"mappings":";;;;;QAuBgBA,Y,GAAAA,Y;QASAC,W,GAAAA,W;QAsBAC,gB,GAAAA,gB;QA8FAC,U,GAAAA,U;QAkCAC,iB,GAAAA,iB;QAiJAC,kB,GAAAA,kB;QAmCAC,mB,GAAAA,mB;;AA9VhB;;;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAEA;AAtBA;;;;;;;;;AAuBO,SAASN,YAAT,CAAsBO,KAAtB,EAAoCC,CAApC,EAA+CC,CAA/C,EAAuE;AAC5E;AACA,MAAIC,MAAMT,YAAYM,KAAZ,EAAmBA,MAAMI,UAAN,CAAiBC,MAApC,CAAV;;AAEA;AACA,SAAOV,iBAAiBK,KAAjB,EAAwBG,GAAxB,EAA6BF,CAA7B,EAAgCC,CAAhC,CAAP;AACD;;AAED;AACO,SAASR,WAAT,CAAqBM,KAArB,EAAmCM,SAAnC,EAAwE;AAC7E;AACA;AACA,MAAIH,MAAM,2CAA8BH,KAA9B,EAAqCM,SAArC,EAAgD,iBAAhD,EAAmE;AAC3EC,oBAAgBC,SAD2D,EAChD;AAC3BC,qBAAiBD,SAF0D,EAE/C;AAC5BE,oBAAgBF,SAH2D,CAGjD;AAHiD,GAAnE,CAAV;;AAMA;AACA;AACA,yCAAsBR,KAAtB,EAA6BG,GAA7B,EAAkC,WAAlC,EAA+C;AAC7CQ,cAAU,IADmC;AAE7CC,gBAAY,KAFiC;AAG7CC,kBAAc;AAH+B,GAA/C;;AAMA;AACA,SAAOV,GAAP;AACD;;AAED;AACO,SAASR,gBAAT,CAA0BK,KAA1B,EAAwCG,GAAxC,EAA0DW,OAA1D,EAA2EC,KAA3E,EAAuG;AAC5G;AACA,2BAAUf,MAAMgB,WAAN,CAAkBb,GAAlB,CAAV;;AAEA;AACA,MAAIF,UAAJ;AACA,MAAI,CAACa,OAAD,IAAY,4BAAkBd,KAAlB,EAAyBc,OAAzB,wBAAhB,EAAmE;AACjEb,QAAI,EAAJ;AACD,GAFD,MAEO;AAAE;AACPA,QAAI,yBAAgBD,KAAhB,EAAuBc,OAAvB,CAAJ;AACD;;AAED;AACA,MAAIZ,UAAJ;AACA,MAAI,CAACa,KAAD,IAAU,4BAAkBf,KAAlB,EAAyBe,KAAzB,wBAAd,EAA+D;AAC7Db,QAAI,EAAJ;AACD,GAFD,MAEO;AAAE;AACPA,QAAI,yBAAgBF,KAAhB,EAAuBe,KAAvB,CAAJ;AACD;;AAED;AACA,OAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAIf,EAAEgB,MAAtB,EAA8B,EAAED,CAAhC,EAAmC;AACjC,QAAI,QAAQE,OAAR,CAAgBjB,EAAEkB,MAAF,CAASH,CAAT,CAAhB,IAA+B,CAAnC,EAAsC;AACpC,YAAMjB,MAAMqB,0BAAN,CAAiCrB,MAAMI,UAAN,CAAiBkB,WAAlD,EAA+D,qBAA/D,CAAN;AACD;AACD,SAAK,IAAIC,IAAIN,IAAI,CAAjB,EAAoBM,IAAIrB,EAAEgB,MAA1B,EAAkC,EAAEK,CAApC,EAAuC;AACrC,UAAIrB,EAAEkB,MAAF,CAASH,CAAT,MAAgBf,EAAEkB,MAAF,CAASG,CAAT,CAApB,EAAiC;AAC/B,cAAMvB,MAAMqB,0BAAN,CAAiCrB,MAAMI,UAAN,CAAiBkB,WAAlD,EAA+D,uBAA/D,CAAN;AACD;AACF;AACF;;AAED;AACA,MAAIE,MAAMtB,EAAEiB,OAAF,CAAU,GAAV,KAAkB,CAAlB,GAAsB,KAAtB,GAA8B,IAAxC;;AAEA;AACA,MAAIK,GAAJ,EAAS;AACP;AACA;AACA;AACA;AACA;AACD,GAND,MAMO,CAQN,CAdD,CAMS;AACP;AACA;AACA;AACA;AACA;AACA;;AAIF;AACArB,MAAIM,eAAJ,GAAsBR,CAAtB;;AAEA;AACAE,MAAIO,cAAJ,GAAqBR,CAArB;;AAEA;AACA;AACA;AACA,MAAI;AACF,QAAIuB,gBAAgB,GAApB;AACA,QAAIvB,EAAEiB,OAAF,CAAU,GAAV,KAAkB,CAAtB,EAAyBM,iBAAiB,GAAjB;AACzB,QAAIvB,EAAEiB,OAAF,CAAU,GAAV,KAAkB,CAAtB,EAAyBM,iBAAiB,GAAjB;AACzB,QAAIvB,EAAEiB,OAAF,CAAU,GAAV,KAAkB,CAAtB,EAAyBM,iBAAiB,GAAjB;AACzB,QAAIC,UAAU,IAAIrB,MAAJ,CAAWJ,CAAX,EAAewB,aAAf,CAAd;;AAEAtB,QAAII,cAAJ,GAAqB,UAACoB,CAAD,EAAYC,SAAZ,EAAkC;AACrDF,cAAQE,SAAR,GAAoBA,SAApB;AACA,UAAIC,QAAQH,QAAQI,IAAR,CAAaH,CAAb,CAAZ;AACA,UAAI,CAACE,KAAL,EAAY;AACV,eAAO,IAAP;AACD;AACD,aAAO;AACLE,kBAAUF,MAAMG,KAAN,GAAcH,MAAM,CAAN,EAASX,MAD5B;AAELe,kBAAUJ;AAFL,OAAP;AAID,KAVD;AAWD,GAlBD,CAkBE,OAAOK,CAAP,EAAU;AACV,QAAIA,aAAaZ,WAAjB,EAA8B;AAC5B,YAAMtB,MAAMqB,0BAAN,CAAiCrB,MAAMI,UAAN,CAAiBkB,WAAlD,EAA+D,gBAA/D,CAAN;AACD,KAFD,MAGE,MAAMY,CAAN;AACH;;AAED;AACA,uBAAIlC,KAAJ,EAAWG,GAAX,EAAgB,WAAhB,EAA6BH,MAAMI,UAAN,CAAiB+B,IAA9C,EAAoD,IAApD;;AAEA;AACA,SAAOhC,GAAP;AACD;;AAED;AACO,SAASP,UAAT,CAAoBI,KAApB,EAAkCoC,CAAlC,EAAkDT,CAAlD,EAAsF;AAC3F;AACA,2BAAUS,+BAAV,EAAoC,mBAApC;;AAEA;AACA,2BAAU,OAAOT,CAAP,KAAa,QAAvB,EAAiC,mBAAjC;;AAEA;AACA,MAAIG,OAAO,cAAI9B,KAAJ,EAAWoC,CAAX,EAAc,MAAd,CAAX;;AAEA;AACA,MAAI,oBAAWpC,KAAX,EAAkB8B,IAAlB,CAAJ,EAA6B;AAC3B;AACA,QAAIO,SAAS,gBAAKrC,KAAL,EAAY8B,IAAZ,EAAkBM,CAAlB,EAAqB,CAAC,uBAAgBpC,KAAhB,EAAuB2B,CAAvB,CAAD,CAArB,CAAb;;AAEA;AACA,QAAI,CAAC,gCAAsB3B,KAAtB,EAA6BqC,MAA7B,uCAAL,EAAmE;AACjE,YAAMrC,MAAMqB,0BAAN,CAAiCrB,MAAMI,UAAN,CAAiBkC,SAAlD,EAA6D,wCAA7D,CAAN;AACD;;AAED;AACA,WAASD,OAAOE,kBAAP,EAAT;AACD;;AAED;AACA,MAAIH,EAAE7B,cAAF,KAAqBC,SAAzB,EAAoC;AAClC,UAAMR,MAAMqB,0BAAN,CAAiCrB,MAAMI,UAAN,CAAiBkC,SAAlD,EAA6D,mDAA7D,CAAN;AACD;;AAED;AACA,SAAOzC,kBAAkBG,KAAlB,EAAyBoC,CAAzB,EAA4BT,CAA5B,CAAP;AACD;;AAED;AACO,SAAS9B,iBAAT,CAA2BG,KAA3B,EAAyCoC,CAAzC,EAAyDT,CAAzD,EAA6F;AAClG;AACA,2BAAUS,EAAE7B,cAAF,KAAqBC,SAArB,IAAkC4B,EAAE3B,eAAF,KAAsBD,SAAxD,IAAqE4B,EAAE1B,cAAF,KAAqBF,SAApG,EAA+G,qCAA/G;;AAEA;AACA,2BAAU,OAAOmB,CAAP,KAAa,QAAvB,EAAiC,mBAAjC;;AAEA;AACA,MAAIT,SAASS,EAAET,MAAf;;AAEA;AACA,MAAIU,YAAY,kBAAS5B,KAAT,EAAgB,cAAIA,KAAJ,EAAWoC,CAAX,EAAc,WAAd,CAAhB,CAAhB;;AAEA;AACA,MAAIrB,QAAQqB,EAAE1B,cAAd;AACA,2BAAU,OAAOK,KAAP,KAAiB,QAA3B;;AAEA;AACA,MAAIyB,SAASzB,MAAMI,OAAN,CAAc,GAAd,KAAsB,CAAtB,GAA0B,IAA1B,GAAiC,KAA9C;;AAEA;AACA,MAAIsB,SAAS1B,MAAMI,OAAN,CAAc,GAAd,KAAsB,CAAtB,GAA0B,IAA1B,GAAiC,KAA9C;;AAEA;AACA,MAAIqB,WAAW,KAAX,IAAoBC,WAAW,KAAnC,EAA0Cb,YAAY,CAAZ;;AAE1C;AACA,MAAIF,UAAUU,EAAE7B,cAAhB;AACA,2BAAUmB,YAAYlB,SAAtB;;AAEA;AACA,MAAIkC,cAAc3B,MAAMI,OAAN,CAAc,GAAd,KAAsB,CAAtB,GAA0B,IAA1B,GAAiC,KAAnD;;AAEA;AACA,MAAIwB,iBAAiB,KAArB;;AAEA,MAAIC,IAAI,IAAR;AACA;AACA,SAAO,CAACD,cAAR,EAAwB;AACtB;AACA,QAAIf,YAAYV,MAAhB,EAAwB;AACtB;AACA,2BAAIlB,KAAJ,EAAWoC,CAAX,EAAc,WAAd,EAA2BpC,MAAMI,UAAN,CAAiB+B,IAA5C,EAAkD,IAAlD;AACA;AACA,aAAOnC,MAAMI,UAAN,CAAiByC,IAAxB;AACD;;AAED;AACAD,QAAIlB,QAAQC,CAAR,EAAWC,SAAX,CAAJ;;AAEA;AACA,QAAIgB,KAAK,IAAT,EAAe;AACb;AACA,UAAIH,MAAJ,EAAY;AACV;AACA,6BAAIzC,KAAJ,EAAWoC,CAAX,EAAc,WAAd,EAA2BpC,MAAMI,UAAN,CAAiB+B,IAA5C,EAAkD,IAAlD;;AAEA;AACA,eAAOnC,MAAMI,UAAN,CAAiByC,IAAxB;AACD;AACD;AACAjB,kBAAY9B,mBAAmBE,KAAnB,EAA0B2B,CAA1B,EAA6BC,SAA7B,EAAwCc,WAAxC,CAAZ;AACD,KAXD,MAWO;AAAE;AACP;AACA,+BAAUE,CAAV,EAAa,cAAb;;AAEA;AACAD,uBAAiB,IAAjB;;AAEA;AACAf,kBAAagB,EAAEX,QAAH,CAAkBD,KAA9B;AACD;AACF;AACD,2BAAUY,KAAK,IAAf;;AAEA;AACA,MAAIV,IAAIU,EAAEb,QAAV;;AAEA;AACA,MAAIW,WAAJ,EAAiB,CAGhB;AAFC;AACA;;;AAGF;AACA,MAAIF,WAAW,IAAX,IAAmBC,WAAW,IAAlC,EAAwC;AACtC;AACA,yBAAIzC,KAAJ,EAAWoC,CAAX,EAAc,WAAd,EAA2B,uBAAgBpC,KAAhB,EAAuBkC,CAAvB,CAA3B,EAAsD,IAAtD;AACD;;AAED;AACA,MAAIY,IAAIF,EAAEX,QAAF,CAAWf,MAAX,GAAoB,CAA5B;;AAEA;AACA,MAAI6B,IAAI,yBAAY/C,KAAZ,EAAmB8C,IAAI,CAAvB,CAAR;;AAEA;AACA,MAAIE,YAAY,cAAIhD,KAAJ,EAAW+C,CAAX,EAAc,QAAd,EAAwBR,kBAAxB,EAAhB;AACA,2BAAUS,uCAAV;AACA,2BAAUA,UAAUC,KAAV,KAAoBH,IAAI,CAAlC,EAAqC,+CAArC;;AAEA;AACA,MAAII,aAAatB,SAAjB;;AAEA;AACA,kCAAmB5B,KAAnB,EAA0B+C,CAA1B,EAA6B,OAA7B,EAAsC,uBAAgB/C,KAAhB,EAAuBkD,UAAvB,CAAtC;;AAEA;AACA,kCAAmBlD,KAAnB,EAA0B+C,CAA1B,EAA6B,OAA7B,EAAsC,uBAAgB/C,KAAhB,EAAuB2B,CAAvB,CAAtC;;AAEA;AACA,MAAIwB,gBAAgBxB,EAAEyB,MAAF,CAASxB,SAAT,EAAoBM,IAAIN,SAAxB,CAApB;;AAEA;AACA,kCAAmB5B,KAAnB,EAA0B+C,CAA1B,EAA6B,GAA7B,EAAkC,uBAAgB/C,KAAhB,EAAuBmD,aAAvB,CAAlC;;AAEA;AACA,OAAK,IAAIlC,IAAI,CAAb,EAAgBA,KAAK6B,CAArB,EAAwB,EAAE7B,CAA1B,EAA6B;AAC3B;AACA,QAAIoC,WAAWT,EAAEX,QAAF,CAAWhB,CAAX,CAAf;;AAEA,QAAIqC,sBAAJ;AACA;AACA,QAAID,aAAa7C,SAAjB,EAA4B;AAC1B8C,sBAAgBtD,MAAMI,UAAN,CAAiBI,SAAjC;AACD,KAFD,MAEO,IAAIkC,WAAJ,EAAiB;AAAE;AACxB;AACA;AACAY,sBAAgBtD,MAAMI,UAAN,CAAiBI,SAAjC;AACD,KAJM,MAIA;AAAE;AACP;AACA,+BAAU,OAAO6C,QAAP,KAAoB,QAA9B;;AAEA;AACAC,sBAAgB,uBAAgBtD,KAAhB,EAAuBqD,QAAvB,CAAhB;AACD;;AAED;AACA,oCAAmBrD,KAAnB,EAA0B+C,CAA1B,EAA6B,kBAAS/C,KAAT,EAAgB,uBAAgBA,KAAhB,EAAuBiB,CAAvB,CAAhB,CAA7B,EAAyEqC,aAAzE;AACD;;AAED;AACA,SAAOP,CAAP;AACD;;AAEM,SAASjD,kBAAT,CAA4BE,KAA5B,EAA0C2B,CAA1C,EAAqDK,KAArD,EAAoEuB,OAApE,EAA8F;AACnG;AACA,2BAAU,OAAO5B,CAAP,KAAa,QAAvB,EAAiC,mBAAjC;;AAEA;AACA,2BAAUK,SAAS,CAAT,IAAcA,SAASwB,KAAKC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAnD,EAAsD,6CAAtD;;AAEA;AACA,2BAAU,OAAOF,OAAP,KAAmB,SAA7B,EAAwC,0BAAxC;;AAEA;AACA,MAAIA,YAAY,KAAhB,EAAuB,OAAOvB,QAAQ,CAAf;;AAEvB;AACA,MAAId,SAASS,EAAET,MAAf;;AAEA;AACA,MAAIc,QAAQ,CAAR,IAAad,MAAjB,EAAyB,OAAOc,QAAQ,CAAf;;AAEzB;AACA,MAAI0B,QAAQ/B,EAAEgC,UAAF,CAAa3B,KAAb,CAAZ;;AAEA;AACA,MAAI0B,QAAQ,MAAR,IAAkBA,QAAQ,MAA9B,EAAsC,OAAO1B,QAAQ,CAAf;;AAEtC;AACA,MAAI4B,SAASjC,EAAEgC,UAAF,CAAa3B,QAAQ,CAArB,CAAb;;AAEA;AACA,MAAI4B,SAAS,MAAT,IAAmBA,SAAS,MAAhC,EAAwC,OAAO5B,QAAQ,CAAf;;AAExC;AACA,SAAOA,QAAQ,CAAf;AACD;;AAEM,SAASjC,mBAAT,CAA6BC,KAA7B,EAA2CC,CAA3C,EAAsDC,CAAtD,EAAyE;AAC9E,SAAOD,EAAE4D,OAAF,CAAU,GAAV,EAAe,IAAf,CAAP;AACD","file":"regexp.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\nimport { NullValue, NumberValue, ObjectValue, StringValue, UndefinedValue, Value } from \"../values/index.js\";\nimport { ArrayCreate, OrdinaryCreateFromConstructor, CreateDataProperty } from \"./create.js\";\nimport { DefinePropertyOrThrow, Set } from \"./properties.js\";\nimport { ToString, ToStringPartial, ToLength } from \"./to.js\";\nimport { Get } from \"./get.js\";\nimport { IsCallable } from \"./is.js\";\nimport { Call } from \"./call.js\";\nimport { HasCompatibleType, HasSomeCompatibleType } from \"./has.js\";\n\n// ECMA262 21.2.3.2.3\nexport function RegExpCreate(realm: Realm, P: ?Value, F: ?Value): ObjectValue {\n  // 1. Let obj be ? RegExpAlloc(%RegExp%).\n  let obj = RegExpAlloc(realm, realm.intrinsics.RegExp);\n\n  // 2. Return ? RegExpInitialize(obj, P, F).\n  return RegExpInitialize(realm, obj, P, F);\n}\n\n// ECMA262 21.2.3.2.1\nexport function RegExpAlloc(realm: Realm, newTarget: ObjectValue): ObjectValue {\n  // 1. Let obj be ? OrdinaryCreateFromConstructor(newTarget, \"%RegExpPrototype%\", « [[RegExpMatcher]],\n  //    [[OriginalSource]], [[OriginalFlags]] »).\n  let obj = OrdinaryCreateFromConstructor(realm, newTarget, \"RegExpPrototype\", {\n    $RegExpMatcher: undefined, // always initialized to not undefined before use\n    $OriginalSource: undefined, // ditto\n    $OriginalFlags: undefined // ditto\n  });\n\n  // 2. Perform ! DefinePropertyOrThrow(obj, \"lastIndex\", PropertyDescriptor {[[Writable]]: true,\n  //    [[Enumerable]]: false, [[Configurable]]: false}).\n  DefinePropertyOrThrow(realm, obj, \"lastIndex\", {\n    writable: true,\n    enumerable: false,\n    configurable: false\n  });\n\n  // 3. Return obj.\n  return obj;\n}\n\n// ECMA262 21.2.3.2.2\nexport function RegExpInitialize(realm: Realm, obj: ObjectValue, pattern: ?Value, flags: ?Value): ObjectValue {\n  // Note that obj is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(obj));\n\n  // 1. If pattern is undefined, let P be the empty String.\n  let P;\n  if (!pattern || HasCompatibleType(realm, pattern, UndefinedValue)) {\n    P = \"\";\n  } else { // 2. Else, let P be ? ToString(pattern).\n    P = ToStringPartial(realm, pattern);\n  }\n\n  // 3. If flags is undefined, let F be the empty String.\n  let F;\n  if (!flags || HasCompatibleType(realm, flags, UndefinedValue)) {\n    F = \"\";\n  } else { // 4. Else, let F be ? ToString(flags).\n    F = ToStringPartial(realm, flags);\n  }\n\n  // 5. If F contains any code unit other than \"g\", \"i\", \"m\", \"u\", or \"y\" or if it contains the same code unit more than once, throw a SyntaxError exception.\n  for (let i = 0; i < F.length; ++i) {\n    if (\"gimuy\".indexOf(F.charAt(i)) < 0) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"invalid RegExp flag\");\n    }\n    for (let j = i + 1; j < F.length; ++j) {\n      if (F.charAt(i) === F.charAt(j)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"duplicate RegExp flag\");\n      }\n    }\n  }\n\n  // 6. If F contains \"u\", let BMP be false; else let BMP be true.\n  let BMP = F.indexOf(\"u\") >= 0 ? false : true;\n\n  // 7. If BMP is true, then\n  if (BMP) {\n    // a. Parse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP\n    //    code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is\n    //    Pattern. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P\n    //    were not matched by the parse, or if any Early Error conditions exist.\n    // b. Let patternCharacters be a List whose elements are the code unit elements of P.\n  } else { // 8. Else,\n    // a. Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points\n    //    (6.1.4). The goal symbol for the parse is Pattern[U]. Throw a SyntaxError exception if P did not\n    //    conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error\n    //    conditions exist.\n    // b. Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16\n    //    decoding to P's sequence of elements.\n\n  }\n\n  // 9. Set the value of obj's [[OriginalSource]] internal slot to P.\n  obj.$OriginalSource = P;\n\n  // 10. Set the value of obj's [[OriginalFlags]] internal slot to F.\n  obj.$OriginalFlags = F;\n\n  // 11. Set obj's [[RegExpMatcher]] internal slot to the internal procedure that evaluates the above parse of\n  //     P by applying the semantics provided in 21.2.2 using patternCharacters as the pattern's List of\n  //     SourceCharacter values and F as the flag parameters.\n  try {\n    let computedFlags = \"y\";\n    if (F.indexOf(\"i\") >= 0) computedFlags += \"i\";\n    if (F.indexOf(\"u\") >= 0) computedFlags += \"u\";\n    if (F.indexOf(\"m\") >= 0) computedFlags += \"m\";\n    let matcher = new RegExp(P, (computedFlags: any));\n\n    obj.$RegExpMatcher = (S: string, lastIndex: number) => {\n      matcher.lastIndex = lastIndex;\n      let match = matcher.exec(S);\n      if (!match) {\n        return null;\n      }\n      return {\n        endIndex: match.index + match[0].length,\n        captures: match\n      };\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"invalid RegExp\");\n    } else\n      throw e;\n  }\n\n  // 12. Perform ? Set(obj, \"lastIndex\", 0, true).\n  Set(realm, obj, \"lastIndex\", realm.intrinsics.zero, true);\n\n  // 13. Return obj.\n  return obj;\n}\n\n// ECMA262 21.2.5.2.1\nexport function RegExpExec(realm: Realm, R: ObjectValue, S: string): ObjectValue | NullValue {\n  // 1. Assert: Type(R) is Object.\n  invariant(R instanceof ObjectValue, \"Type(R) is Object\");\n\n  // 2. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 3. Let exec be ? Get(R, \"exec\").\n  let exec = Get(realm, R, \"exec\");\n\n  // 4. If IsCallable(exec) is true, then\n  if (IsCallable(realm, exec)) {\n    // a. Let result be ? Call(exec, R, « S »).\n    let result = Call(realm, exec, R, [new StringValue(realm, S)]);\n\n    // b. If Type(result) is neither Object or Null, throw a TypeError exception.\n    if (!HasSomeCompatibleType(realm, result, ObjectValue, NullValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(result) is neither Object or Null\");\n    }\n\n    // c. Return result.\n    return ((result.throwIfNotConcrete(): any): ObjectValue | NullValue);\n  }\n\n  // 5. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.\n  if (R.$RegExpMatcher === undefined) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"R does not have a [[RegExpMatcher]] internal slot\");\n  }\n\n  // 6. Return ? RegExpBuiltinExec(R, S).\n  return RegExpBuiltinExec(realm, R, S);\n}\n\n// ECMA262 21.2.5.2.2\nexport function RegExpBuiltinExec(realm: Realm, R: ObjectValue, S: string): ObjectValue | NullValue {\n  // 1. Assert: R is an initialized RegExp instance.\n  invariant(R.$RegExpMatcher !== undefined && R.$OriginalSource !== undefined && R.$OriginalFlags !== undefined, \"R is an initialized RegExp instance\");\n\n  // 2. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 3. Let length be the number of code units in S.\n  let length = S.length;\n\n  // 4. Let lastIndex be ? ToLength(? Get(R, \"lastIndex\")).\n  let lastIndex = ToLength(realm, Get(realm, R, \"lastIndex\"));\n\n  // 5. Let flags be R.[[OriginalFlags]].\n  let flags = R.$OriginalFlags;\n  invariant(typeof flags === \"string\");\n\n  // 6 .If flags contains \"g\", let global be true, else let global be false.\n  let global = flags.indexOf(\"g\") >= 0 ? true : false;\n\n  // 7. If flags contains \"y\", let sticky be true, else let sticky be false.\n  let sticky = flags.indexOf(\"y\") >= 0 ? true : false;\n\n  // 8. If global is false and sticky is false, let lastIndex be 0.\n  if (global === false && sticky === false) lastIndex = 0;\n\n  // 9. Let matcher be the value of R's [[RegExpMatcher]] internal slot.\n  let matcher = R.$RegExpMatcher;\n  invariant(matcher !== undefined);\n\n  // 10. If flags contains \"u\", let fullUnicode be true, else let fullUnicode be false.\n  let fullUnicode = flags.indexOf(\"u\") >= 0 ? true : false;\n\n  // 11. Let matchSucceeded be false.\n  let matchSucceeded = false;\n\n  let r = null;\n  // 12. Repeat, while matchSucceeded is false\n  while (!matchSucceeded) {\n    // a. If lastIndex > length, then\n    if (lastIndex > length) {\n      // i. Perform ? Set(R, \"lastIndex\", 0, true).\n      Set(realm, R, \"lastIndex\", realm.intrinsics.zero, true);\n      // ii. Return null.\n      return realm.intrinsics.null;\n    }\n\n    // b. Let r be matcher(S, lastIndex).\n    r = matcher(S, lastIndex);\n\n    // c. If r is failure, then\n    if (r == null) {\n      // i. If sticky is true, then\n      if (sticky) {\n        // 1. Perform ? Set(R, \"lastIndex\", 0, true).\n        Set(realm, R, \"lastIndex\", realm.intrinsics.zero, true);\n\n        // 2. Return null.\n        return realm.intrinsics.null;\n      }\n      // ii. Let lastIndex be AdvanceStringIndex(S, lastIndex, fullUnicode).\n      lastIndex = AdvanceStringIndex(realm, S, lastIndex, fullUnicode);\n    } else { // d. Else,\n      // i. Assert: r is a State.\n      invariant(r, \"r is a State\");\n\n      // ii. Set matchSucceeded to true.\n      matchSucceeded = true;\n\n      // (not in standard) Let lastIndex be the index of the captures\n      lastIndex = (r.captures: any).index;\n    }\n  }\n  invariant(r != null);\n\n  // 13. Let e be r's endIndex value.\n  let e = r.endIndex;\n\n  // 14. If fullUnicode is true, then\n  if (fullUnicode) {\n    // TODO a. e is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the smallest index into S that corresponds to the character at element e of Input. If e is greater than or equal to the length of Input, then eUTF is the number of code units in S.\n    // TODO b. Let e be eUTF.\n  }\n\n  // 15. If global is true or sticky is true, then\n  if (global === true || sticky === true) {\n    // a. Perform ? Set(R, \"lastIndex\", e, true).\n    Set(realm, R, \"lastIndex\", new NumberValue(realm, e), true);\n  }\n\n  // 16. Let n be the length of r's captures List. (This is the same value as 21.2.2.1's NcapturingParens.)\n  let n = r.captures.length - 1;\n\n  // 17. Let A be ArrayCreate(n + 1).\n  let A = ArrayCreate(realm, n + 1);\n\n  // 18. Assert: The value of A's \"length\" property is n + 1.\n  let lengthOfA = Get(realm, A, \"length\").throwIfNotConcrete();\n  invariant(lengthOfA instanceof NumberValue);\n  invariant(lengthOfA.value === n + 1, \"The value of A's \\\"length\\\" property is n + 1\");\n\n  // 19. Let matchIndex be lastIndex.\n  let matchIndex = lastIndex;\n\n  // 20. Perform ! CreateDataProperty(A, \"index\", matchIndex).\n  CreateDataProperty(realm, A, \"index\", new NumberValue(realm, matchIndex));\n\n  // 21. Perform ! CreateDataProperty(A, \"input\", S).\n  CreateDataProperty(realm, A, \"input\", new StringValue(realm, S));\n\n  // 22. Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and offset e exclusive).\n  let matchedSubstr = S.substr(lastIndex, e - lastIndex);\n\n  // 23. Perform ! CreateDataProperty(A, \"0\", matchedSubstr).\n  CreateDataProperty(realm, A, \"0\", new StringValue(realm, matchedSubstr));\n\n  // 24. For each integer i such that i > 0 and i ≤ n\n  for (let i = 1; i <= n; ++i) {\n    // a. Let captureI be ith element of r's captures List.\n    let captureI = r.captures[i];\n\n    let capturedValue;\n    // b. If captureI is undefined, let capturedValue be undefined.\n    if (captureI === undefined) {\n      capturedValue = realm.intrinsics.undefined;\n    } else if (fullUnicode) { // c. Else if fullUnicode is true, then\n      // TODO: i. Assert: captureI is a List of code points.\n      // TODO: ii. Let capturedValue be a string whose code units are the UTF16Encoding of the code points of captureI.\n      capturedValue = realm.intrinsics.undefined;\n    } else { // d. Else, fullUnicode is false,\n      // i. Assert: captureI is a List of code units.\n      invariant(typeof captureI === \"string\");\n\n      // ii. Let capturedValue be a string consisting of the code units of captureI.\n      capturedValue = new StringValue(realm, captureI);\n    }\n\n    // e. Perform ! CreateDataProperty(A, ! ToString(i), capturedValue).\n    CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, i)), capturedValue);\n  }\n\n  // 25. Return A.\n  return A;\n}\n\nexport function AdvanceStringIndex(realm: Realm, S: string, index: number, unicode: boolean): number {\n  // 1. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 2. Assert: index is an integer such that 0≤index≤253-1.\n  invariant(index >= 0 && index <= Math.pow(2, 53) - 1, \"index is an integer such that 0≤index≤253-1\");\n\n  // 3. Assert: Type(unicode) is Boolean.\n  invariant(typeof unicode === \"boolean\", \"Type(unicode) is Boolean\");\n\n  // 4. If unicode is false, return index+1.\n  if (unicode === false) return index + 1;\n\n  // 5. Let length be the number of code units in S.\n  let length = S.length;\n\n  // 6. If index+1 ≥ length, return index+1.\n  if (index + 1 >= length) return index + 1;\n\n  // 7. Let first be the code unit value at index index in S.\n  let first = S.charCodeAt(index);\n\n  // 8. If first < 0xD800 or first > 0xDBFF, return index+1.\n  if (first < 0xD800 || first > 0xDBFF) return index + 1;\n\n  // 9. Let second be the code unit value at index index+1 in S.\n  let second = S.charCodeAt(index + 1);\n\n  // 10. If second < 0xDC00 or second > 0xDFFF, return index+1.\n  if (second < 0xDC00 || second > 0xDFFF) return index + 1;\n\n  // 11. Return index+2.\n  return index + 2;\n}\n\nexport function EscapeRegExpPattern(realm: Realm, P: string, F: string): string {\n  return P.replace(\"/\", \"\\/\");\n}\n"]}