"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsSuperReference = IsSuperReference;
exports.HasPrimitiveBase = HasPrimitiveBase;
exports.GetReferencedName = GetReferencedName;
exports.GetReferencedNamePartial = GetReferencedNamePartial;
exports.GetValue = GetValue;
exports.IsStrictReference = IsStrictReference;
exports.IsPropertyReference = IsPropertyReference;
exports.GetBase = GetBase;
exports.IsUnresolvableReference = IsUnresolvableReference;
exports.NewDeclarativeEnvironment = NewDeclarativeEnvironment;
exports.BoundNames = BoundNames;
exports.ContainsExpression = ContainsExpression;
exports.ResolveBinding = ResolveBinding;
exports.GetIdentifierReference = GetIdentifierReference;
exports.InitializeReferencedBinding = InitializeReferencedBinding;
exports.BlockDeclarationInstantiation = BlockDeclarationInstantiation;
exports.NewGlobalEnvironment = NewGlobalEnvironment;
exports.NewObjectEnvironment = NewObjectEnvironment;
exports.NewFunctionEnvironment = NewFunctionEnvironment;
exports.GetActiveScriptOrModule = GetActiveScriptOrModule;
exports.GetThisEnvironment = GetThisEnvironment;
exports.ResolveThisBinding = ResolveThisBinding;
exports.BindingInitialization = BindingInitialization;
exports.InitializeBoundName = InitializeBoundName;
exports.IsDestructuring = IsDestructuring;
exports.KeyedBindingInitialization = KeyedBindingInitialization;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _index = require("../values/index.js");

var _environment = require("../environment.js");

var _index2 = require("./index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// ECMA262 6.2.3
// IsSuperReference(V). Returns true if this reference has a thisValue component.
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function IsSuperReference(realm, V) {
  return V.thisValue !== undefined;
}

// ECMA262 6.2.3
// HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.
function HasPrimitiveBase(realm, V) {
  var base = GetBase(realm, V);
  return base instanceof _index.Value && (0, _index2.HasSomeCompatibleType)(realm, base, _index.BooleanValue, _index.StringValue, _index.SymbolValue, _index.NumberValue);
}

// ECMA262 6.2.3
// GetReferencedName(V). Returns the referenced name component of the reference V.
function GetReferencedName(realm, V) {
  if (V.referencedName instanceof _index.AbstractValue) throw realm.createIntrospectionErrorThrowCompletion("abstract reference");
  return V.referencedName;
}

function GetReferencedNamePartial(realm, V) {
  return V.referencedName;
}

// ECMA262 6.2.3.1
function GetValue(realm, V) {
  // This step is not necessary as we propagate completions with exceptions.
  // 1. ReturnIfAbrupt(V).

  // 2. If Type(V) is not Reference, return V.
  if (!(V instanceof _environment.Reference)) return V;

  // 3. Let base be GetBase(V).
  var base = GetBase(realm, V);

  // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.
  if (IsUnresolvableReference(realm, V)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, V.referencedName.toString() + " is not defined");
  }

  // 5. If IsPropertyReference(V) is true, then
  if (IsPropertyReference(realm, V)) {
    // a. If HasPrimitiveBase(V) is true, then
    if (HasPrimitiveBase(realm, V)) {
      // i. Assert: In this case, base will never be null or undefined.
      (0, _invariant2.default)(base instanceof _index.Value && !(0, _index2.HasSomeCompatibleType)(realm, base, _index.UndefinedValue, _index.NullValue));

      // ii. Let base be ToObject(base).
      base = (0, _index2.ToObjectPartial)(realm, base);
    }
    (0, _invariant2.default)(base instanceof _index.ObjectValue || base instanceof _index.AbstractObjectValue);

    // b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).
    return base.$GetPartial(GetReferencedNamePartial(realm, V), (0, _index2.GetThisValue)(realm, V));
  }

  // 6. Else base must be an Environment Record,
  if (base instanceof _environment.EnvironmentRecord) {
    // a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).
    var referencedName = GetReferencedName(realm, V);
    (0, _invariant2.default)(typeof referencedName === "string");
    return base.GetBindingValue(referencedName, IsStrictReference(realm, V));
  }

  throw new Error("unknown reference type");
}

// ECMA262 6.2.3
// IsStrictReference(V). Returns the strict reference flag component of the reference V.
function IsStrictReference(realm, V) {
  return V.strict;
}

// ECMA262 6.2.3
// IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.
function IsPropertyReference(realm, V) {
  return V.base instanceof _index.ObjectValue || V.base instanceof _index.AbstractObjectValue || V.base instanceof _index.AbstractObjectValue || HasPrimitiveBase(realm, V);
}

// ECMA262 6.2.3
// GetBase(V). Returns the base value component of the reference V.
function GetBase(realm, V) {
  return V.base;
}

// ECMA262 6.2.3
// IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.
function IsUnresolvableReference(realm, V) {
  return !V.base;
}

// ECMA262 8.1.2.2
function NewDeclarativeEnvironment(realm, E) {
  // 1. Let env be a new Lexical Environment.
  var env = new _environment.LexicalEnvironment(realm);

  // 2. Let envRec be a new declarative Environment Record containing no bindings.
  var envRec = new _environment.DeclarativeEnvironmentRecord(realm);

  // 3. Set env's EnvironmentRecord to envRec.
  env.environmentRecord = envRec;

  // 4. Set the outer lexical environment reference of env to E.
  env.parent = E;

  // 5. Return env.
  return env;
}

function BoundNames(realm, node) {
  return Object.keys(t.getOuterBindingIdentifiers(node));
}

// ECMA262 13.3.3.2
function ContainsExpression(realm, node) {
  switch (node.type) {
    case "ObjectPattern":
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var prop = _step.value;

          if (ContainsExpression(realm, prop)) return true;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    case "ArrayPattern":
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = node.elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var elem = _step2.value;

          if (ContainsExpression(realm, elem)) return true;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return false;
    case "RestElement":
      return ContainsExpression(realm, node.argument);
    case "AssignmentPattern":
      return true;
    default:
      return false;
  }
}

// ECMA262 8.3.2
function ResolveBinding(realm, name, strict, env) {
  // 1. If env was not passed or if env is undefined, then
  if (!env) {
    // a. Let env be the running execution context's LexicalEnvironment.
    env = realm.getRunningContext().lexicalEnvironment;
  }

  // 2. Assert: env is a Lexical Environment.
  (0, _invariant2.default)(env instanceof _environment.LexicalEnvironment, "expected lexical environment");

  // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.

  // 4. Return ? GetIdentifierReference(env, name, strict).
  return GetIdentifierReference(realm, env, name, strict);
}

// ECMA262 8.1.2.1
function GetIdentifierReference(realm, lex, name, strict) {
  // 1. If lex is the value null, then
  if (!lex) {
    // a. Return a value of type Reference whose base value is undefined, whose referenced name is name, and whose strict reference flag is strict.
    return new _environment.Reference(undefined, name, strict);
  }

  // 2. Let envRec be lex's EnvironmentRecord.
  var envRec = lex.environmentRecord;

  // 3. Let exists be ? envRec.HasBinding(name).
  var exists = envRec.HasBinding(name);

  // 4. If exists is true, then
  if (exists) {
    // a. Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict reference flag is strict.
    return new _environment.Reference(envRec, name, strict);
  } else {
    // 5. Else,
    // a. Let outer be the value of lex's outer environment reference.
    var outer = lex.parent;

    // b. Return ? GetIdentifierReference(outer, name, strict).
    return GetIdentifierReference(realm, outer, name, strict);
  }
}

// ECMA262 6.2.3.4
function InitializeReferencedBinding(realm, V, W) {
  // 1. ReturnIfAbrupt(V).
  // 2. ReturnIfAbrupt(W).

  // 3. Assert: Type(V) is Reference.
  (0, _invariant2.default)(V instanceof _environment.Reference, "expected reference");

  // 4. Assert: IsUnresolvableReference(V) is false.
  (0, _invariant2.default)(!IsUnresolvableReference(realm, V), "expected resolvable reference");

  // 5. Let base be GetBase(V).
  var base = GetBase(realm, V);

  // 6. Assert: base is an Environment Record.
  (0, _invariant2.default)(base instanceof _environment.EnvironmentRecord, "expected environment record");

  // 7. Return base.InitializeBinding(GetReferencedName(V), W).
  var referencedName = GetReferencedName(realm, V);
  (0, _invariant2.default)(typeof referencedName === "string");
  return base.InitializeBinding(referencedName, W);
}

// ECMA262 13.2.14
function BlockDeclarationInstantiation(realm, strictCode, body, env) {
  // 1. Let envRec be env's EnvironmentRecord.
  var envRec = env.environmentRecord;

  // 2. Assert: envRec is a declarative Environment Record.
  (0, _invariant2.default)(envRec instanceof _environment.DeclarativeEnvironmentRecord, "expected declarative environment record");

  // 3. Let declarations be the LexicallyScopedDeclarations of code.
  var declarations = [];
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = body[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var node = _step3.value;

      if (node.type === "FunctionDeclaration" || node.type === "VariableDeclaration" && node.kind !== "var") {
        declarations.push(node);
      }
    }

    // 4. For each element d in declarations do
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = declarations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var d = _step4.value;

      // a. For each element dn of the BoundNames of d do
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = BoundNames(realm, d)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var dn = _step5.value;

          if (envRec.HasBinding(dn)) {
            //ECMA262 13.2.1
            throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, dn + " already declared");
          }
          // i. If IsConstantDeclaration of d is true, then
          if (d.type === "VariableDeclaration" && d.kind === "const") {
            // 1. Perform ! envRec.CreateImmutableBinding(dn, true).
            envRec.CreateImmutableBinding(dn, true);
          } else {
            // ii. Else,
            // 1. Perform ! envRec.CreateMutableBinding(dn, false).
            envRec.CreateMutableBinding(dn, false);
          }
        }

        // b. If d is a GeneratorDeclaration production or a FunctionDeclaration production, then
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      if (d.type === "FunctionDeclaration") {
        // i. Let fn be the sole element of the BoundNames of d.
        var fn = BoundNames(realm, d)[0];

        // ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.
        var fo = env.evaluate(d, strictCode);
        (0, _invariant2.default)(fo instanceof _index.Value);

        // iii. Perform envRec.InitializeBinding(fn, fo).
        envRec.InitializeBinding(fn, fo);
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }
}

// ECMA262 8.1.2.5
function NewGlobalEnvironment(realm, G, thisValue) {
  // 1. Let env be a new Lexical Environment.
  var env = new _environment.LexicalEnvironment(realm);

  // 2. Let objRec be a new object Environment Record containing G as the binding object.
  var objRec = new _environment.ObjectEnvironmentRecord(realm, G);

  // 3. Let dclRec be a new declarative Environment Record containing no bindings.
  var dclRec = new _environment.DeclarativeEnvironmentRecord(realm);

  // 4. Let globalRec be a new global Environment Record.
  var globalRec = new _environment.GlobalEnvironmentRecord(realm);

  // 5. Set globalRec.[[ObjectRecord]] to objRec.
  globalRec.$ObjectRecord = objRec;

  // 6. Set globalRec.[[GlobalThisValue]] to thisValue.
  globalRec.$GlobalThisValue = thisValue;

  // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.
  globalRec.$DeclarativeRecord = dclRec;

  // 8. Set globalRec.[[VarNames]] to a new empty List.
  globalRec.$VarNames = [];

  // 9. Set env's EnvironmentRecord to globalRec.
  env.environmentRecord = globalRec;

  // 10. Set the outer lexical environment reference of env to null.
  env.parent = null;

  // 11. Return env.
  return env;
}

// ECMA262 8.1.2.3
function NewObjectEnvironment(realm, O, E) {
  // 1. Let env be a new Lexical Environment.
  var env = new _environment.LexicalEnvironment(realm);

  // 2. Let envRec be a new object Environment Record containing O as the binding object.
  var envRec = new _environment.ObjectEnvironmentRecord(realm, O);

  // 3. Set env's EnvironmentRecord to envRec.
  env.environmentRecord = envRec;

  // 4. Set the outer lexical environment reference of env to E.
  env.parent = E;

  // 5. Return env.
  return env;
}

// ECMA262 8.1.2.4
function NewFunctionEnvironment(realm, F, newTarget) {
  // 1. Assert: F is an ECMAScript function.
  (0, _invariant2.default)(F instanceof _index.FunctionValue, "expected a function");

  // 2. Assert: Type(newTarget) is Undefined or Object.
  (0, _invariant2.default)(newTarget === undefined || newTarget instanceof _index.ObjectValue, "expected undefined or object value for new target");

  // 3. Let env be a new Lexical Environment.
  var env = new _environment.LexicalEnvironment(realm);

  // 4. Let envRec be a new function Environment Record containing no bindings.
  var envRec = new _environment.FunctionEnvironmentRecord(realm);

  // 5. Set envRec.[[FunctionObject]] to F.
  envRec.$FunctionObject = F;

  // 6. If F's [[ThisMode]] internal slot is lexical, set envRec.[[ThisBindingStatus]] to "lexical".
  if (F.$ThisMode === "lexical") {
    envRec.$ThisBindingStatus = "lexical";
  } else {
    // 7. Else, set envRec.[[ThisBindingStatus]] to "uninitialized".
    envRec.$ThisBindingStatus = "uninitialized";
  }

  // 8. Let home be the value of F's [[HomeObject]] internal slot.
  var home = F.$HomeObject;

  // 9. Set envRec.[[HomeObject]] to home.
  envRec.$HomeObject = home;

  // 10. Set envRec.[[NewTarget]] to newTarget.
  envRec.$NewTarget = newTarget;

  // 11. Set env's EnvironmentRecord to envRec.
  env.environmentRecord = envRec;

  // 12. Set the outer lexical environment reference of env to the value of F's [[Environment]] internal slot.
  env.parent = F.$Environment;

  // 13. Return env.
  return env;
}

// ECMA262 8.3.1
function GetActiveScriptOrModule(realm) {
  // The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the active function object.
  // GetActiveScriptOrModule performs the following steps:
  //
  // If the execution context stack is empty, return null.
  if (realm.contextStack.length === 0) return null;
  // Let ec be the topmost execution context on the execution context stack whose Function component's [[ScriptOrModule]] component is not null.
  // If such an execution context exists, return ec's Function component's [[ScriptOrModule]] slot's value.
  var ec = void 0;
  for (var i = realm.contextStack.length - 1; i >= 0; i--) {
    ec = realm.contextStack[i];
    var F = ec.function;
    if (F == null) continue;
    if (F.$ScriptOrModule instanceof Object) {
      return F.$ScriptOrModule;
    }
  }
  // Otherwise, let ec be the running execution context.
  ec = realm.getRunningContext();
  // Assert: ec's ScriptOrModule component is not null.
  (0, _invariant2.default)(ec.ScriptOrModule !== null);
  // Return ec's ScriptOrModule component.
  return ec.ScriptOrModule;
}

// ECMA262 8.3.3
function GetThisEnvironment(realm) {
  // 1. Let lex be the running execution context's LexicalEnvironment.
  var lex = realm.getRunningContext().lexicalEnvironment;

  // 2. Repeat
  while (true) {
    // a. Let envRec be lex's EnvironmentRecord.
    var envRec = lex.environmentRecord;

    // b. Let exists be envRec.HasThisBinding().
    var exists = envRec.HasThisBinding();

    // c. If exists is true, return envRec.
    if (exists) return envRec;

    // d. Let outer be the value of lex's outer environment reference.
    var outer = lex.parent;
    (0, _invariant2.default)(outer);

    // e. Let lex be outer.
    lex = outer;
  }

  (0, _invariant2.default)(false);
}

// ECMA262 8.3.4
function ResolveThisBinding(realm) {
  // 1. Let envRec be GetThisEnvironment( ).
  var envRec = GetThisEnvironment(realm);

  // 2. Return ? envRec.GetThisBinding().
  return envRec.GetThisBinding();
}

function BindingInitialization(realm, node, value, environment) {
  if (node.type === "ArrayPattern") {
    // ECMA262 13.3.3.5
    // 1. Let iterator be ? GetIterator(value).
    // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.
    // 3. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.
    // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).
    // 5. Return result.
    throw new Error("TODO: Patterns aren't supported yet");
  } else if (node.type === "ObjectPattern") {
    // ECMA262 13.3.3.5
    // 1. Perform ? RequireObjectCoercible(value).
    (0, _index2.RequireObjectCoercible)(realm, value);

    // 2. Return the result of performing BindingInitialization for ObjectBindingPattern using value and environment as arguments.
    throw new Error("TODO: Patterns aren't supported yet");
  } else if (node.type === "Identifier") {
    // ECMA262 12.1.5
    // 1. Let name be StringValue of Identifier.
    var name = node.name;

    // 2. Return ? InitializeBoundName(name, value, environment).
    return InitializeBoundName(realm, name, value, environment);
  } else if (node.type === "VariableDeclaration") {
    // ECMA262 13.7.5.9
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
      for (var _iterator6 = node.declarations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        var decl = _step6.value;

        BindingInitialization(realm, decl.id, value, environment);
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6.return) {
          _iterator6.return();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }
  }

  throw new Error("Unknown node " + node.type);
}

// ECMA262 12.1.5.1
function InitializeBoundName(realm, name, value, environment) {
  // 1. Assert: Type(name) is String.
  (0, _invariant2.default)(typeof name === "string", "expected name to be a string");

  // 2. If environment is not undefined, then
  if (environment) {
    // a. Let env be the EnvironmentRecord component of environment.
    var env = environment.environmentRecord;

    // b. Perform env.InitializeBinding(name, value).
    env.InitializeBinding(name, value);

    // c. Return NormalCompletion(undefined).
    return realm.intrinsics.undefined;
  } else {
    // 3. Else,
    // a. Let lhs be ResolveBinding(name).
    // Note that the undefined environment implies non-strict.
    var lhs = ResolveBinding(realm, name, false);

    // b. Return ? PutValue(lhs, value).
    return (0, _index2.PutValue)(realm, lhs, value);
  }
}

// ECMA262 12.3.1.3 and 13.7.5.6
function IsDestructuring(ast) {
  switch (ast.type) {
    case "VariableDeclaration":
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = ast.declarations[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var decl = _step7.value;

          switch (decl.type) {
            case "VariableDeclarator":
              switch (decl.id.type) {
                case "ArrayPattern":
                case "AssignmentPattern":
                case "ObjectPattern":
                  return true;
                default:
                  break;
              }
              break;
            default:
              break;
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      return false;
    case "ArrayLiteral":
    case "ObjectLiteral":
      return true;
    default:
      return false;
  }
}

// ECMA262 13.3.3.7
function KeyedBindingInitialization(realm, value, environment, propertyName) {
  // 1. Let bindingId be StringValue of BindingIdentifier.
  var bindingId = propertyName;

  // if environment is undefined, the calling context is not strict
  var strict = environment !== undefined;

  // 2. Let lhs be ? ResolveBinding(bindingId, environment).
  var lhs = ResolveBinding(realm, bindingId, strict, environment);

  // 3. Let v be ? GetV(value, propertyName).
  var v = (0, _index2.GetV)(realm, value, propertyName);

  // 4. If Initializer is present and v is undefined, then
  if (false) {}
  // a. Let defaultValue be the result of evaluating Initializer.
  // b. Let v be ? GetValue(defaultValue).
  // c. If IsAnonymousFunctionDefinition(Initializer) is true, then
  // i. Let hasNameProperty be ? HasOwnProperty(v, "name").
  // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).


  // 5. If environment is undefined, return ? PutValue(lhs, v).
  if (!environment) return (0, _index2.PutValue)(realm, lhs, v);

  console.log(lhs, v);

  // 6. Return InitializeReferencedBinding(lhs, v).
  return InitializeReferencedBinding(realm, lhs, v);
}
//# sourceMappingURL=environment.js.map