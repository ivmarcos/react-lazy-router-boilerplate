{"version":3,"sources":["../../src/methods/environment.js"],"names":["IsSuperReference","HasPrimitiveBase","GetReferencedName","GetReferencedNamePartial","GetValue","IsStrictReference","IsPropertyReference","GetBase","IsUnresolvableReference","NewDeclarativeEnvironment","BoundNames","ContainsExpression","ResolveBinding","GetIdentifierReference","InitializeReferencedBinding","BlockDeclarationInstantiation","NewGlobalEnvironment","NewObjectEnvironment","NewFunctionEnvironment","GetActiveScriptOrModule","GetThisEnvironment","ResolveThisBinding","BindingInitialization","InitializeBoundName","IsDestructuring","KeyedBindingInitialization","t","realm","V","thisValue","undefined","base","referencedName","createIntrospectionErrorThrowCompletion","createErrorThrowCompletion","intrinsics","ReferenceError","toString","$GetPartial","GetBindingValue","Error","strict","E","env","envRec","environmentRecord","parent","node","Object","keys","getOuterBindingIdentifiers","type","properties","prop","elements","elem","argument","name","getRunningContext","lexicalEnvironment","lex","exists","HasBinding","outer","W","InitializeBinding","strictCode","body","declarations","kind","push","d","dn","SyntaxError","CreateImmutableBinding","CreateMutableBinding","fn","fo","evaluate","G","objRec","dclRec","globalRec","$ObjectRecord","$GlobalThisValue","$DeclarativeRecord","$VarNames","O","F","newTarget","$FunctionObject","$ThisMode","$ThisBindingStatus","home","$HomeObject","$NewTarget","$Environment","contextStack","length","ec","i","function","$ScriptOrModule","ScriptOrModule","HasThisBinding","GetThisBinding","value","environment","decl","id","lhs","ast","propertyName","bindingId","v","console","log"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport {\n  AbstractValue,\n  UndefinedValue,\n  NullValue,\n  NumberValue,\n  BooleanValue,\n  SymbolValue,\n  FunctionValue,\n  ObjectValue,\n  StringValue,\n  Value,\n  AbstractObjectValue,\n} from \"../values/index.js\";\nimport {\n  ObjectEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  EnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  GlobalEnvironmentRecord,\n  Reference,\n  LexicalEnvironment\n} from \"../environment.js\";\nimport {\n  GetV,\n  GetThisValue,\n  ToObjectPartial,\n  PutValue,\n  RequireObjectCoercible,\n  HasSomeCompatibleType\n} from \"./index.js\";\nimport type { BabelNode, BabelNodeVariableDeclaration, BabelNodeIdentifier, BabelNodeRestElement, BabelNodeObjectPattern, BabelNodeArrayPattern, BabelNodeStatement } from \"babel-types\";\n\n\n// ECMA262 6.2.3\n// IsSuperReference(V). Returns true if this reference has a thisValue component.\nexport function IsSuperReference(realm: Realm, V: Reference): boolean {\n  return V.thisValue !== undefined;\n}\n\n// ECMA262 6.2.3\n// HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.\nexport function HasPrimitiveBase(realm: Realm, V: Reference): boolean {\n  let base = GetBase(realm, V);\n  return base instanceof Value && HasSomeCompatibleType(realm, base, BooleanValue, StringValue, SymbolValue, NumberValue);\n}\n\n// ECMA262 6.2.3\n// GetReferencedName(V). Returns the referenced name component of the reference V.\nexport function GetReferencedName(realm: Realm, V: Reference): string | SymbolValue {\n  if (V.referencedName instanceof AbstractValue)\n    throw realm.createIntrospectionErrorThrowCompletion(\"abstract reference\");\n  return V.referencedName;\n}\n\nexport function GetReferencedNamePartial(realm: Realm, V: Reference): AbstractValue | string | SymbolValue {\n  return V.referencedName;\n}\n\n// ECMA262 6.2.3.1\nexport function GetValue(realm: Realm, V: Reference | Value): Value {\n  // This step is not necessary as we propagate completions with exceptions.\n  // 1. ReturnIfAbrupt(V).\n\n  // 2. If Type(V) is not Reference, return V.\n  if (!(V instanceof Reference)) return V;\n\n  // 3. Let base be GetBase(V).\n  let base = GetBase(realm, V);\n\n  // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.\n  if (IsUnresolvableReference(realm, V)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${V.referencedName.toString()} is not defined`);\n  }\n\n  // 5. If IsPropertyReference(V) is true, then\n  if (IsPropertyReference(realm, V)) {\n    // a. If HasPrimitiveBase(V) is true, then\n    if (HasPrimitiveBase(realm, V)) {\n      // i. Assert: In this case, base will never be null or undefined.\n      invariant(base instanceof Value && !HasSomeCompatibleType(realm, base, UndefinedValue, NullValue));\n\n      // ii. Let base be ToObject(base).\n      base = ToObjectPartial(realm, base);\n    }\n    invariant(base instanceof ObjectValue || base instanceof AbstractObjectValue);\n\n    // b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).\n    return base.$GetPartial(GetReferencedNamePartial(realm, V), GetThisValue(realm, V));\n  }\n\n  // 6. Else base must be an Environment Record,\n  if (base instanceof EnvironmentRecord) {\n    // a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).\n    let referencedName = GetReferencedName(realm, V);\n    invariant(typeof referencedName === \"string\");\n    return base.GetBindingValue(referencedName, IsStrictReference(realm, V));\n  }\n\n  throw new Error(\"unknown reference type\");\n}\n\n// ECMA262 6.2.3\n// IsStrictReference(V). Returns the strict reference flag component of the reference V.\nexport function IsStrictReference(realm: Realm, V: Reference): boolean {\n  return V.strict;\n}\n\n// ECMA262 6.2.3\n// IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.\nexport function IsPropertyReference(realm: Realm, V: Reference): boolean {\n  return V.base instanceof ObjectValue || V.base instanceof AbstractObjectValue ||\n    V.base instanceof AbstractObjectValue || HasPrimitiveBase(realm, V);\n}\n\n// ECMA262 6.2.3\n// GetBase(V). Returns the base value component of the reference V.\nexport function GetBase(realm: Realm, V: Reference): void | Value | EnvironmentRecord {\n  return V.base;\n}\n\n// ECMA262 6.2.3\n// IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.\nexport function IsUnresolvableReference(realm: Realm, V: Reference): boolean {\n  return !V.base;\n}\n\n// ECMA262 8.1.2.2\nexport function NewDeclarativeEnvironment(realm: Realm, E: LexicalEnvironment): LexicalEnvironment {\n  // 1. Let env be a new Lexical Environment.\n  let env = new LexicalEnvironment(realm);\n\n  // 2. Let envRec be a new declarative Environment Record containing no bindings.\n  let envRec = new DeclarativeEnvironmentRecord(realm);\n\n  // 3. Set env's EnvironmentRecord to envRec.\n  env.environmentRecord = envRec;\n\n  // 4. Set the outer lexical environment reference of env to E.\n  env.parent = E;\n\n  // 5. Return env.\n  return env;\n}\n\nexport function BoundNames(realm: Realm, node: BabelNode): Array<string> {\n  return Object.keys(t.getOuterBindingIdentifiers(node));\n}\n\n// ECMA262 13.3.3.2\nexport function ContainsExpression(realm: Realm, node: BabelNode): boolean {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      for (let prop of ((node: any): BabelNodeObjectPattern).properties) {\n        if (ContainsExpression(realm, prop)) return true;\n      }\n      return false;\n    case \"ArrayPattern\":\n      for (let elem of ((node: any): BabelNodeArrayPattern).elements) {\n        if (ContainsExpression(realm, elem)) return true;\n      }\n      return false;\n    case \"RestElement\":\n      return ContainsExpression(realm, ((node: any): BabelNodeRestElement).argument);\n    case \"AssignmentPattern\":\n      return true;\n    default:\n     return false;\n  }\n}\n\n// ECMA262 8.3.2\nexport function ResolveBinding(realm: Realm, name: string, strict: boolean, env?: ?LexicalEnvironment): Reference {\n  // 1. If env was not passed or if env is undefined, then\n  if (!env) {\n    // a. Let env be the running execution context's LexicalEnvironment.\n    env = realm.getRunningContext().lexicalEnvironment;\n  }\n\n  // 2. Assert: env is a Lexical Environment.\n  invariant(env instanceof LexicalEnvironment, \"expected lexical environment\");\n\n  // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.\n\n  // 4. Return ? GetIdentifierReference(env, name, strict).\n  return GetIdentifierReference(realm, env, name, strict);\n}\n\n// ECMA262 8.1.2.1\nexport function GetIdentifierReference(realm: Realm, lex: ?LexicalEnvironment, name: string, strict: boolean): Reference {\n  // 1. If lex is the value null, then\n  if (!lex) {\n    // a. Return a value of type Reference whose base value is undefined, whose referenced name is name, and whose strict reference flag is strict.\n    return new Reference(undefined, name, strict);\n  }\n\n  // 2. Let envRec be lex's EnvironmentRecord.\n  let envRec = lex.environmentRecord;\n\n  // 3. Let exists be ? envRec.HasBinding(name).\n  let exists = envRec.HasBinding(name);\n\n  // 4. If exists is true, then\n  if (exists) {\n    // a. Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict reference flag is strict.\n    return new Reference(envRec, name, strict);\n  } else { // 5. Else,\n    // a. Let outer be the value of lex's outer environment reference.\n    let outer = lex.parent;\n\n    // b. Return ? GetIdentifierReference(outer, name, strict).\n    return GetIdentifierReference(realm, outer, name, strict);\n  }\n}\n\n// ECMA262 6.2.3.4\nexport function InitializeReferencedBinding(realm: Realm, V: Reference, W: Value): Value {\n  // 1. ReturnIfAbrupt(V).\n  // 2. ReturnIfAbrupt(W).\n\n  // 3. Assert: Type(V) is Reference.\n  invariant(V instanceof Reference, \"expected reference\");\n\n  // 4. Assert: IsUnresolvableReference(V) is false.\n  invariant(!IsUnresolvableReference(realm, V), \"expected resolvable reference\");\n\n  // 5. Let base be GetBase(V).\n  let base = GetBase(realm, V);\n\n  // 6. Assert: base is an Environment Record.\n  invariant(base instanceof EnvironmentRecord, \"expected environment record\");\n\n  // 7. Return base.InitializeBinding(GetReferencedName(V), W).\n  let referencedName = GetReferencedName(realm, V);\n  invariant(typeof referencedName === \"string\");\n  return base.InitializeBinding(referencedName, W);\n}\n\n// ECMA262 13.2.14\nexport function BlockDeclarationInstantiation(realm: Realm, strictCode: boolean, body: Array<BabelNodeStatement>, env: LexicalEnvironment) {\n  // 1. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a declarative Environment Record.\n  invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n\n  // 3. Let declarations be the LexicallyScopedDeclarations of code.\n  let declarations = [];\n  for (let node of body) {\n    if (node.type === \"FunctionDeclaration\" || (node.type === \"VariableDeclaration\" && node.kind !== \"var\")) {\n      declarations.push(node);\n    }\n  }\n\n  // 4. For each element d in declarations do\n  for (let d of declarations) {\n    // a. For each element dn of the BoundNames of d do\n    for (let dn of BoundNames(realm, d)) {\n      if (envRec.HasBinding(dn)) {\n        //ECMA262 13.2.1\n        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError,\n          dn + \" already declared\");\n      }\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.type === \"VariableDeclaration\" && d.kind === \"const\") {\n        // 1. Perform ! envRec.CreateImmutableBinding(dn, true).\n        envRec.CreateImmutableBinding(dn, true);\n      } else { // ii. Else,\n        // 1. Perform ! envRec.CreateMutableBinding(dn, false).\n        envRec.CreateMutableBinding(dn, false);\n      }\n    }\n\n    // b. If d is a GeneratorDeclaration production or a FunctionDeclaration production, then\n    if (d.type === \"FunctionDeclaration\") {\n      // i. Let fn be the sole element of the BoundNames of d.\n      let fn = BoundNames(realm, d)[0];\n\n      // ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.\n      let fo = env.evaluate(d, strictCode);\n      invariant(fo instanceof Value);\n\n      // iii. Perform envRec.InitializeBinding(fn, fo).\n      envRec.InitializeBinding(fn, fo);\n    }\n  }\n}\n\n// ECMA262 8.1.2.5\nexport function NewGlobalEnvironment(realm: Realm, G: ObjectValue | AbstractObjectValue, thisValue: ObjectValue | AbstractObjectValue) {\n  // 1. Let env be a new Lexical Environment.\n  let env = new LexicalEnvironment(realm);\n\n  // 2. Let objRec be a new object Environment Record containing G as the binding object.\n  let objRec = new ObjectEnvironmentRecord(realm, G);\n\n  // 3. Let dclRec be a new declarative Environment Record containing no bindings.\n  let dclRec = new DeclarativeEnvironmentRecord(realm);\n\n  // 4. Let globalRec be a new global Environment Record.\n  let globalRec = new GlobalEnvironmentRecord(realm);\n\n  // 5. Set globalRec.[[ObjectRecord]] to objRec.\n  globalRec.$ObjectRecord = objRec;\n\n  // 6. Set globalRec.[[GlobalThisValue]] to thisValue.\n  globalRec.$GlobalThisValue = thisValue;\n\n  // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.\n  globalRec.$DeclarativeRecord = dclRec;\n\n  // 8. Set globalRec.[[VarNames]] to a new empty List.\n  globalRec.$VarNames = [];\n\n  // 9. Set env's EnvironmentRecord to globalRec.\n  env.environmentRecord = globalRec;\n\n  // 10. Set the outer lexical environment reference of env to null.\n  env.parent = null;\n\n  // 11. Return env.\n  return env;\n}\n\n\n// ECMA262 8.1.2.3\nexport function NewObjectEnvironment(realm: Realm, O: ObjectValue | AbstractObjectValue, E: LexicalEnvironment): LexicalEnvironment {\n  // 1. Let env be a new Lexical Environment.\n  let env = new LexicalEnvironment(realm);\n\n  // 2. Let envRec be a new object Environment Record containing O as the binding object.\n  let envRec = new ObjectEnvironmentRecord(realm, O);\n\n  // 3. Set env's EnvironmentRecord to envRec.\n  env.environmentRecord = envRec;\n\n  // 4. Set the outer lexical environment reference of env to E.\n  env.parent = E;\n\n  // 5. Return env.\n  return env;\n}\n\n// ECMA262 8.1.2.4\nexport function NewFunctionEnvironment(realm: Realm, F: FunctionValue, newTarget?: ObjectValue): LexicalEnvironment {\n  // 1. Assert: F is an ECMAScript function.\n  invariant(F instanceof FunctionValue, \"expected a function\");\n\n  // 2. Assert: Type(newTarget) is Undefined or Object.\n  invariant(newTarget === undefined || newTarget instanceof ObjectValue, \"expected undefined or object value for new target\");\n\n  // 3. Let env be a new Lexical Environment.\n  let env = new LexicalEnvironment(realm);\n\n  // 4. Let envRec be a new function Environment Record containing no bindings.\n  let envRec = new FunctionEnvironmentRecord(realm);\n\n  // 5. Set envRec.[[FunctionObject]] to F.\n  envRec.$FunctionObject = F;\n\n  // 6. If F's [[ThisMode]] internal slot is lexical, set envRec.[[ThisBindingStatus]] to \"lexical\".\n  if (F.$ThisMode === \"lexical\") {\n    envRec.$ThisBindingStatus = \"lexical\";\n  } else { // 7. Else, set envRec.[[ThisBindingStatus]] to \"uninitialized\".\n    envRec.$ThisBindingStatus = \"uninitialized\";\n  }\n\n  // 8. Let home be the value of F's [[HomeObject]] internal slot.\n  let home = F.$HomeObject;\n\n  // 9. Set envRec.[[HomeObject]] to home.\n  envRec.$HomeObject = home;\n\n  // 10. Set envRec.[[NewTarget]] to newTarget.\n  envRec.$NewTarget = newTarget;\n\n  // 11. Set env's EnvironmentRecord to envRec.\n  env.environmentRecord = envRec;\n\n  // 12. Set the outer lexical environment reference of env to the value of F's [[Environment]] internal slot.\n  env.parent = F.$Environment;\n\n  // 13. Return env.\n  return env;\n}\n\n// ECMA262 8.3.1\nexport function GetActiveScriptOrModule(realm: Realm) {\n  // The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the active function object.\n  // GetActiveScriptOrModule performs the following steps:\n  //\n  // If the execution context stack is empty, return null.\n  if (realm.contextStack.length === 0) return null;\n  // Let ec be the topmost execution context on the execution context stack whose Function component's [[ScriptOrModule]] component is not null.\n  // If such an execution context exists, return ec's Function component's [[ScriptOrModule]] slot's value.\n  let ec;\n  for (let i = realm.contextStack.length - 1; i >= 0; i--) {\n    ec = realm.contextStack[i];\n    let F = ec.function;\n    if (F == null) continue;\n    if (F.$ScriptOrModule instanceof Object) {\n      return F.$ScriptOrModule;\n    }\n  }\n  // Otherwise, let ec be the running execution context.\n  ec = realm.getRunningContext();\n  // Assert: ec's ScriptOrModule component is not null.\n  invariant(ec.ScriptOrModule !== null);\n  // Return ec's ScriptOrModule component.\n  return ec.ScriptOrModule;\n}\n\n// ECMA262 8.3.3\nexport function GetThisEnvironment(realm: Realm): EnvironmentRecord {\n  // 1. Let lex be the running execution context's LexicalEnvironment.\n  let lex = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Repeat\n  while (true) {\n    // a. Let envRec be lex's EnvironmentRecord.\n    let envRec = lex.environmentRecord;\n\n    // b. Let exists be envRec.HasThisBinding().\n    let exists = envRec.HasThisBinding();\n\n    // c. If exists is true, return envRec.\n    if (exists) return envRec;\n\n    // d. Let outer be the value of lex's outer environment reference.\n    let outer = lex.parent;\n    invariant(outer);\n\n    // e. Let lex be outer.\n    lex = outer;\n  }\n\n  invariant(false);\n}\n\n// ECMA262 8.3.4\nexport function ResolveThisBinding(realm: Realm): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n  // 1. Let envRec be GetThisEnvironment( ).\n  let envRec = GetThisEnvironment(realm);\n\n  // 2. Return ? envRec.GetThisBinding().\n  return envRec.GetThisBinding();\n}\n\nexport function BindingInitialization(realm: Realm, node: BabelNode, value: Value, environment: void | LexicalEnvironment) {\n  if (node.type === \"ArrayPattern\") { // ECMA262 13.3.3.5\n    // 1. Let iterator be ? GetIterator(value).\n    // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.\n    // 3. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.\n    // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n    // 5. Return result.\n    throw new Error(\"TODO: Patterns aren't supported yet\");\n  } else if (node.type === \"ObjectPattern\") { // ECMA262 13.3.3.5\n    // 1. Perform ? RequireObjectCoercible(value).\n    RequireObjectCoercible(realm, value);\n\n    // 2. Return the result of performing BindingInitialization for ObjectBindingPattern using value and environment as arguments.\n    throw new Error(\"TODO: Patterns aren't supported yet\");\n  } else if (node.type === \"Identifier\") { // ECMA262 12.1.5\n    // 1. Let name be StringValue of Identifier.\n    let name = ((node: any): BabelNodeIdentifier).name;\n\n    // 2. Return ? InitializeBoundName(name, value, environment).\n    return InitializeBoundName(realm, name, value, environment);\n  } else if (node.type === \"VariableDeclaration\") { // ECMA262 13.7.5.9\n    for (let decl of ((node: any): BabelNodeVariableDeclaration).declarations) {\n      BindingInitialization(realm, decl.id, value, environment);\n    }\n  }\n\n  throw new Error(\"Unknown node \" + node.type);\n}\n\n// ECMA262 12.1.5.1\nexport function InitializeBoundName(realm: Realm, name: string, value: Value, environment: void | LexicalEnvironment) {\n  // 1. Assert: Type(name) is String.\n  invariant(typeof name === \"string\", \"expected name to be a string\");\n\n  // 2. If environment is not undefined, then\n  if (environment) {\n    // a. Let env be the EnvironmentRecord component of environment.\n    let env = environment.environmentRecord;\n\n    // b. Perform env.InitializeBinding(name, value).\n    env.InitializeBinding(name, value);\n\n    // c. Return NormalCompletion(undefined).\n    return realm.intrinsics.undefined;\n  } else { // 3. Else,\n    // a. Let lhs be ResolveBinding(name).\n    // Note that the undefined environment implies non-strict.\n    let lhs = ResolveBinding(realm, name, false);\n\n    // b. Return ? PutValue(lhs, value).\n    return PutValue(realm, lhs, value);\n  }\n}\n\n// ECMA262 12.3.1.3 and 13.7.5.6\nexport function IsDestructuring(ast: BabelNode) {\n  switch (ast.type) {\n    case \"VariableDeclaration\":\n      for (let decl of ((ast: any): BabelNodeVariableDeclaration).declarations) {\n        switch (decl.type) {\n          case \"VariableDeclarator\":\n            switch (decl.id.type) {\n              case \"ArrayPattern\":\n              case \"AssignmentPattern\":\n              case \"ObjectPattern\":\n                return true;\n              default:\n                break;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      return false;\n    case \"ArrayLiteral\":\n    case \"ObjectLiteral\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n// ECMA262 13.3.3.7\nexport function KeyedBindingInitialization(realm: Realm, value: Value, environment: ?LexicalEnvironment, propertyName: string) {\n  // 1. Let bindingId be StringValue of BindingIdentifier.\n  let bindingId = propertyName;\n\n  // if environment is undefined, the calling context is not strict\n  let strict = environment !== undefined;\n\n  // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n  let lhs = ResolveBinding(realm, bindingId, strict, environment);\n\n  // 3. Let v be ? GetV(value, propertyName).\n  let v = GetV(realm, value, propertyName);\n\n  // 4. If Initializer is present and v is undefined, then\n  if (false) {\n    // a. Let defaultValue be the result of evaluating Initializer.\n    // b. Let v be ? GetValue(defaultValue).\n    // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n      // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n  }\n\n  // 5. If environment is undefined, return ? PutValue(lhs, v).\n  if (!environment) return PutValue(realm, lhs, v);\n\n  console.log(lhs, v);\n\n  // 6. Return InitializeReferencedBinding(lhs, v).\n  return InitializeReferencedBinding(realm, lhs, v);\n}\n"]}