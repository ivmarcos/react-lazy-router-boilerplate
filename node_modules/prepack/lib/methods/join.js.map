{"version":3,"sources":["../../src/methods/join.js"],"names":["joinPossiblyNormalCompletions","joinPossiblyNormalCompletionWithAbruptCompletion","joinEffectsAndRemoveNestedReturnCompletions","joinEffects","joinMaps","joinBindings","joinValues","joinValuesAsConditional","joinPropertyBindings","joinDescriptors","joinBooleans","t","realm","pnc","c","empty_effects","consequent","alternate","joinCondition","consequentEffects","new_alternate","alternateEffects","new_consequent","ac","e","alternate_effects","consequent_effects","nested_effects","undefined","e1","e2","intrinsics","createIntrospectionErrorThrowCompletion","result1","gen1","bindings1","properties1","createdObj1","result2","gen2","bindings2","properties2","createdObj2","result","joinResults","bindings","properties","createdObjects","Set","forEach","o","add","generator","joinGenerators","getAbstractValue","v1","v2","target","empty","val","value","generator1","generator2","body","push","args","buildNode","context","cond","block1","serializeBody","block2","ifStatement","unaryExpression","statements","startBody","serialize","endBody","blockStatement","m1","m2","join","m3","Map","val1","key","map1","val2","get","val3","set","map2","has","b","throwIfNotConcrete","condition","types","values","createAbstract","conditionalExpression","mightBeEmpty","mightHaveBeenDeleted","c1","c2","d1","d2","object","descriptor","clone_with_abstract_value","d","Error","dc","d3","writable","enumerable","configurable","hasOwnProperty"],"mappings":"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","file":"join.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeBlockStatement } from \"babel-types\";\nimport type { Binding } from \"../environment.js\";\nimport type { Bindings, Effects, EvaluationResult, PropertyBindings, CreatedObjects, Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport { AbruptCompletion, BreakCompletion, Completion, ContinueCompletion,\n   PossiblyNormalCompletion, JoinedAbruptCompletions,\n   ReturnCompletion, IntrospectionThrowCompletion, ThrowCompletion } from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport type { SerializationContext } from \"../utils/generator.js\";\nimport { AbstractValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\nexport function joinPossiblyNormalCompletions(\n    realm: Realm, pnc: PossiblyNormalCompletion, c: PossiblyNormalCompletion): PossiblyNormalCompletion {\n    let empty_effects = construct_empty_effects(realm);\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof Value) {\n        return new PossiblyNormalCompletion(pnc.joinCondition,\n           pnc.consequent, pnc.consequentEffects, c, empty_effects);\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let new_alternate = joinPossiblyNormalCompletions(realm, pnc.alternate, c);\n      return new PossiblyNormalCompletion(pnc.joinCondition,\n         pnc.consequent, pnc.consequentEffects, new_alternate, empty_effects);\n    } else {\n      invariant(pnc.alternate instanceof AbruptCompletion);\n      if (pnc.consequent instanceof Value) {\n        return new PossiblyNormalCompletion(pnc.joinCondition,\n           c, empty_effects, pnc.alternate, pnc.alternateEffects);\n      }\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      let new_consequent = joinPossiblyNormalCompletions(realm, pnc.consequent, c);\n      return new PossiblyNormalCompletion(pnc.joinCondition,\n         new_consequent, empty_effects, pnc.alternate, pnc.alternateEffects);\n    }\n}\n\nexport function joinPossiblyNormalCompletionWithAbruptCompletion(\n    realm: Realm, pnc: PossiblyNormalCompletion, ac: AbruptCompletion, e: Effects): Effects {\n  if (pnc.consequent instanceof AbruptCompletion) {\n    if (pnc.alternate instanceof Value)\n      return joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, e);\n    invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n    let alternate_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.alternate, ac, e);\n    invariant(pnc.consequent instanceof AbruptCompletion);\n    return joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, alternate_effects);\n  } else {\n    invariant(pnc.alternate instanceof AbruptCompletion);\n    if (pnc.consequent instanceof Value)\n      return joinEffects(realm, pnc.joinCondition, e, pnc.alternateEffects);\n    invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n    let consequent_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.consequent, ac, e);\n    invariant(pnc.alternate instanceof AbruptCompletion);\n    return joinEffects(realm, pnc.joinCondition, consequent_effects, pnc.alternateEffects);\n  }\n}\n\nexport function joinEffectsAndRemoveNestedReturnCompletions(\n    realm: Realm, c: Completion | Value, e: Effects, nested_effects?: Effects): Effects {\n  if (c instanceof Value)\n    return e;\n  if (c instanceof AbruptCompletion) {\n    invariant(nested_effects !== undefined);\n    return nested_effects;\n  }\n  if (c instanceof PossiblyNormalCompletion) {\n    let e1 = joinEffectsAndRemoveNestedReturnCompletions(realm, c.consequent, e, c.consequentEffects);\n    let e2 = joinEffectsAndRemoveNestedReturnCompletions(realm, c.alternate, e, c.alternateEffects);\n    if (e1[0] instanceof ReturnCompletion) {\n      if (!(e2[0] instanceof ReturnCompletion)) {\n        invariant(e2[0] instanceof Value); // otherwise c cannot possibly be normal\n        e2[0] = new ReturnCompletion(realm.intrinsics.undefined);\n      }\n      return joinEffects(realm, c.joinCondition, e1, e2);\n    } else if (e2[0] instanceof ReturnCompletion) {\n      invariant(e1[0] instanceof Value); // otherwise c cannot possibly be normal\n      e1[0] = new ReturnCompletion(realm.intrinsics.undefined);\n      return joinEffects(realm, c.joinCondition, e1, e2);\n    } else {\n      throw AbstractValue.createIntrospectionErrorThrowCompletion(c.joinCondition);\n    }\n  }\n  invariant(false);\n}\n\nexport function joinEffects(realm: Realm, joinCondition: AbstractValue,\n    e1: Effects, e2: Effects): Effects {\n  let [result1, gen1, bindings1, properties1, createdObj1] = e1;\n  let [result2, gen2, bindings2, properties2, createdObj2] = e2;\n\n  if (result1 instanceof IntrospectionThrowCompletion) return e1;\n  if (result2 instanceof IntrospectionThrowCompletion) return e2;\n  let result = joinResults(realm, joinCondition, result1, result2, e1, e2);\n  if (result1 instanceof AbruptCompletion) {\n    if (!(result2 instanceof AbruptCompletion)) {\n      invariant(result instanceof PossiblyNormalCompletion);\n      return [result, gen2, bindings2, properties2, createdObj2];\n    }\n  } else if (result2 instanceof AbruptCompletion) {\n    invariant(result instanceof PossiblyNormalCompletion);\n    return [result, gen1, bindings1, properties1, createdObj1];\n  }\n\n  let bindings = joinBindings(realm, joinCondition, bindings1, bindings2);\n  let properties = joinPropertyBindings(realm, joinCondition,\n    properties1, properties2, createdObj1, createdObj2);\n  let createdObjects = new Set();\n  createdObj1.forEach((o) => {\n    createdObjects.add(o);\n  });\n  createdObj2.forEach((o) => {\n    createdObjects.add(o);\n  });\n\n  let generator = joinGenerators(realm, joinCondition, gen1, gen2, result1, result2);\n\n  return [result, generator, bindings, properties, createdObjects];\n}\n\nfunction joinResults(realm: Realm, joinCondition: AbstractValue,\n    result1: EvaluationResult, result2: EvaluationResult,\n    e1: Effects, e2: Effects): EvaluationResult {\n  function getAbstractValue(v1: void | Value, v2: void | Value): AbstractValue {\n    return joinValuesAsConditional(realm, joinCondition, v1, v2);\n  }\n  if (result1 instanceof Reference || result2 instanceof Reference)\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(joinCondition);\n  if (result1 instanceof BreakCompletion && result2 instanceof BreakCompletion &&\n      result1.target === result2.target) {\n    return new BreakCompletion(realm.intrinsics.empty, result1.target);\n  }\n  if (result1 instanceof ContinueCompletion && result2 instanceof ContinueCompletion &&\n      result1.target === result2.target) {\n    return new ContinueCompletion(realm.intrinsics.empty, result1.target);\n  }\n  if (result1 instanceof ReturnCompletion && result2 instanceof ReturnCompletion) {\n    let val = joinValues(realm, result1.value, result2.value, getAbstractValue);\n    return new ReturnCompletion(val);\n  }\n  if (result1 instanceof ThrowCompletion && result2 instanceof ThrowCompletion) {\n    let val = joinValues(realm, result1.value, result2.value, getAbstractValue);\n    return new ThrowCompletion(val);\n  }\n  if (result1 instanceof AbruptCompletion && result2 instanceof AbruptCompletion) {\n    return new JoinedAbruptCompletions(realm, joinCondition, result1, e1, result2, e2);\n  }\n  if (result1 instanceof Value && result2 instanceof Value)\n    return joinValues(realm, result1, result2, getAbstractValue);\n  return new PossiblyNormalCompletion(joinCondition, result1, e1, result2, e2);\n}\n\nfunction joinGenerators(realm: Realm, joinCondition: AbstractValue,\n    generator1: Generator, generator2: Generator,\n    result1: EvaluationResult, result2: EvaluationResult): Generator {\n  let result = new Generator(realm);\n  if (!generator1.empty() || !generator2.empty()) {\n    result.body.push({\n      args: [joinCondition],\n      buildNode: function ([cond], context) {\n        let block1 = generator1.empty() ? null : serializeBody(generator1, context);\n        let block2 = generator2.empty() ? null : serializeBody(generator2, context);\n        if (block1) return t.ifStatement(cond, block1, block2);\n        invariant(block2);\n        return t.ifStatement(t.unaryExpression(\"!\", cond), block2);\n      }\n    });\n  }\n  return result;\n}\n\nfunction serializeBody(\n  generator: Generator,\n  context: SerializationContext\n): BabelNodeBlockStatement {\n  let statements = context.startBody();\n  generator.serialize(statements, context);\n  context.endBody(statements);\n  return t.blockStatement(statements);\n}\n\n// Creates a single map that joins together maps m1 and m2 using the given join\n// operator. If an entry is present in one map but not the other, the missing\n// entry is treated as if it were there and its value were undefined.\nexport function joinMaps<K, V>(\n    m1: Map<K, void | V>,\n    m2: Map<K, void | V>,\n    join: (K, void | V, void | V) => V): Map<K, void | V> {\n  let m3 : Map<K, void | V> = new Map();\n  m1.forEach(\n    (val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = join(key, val1, val2);\n      m3.set(key, val3);\n    }\n  );\n  m2.forEach(\n    (val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, join(key, undefined, val2));\n      }\n    }\n  );\n  return m3;\n}\n\n// Creates a single map that has an key, value pair for the union of the key\n// sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]\n// where the join is defined to be just m1[key] if m1[key] === m2[key] and\n// and abstract value with expression \"joinCondition ? m1[key] : m2[key]\" if not.\nexport function joinBindings(realm: Realm, joinCondition: AbstractValue,\n     m1: Bindings, m2: Bindings): Bindings {\n\n  function getAbstractValue(v1: void | Value, v2: void | Value): AbstractValue{\n    return joinValuesAsConditional(realm, joinCondition, v1, v2);\n  }\n  function join(b: Binding, v1: void | Value, v2: void | Value) {\n    if (v1 === undefined) v1 = b.value;\n    if (v2 === undefined) v2 = b.value;\n    return joinValues(realm, v1, v2, getAbstractValue);\n  }\n  return joinMaps(m1, m2, join);\n}\n\n// If v1 is known and defined and v1 === v2 return v1,\n// otherwise return getAbstractValue(v1, v2)\nexport function joinValues(realm: Realm, v1: void | Value, v2: void | Value,\n  getAbstractValue: (void | Value, void | Value) => AbstractValue): Value {\n  if (v1 !== undefined && v2 !== undefined &&\n      !(v1 instanceof AbstractValue) && !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())) {\n    return v1;\n  } else {\n    return getAbstractValue(v1, v2);\n  }\n}\n\nexport function joinValuesAsConditional(\n    realm: Realm, condition: AbstractValue, v1: void | Value, v2: void | Value): AbstractValue {\n  let types = TypesDomain.joinValues(v1, v2);\n  let values = ValuesDomain.joinValues(realm, v1, v2);\n  let result = realm.createAbstract(types, values,\n    [condition, v1 || realm.intrinsics.undefined, v2 || realm.intrinsics.undefined],\n    (args) => t.conditionalExpression(args[0], args[1], args[2]));\n  if (v1) result.mightBeEmpty = v1.mightHaveBeenDeleted();\n  if (v2 && !result.mightBeEmpty) result.mightBeEmpty = v2.mightHaveBeenDeleted();\n  return result;\n}\n\nexport function joinPropertyBindings(realm: Realm, joinCondition: AbstractValue,\n    m1: PropertyBindings, m2: PropertyBindings,\n    c1: CreatedObjects, c2: CreatedObjects): PropertyBindings {\n\n  function getAbstractValue(v1: void | Value, v2: void | Value): AbstractValue{\n    return joinValuesAsConditional(realm, joinCondition, v1, v2);\n  }\n  function join(b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) {\n    // If the PropertyBinding object has been freshly allocated do not join\n    if (d1 === undefined) {\n      if (c2.has(b.object)) return d2; // no join\n      if (b.descriptor !== undefined && m1.has(b)) {\n        // property was deleted\n        d1 = cloneDescriptor(b.descriptor);\n        invariant(d1 !== undefined);\n        d1.value = realm.intrinsics.empty;\n      } else {\n        // no write to property\n        d1 = b.descriptor; //Get value of property before the split\n      }\n    }\n    if (d2 === undefined) {\n      if (c1.has(b.object)) return d1; // no join\n      if (b.descriptor !== undefined && m2.has(b)) {\n        // property was deleted\n        d2 = cloneDescriptor(b.descriptor);\n        invariant(d2 !== undefined);\n        d2.value = realm.intrinsics.empty;\n      } else {\n        // no write to property\n        d2 = b.descriptor; //Get value of property before the split\n      }\n    }\n    return joinDescriptors(realm, d1, d2, getAbstractValue);\n  }\n  return joinMaps(m1, m2, join);\n}\n\n// Returns a field by field join of two descriptors.\n// Descriptors with get/set are not yet supported.\nexport function joinDescriptors(realm: Realm,\n    d1: void | Descriptor, d2: void | Descriptor,\n    getAbstractValue: (void | Value, void | Value) => AbstractValue): void | Descriptor {\n  function clone_with_abstract_value(d: Descriptor) {\n    if (!IsDataDescriptor(realm, d))\n      throw new Error(\"TODO: join computed properties\");\n    let dc = cloneDescriptor(d);\n    invariant(dc !== undefined);\n    dc.value = getAbstractValue(d.value, realm.intrinsics.empty);\n    return dc;\n  }\n  if (d1 === undefined) {\n    if (d2 === undefined) return undefined;\n    // d2 is a new property created in only one branch, join with empty\n    return clone_with_abstract_value(d2);\n  } else if (d2 === undefined) {\n    // d1 is a new property created in only one branch, join with empty\n    return clone_with_abstract_value(d1);\n  } else {\n    let d3 : Descriptor = { };\n    let writable = joinBooleans(d1.writable, d2.writable);\n    if (writable !== undefined) d3.writable = writable;\n    let enumerable = joinBooleans(d1.enumerable, d2.enumerable);\n    if (enumerable !== undefined) d3.enumerable = enumerable;\n    let configurable = joinBooleans(d1.configurable, d2.configurable);\n    if (configurable !== undefined) d3.configurable = configurable;\n    if (IsDataDescriptor(realm, d1) || IsDataDescriptor(realm, d2))\n      d3.value = joinValues(realm, d1.value, d2.value, getAbstractValue);\n    if (d1.hasOwnProperty(\"get\") || d2.hasOwnProperty(\"get\"))\n      throw new Error(\"TODO: join callables\");\n    if (d1.hasOwnProperty(\"set\") || d2.hasOwnProperty(\"set\"))\n      throw new Error(\"TODO: join callables\");\n    return d3;\n  }\n}\n\n// Returns v1 || v2, treating undefined as false,\n// but returns undefined if both v1 and v2 are undefined.\nexport function joinBooleans(v1: void | boolean, v2: void | boolean): void | boolean {\n  if (v1 === undefined) {\n    return v2;\n  } else if (v2 === undefined) {\n    return v1;\n  } else {\n    return v1 || v2;\n  }\n}\n"]}