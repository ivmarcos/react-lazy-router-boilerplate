{"version":3,"sources":["../../src/methods/get.js"],"names":["GetFunctionRealm","OrdinaryGet","GetGlobalObject","GetSubstitution","GetMethod","GetPrototypeFromConstructor","Get","GetV","GetThisValue","GetNewTarget","GetTemplateObject","t","realm","obj","$Realm","target","$BoundTargetFunction","$ProxyHandler","createErrorThrowCompletion","intrinsics","TypeError","$ProxyTarget","proxyTarget","O","P","Receiver","dataOnly","desc","$GetOwnProperty","descValue","undefined","value","mightHaveBeenDeleted","parent","$GetPrototypeOf","parentVal","cond","createAbstract","topVal","empty","x","y","binaryExpression","$Get","createIntrospectionErrorThrowCompletion","getter","get","ctx","getRunningContext","currentRealm","$GlobalObject","matched","str","position","captures","replacement","matchLength","length","stringLength","Array","isArray","tailPos","m","result","i","ch","charAt","peek","substr","idx","charCodeAt","peek2","newIdx","V","func","constructor","intrinsicDefaultProto","proto","thisValue","envRec","SyntaxError","$NewTarget","templateLiteral","rawStrings","quasis","map","quasi","raw","templateRegistry","$TemplateMap","e","same","$Strings","$Array","cookedStrings","cooked","count","template","rawObj","index","prop","cookedValue","$DefineOwnProperty","writable","enumerable","configurable","rawValue","push"],"mappings":"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","file":"get.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, CallableObjectValue } from \"../types.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { Value, AbstractValue, BooleanValue, BoundFunctionValue, NumberValue, ProxyValue, UndefinedValue, StringValue, ObjectValue, NullValue, AbstractObjectValue } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { ArrayCreate } from \"./create.js\";\nimport { SetIntegrityLevel } from \"./integrity.js\";\nimport { ToString } from \"./to.js\";\nimport {\n  ToObjectPartial,\n  IsPropertyKey,\n  IsCallable,\n  IsPropertyReference,\n  IsSuperReference,\n  IsDataDescriptor,\n  IsAccessorDescriptor,\n  joinValuesAsConditional,\n  Call,\n  GetBase,\n  GetThisEnvironment,\n  HasSomeCompatibleType,\n} from \"./index.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeTemplateLiteral } from \"babel-types\";\nimport * as t from \"babel-types\";\n\n// ECMA262 7.3.22\nexport function GetFunctionRealm(realm: Realm, obj: ObjectValue): Realm {\n  // 1. Assert: obj is a callable object.\n  invariant(IsCallable(realm, obj), \"expected callable object\");\n\n  // 2. If obj has a [[Realm]] internal slot, then\n  if (obj.$Realm) {\n    // a. Return obj's [[Realm]] internal slot.\n    return obj.$Realm;\n  }\n\n  // 3. If obj is a Bound Function exotic object, then\n  if (obj instanceof BoundFunctionValue) {\n    // a. Let target be obj's [[BoundTargetFunction]] internal slot.\n    let target = obj.$BoundTargetFunction;\n\n    // b. Return ? GetFunctionRealm(target).\n    return GetFunctionRealm(realm, target);\n  }\n\n  // 4. If obj is a Proxy exotic object, then\n  if (obj instanceof ProxyValue) {\n    // a. If the value of the [[ProxyHandler]] internal slot of obj is null, throw a TypeError exception.\n    if (obj.$ProxyHandler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"proxy handler is null\");\n    }\n    invariant(obj.$ProxyTarget instanceof ObjectValue);\n\n    // b. Let proxyTarget be the value of obj's [[ProxyTarget]] internal slot.\n    let proxyTarget = obj.$ProxyTarget;\n\n    // c. Return ? GetFunctionRealm(proxyTarget).\n    return GetFunctionRealm(realm, proxyTarget);\n  }\n\n  // 5. Return the current Realm Record.\n  return realm;\n}\n\n// ECMA262 9.1.8.1\nexport function OrdinaryGet(realm: Realm, O: ObjectValue, P: PropertyKeyValue, Receiver: Value, dataOnly?: boolean): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let desc be ? O.[[GetOwnProperty]](P).\n  let desc = O.$GetOwnProperty(P);\n  let descValue = !desc ? realm.intrinsics.undefined :\n    (desc.value === undefined ? realm.intrinsics.undefined : desc.value);\n\n  // 3. If desc is undefined, then\n  if (!desc || descValue.mightHaveBeenDeleted()) {\n    // a. Let parent be ? O.[[GetPrototypeOf]]().\n    let parent = O.$GetPrototypeOf();\n\n    // b. If parent is null, return undefined.\n    if (parent instanceof NullValue) {\n      // Return the property value since it is now known to be the right value\n      // even in the case when it is empty.\n      return descValue;\n    }\n\n    // c. Return ? parent.[[Get]](P, Receiver).\n    if (descValue.mightHaveBeenDeleted()) {\n      // We don't know for sure that O.P does not exist.\n      invariant(descValue instanceof AbstractValue);\n      let parentVal = OrdinaryGet(realm, parent, P, descValue, true);\n      if (parentVal instanceof UndefinedValue)\n        // even O.P returns undefined it is still the right value.\n        return descValue;\n      // Join with parent value with descValue because the actual value will be\n      // descValue unless it is empty.\n      // Only get the parent value if it does not involve a getter call.\n      // Use a property get for the joined value since it does the check for empty.\n      let cond = realm.createAbstract(new TypesDomain(BooleanValue), ValuesDomain.topVal,\n        [descValue, realm.intrinsics.empty],\n        ([x, y]) => t.binaryExpression(\"!==\", x, y));\n      return joinValuesAsConditional(realm, cond, descValue, parentVal);\n    }\n    invariant(!desc);\n    return parent.$Get(P, Receiver);\n  }\n\n  // 4. If IsDataDescriptor(desc) is true, return desc.[[Value]].\n  if (IsDataDescriptor(realm, desc)) return descValue;\n  if (dataOnly) {\n    invariant(descValue instanceof AbstractValue);\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(descValue);\n  }\n\n  // 5. Assert: IsAccessorDescriptor(desc) is true.\n  invariant(IsAccessorDescriptor(realm, desc), \"expected accessor descriptor\");\n\n  // 6. Let getter be desc.[[Get]].\n  let getter = desc.get;\n\n  // 7. If getter is undefined, return undefined.\n  if (!getter || getter instanceof UndefinedValue) return realm.intrinsics.undefined;\n\n  // 8. Return ? Call(getter, Receiver).\n  return Call(realm, getter, Receiver);\n}\n\n// ECMA262 8.3.6\nexport function GetGlobalObject(realm: Realm): ObjectValue | AbstractObjectValue {\n  // 1. Let ctx be the running execution context.\n  let ctx = realm.getRunningContext();\n\n  // 2. Let currentRealm be ctx's Realm.\n  let currentRealm = ctx.realm;\n\n  // 3. Return currentRealm.[[GlobalObject]].\n  return currentRealm.$GlobalObject;\n}\n\n// ECMA262 21.1.3.14.1\nexport function GetSubstitution(realm: Realm, matched: string, str: string, position: number, captures: Array<string | void>, replacement: string): string {\n  // 1. Assert: Type(matched) is String.\n  invariant(typeof matched === \"string\", \"expected matched to be a stirng\");\n\n  // 2. Let matchLength be the number of code units in matched.\n  let matchLength = matched.length;\n\n  // 3. Assert: Type(str) is String.\n  invariant(typeof str === \"string\", \"expected matched to be a stirng\");\n\n  // 4. Let stringLength be the number of code units in str.\n  let stringLength = str.length;\n\n  // 5. Assert: position is a nonnegative integer.\n  invariant(position >= 0, \"expected position to be a nonegative integer\");\n\n  // 6. Assert: position ≤ stringLength.\n  invariant(position <= stringLength, \"expected position to be less than string length\");\n\n  // 7. Assert: captures is a possibly empty List of Strings.\n  invariant(Array.isArray(captures), \"expected captures to be an array\");\n\n  // 8. Assert: Type(replacement) is String.\n  invariant(typeof replacement === \"string\", \"expected replacement to be a stirng\");\n\n  // 9. Let tailPos be position + matchLength.\n  let tailPos = position + matchLength;\n\n  // 10. Let m be the number of elements in captures.\n  let m = captures.length;\n\n  // 11. Let result be a String value derived from replacement by copying code unit elements\n  //     from replacement to result while performing replacements as specified in Table 46.\n  //     These $ replacements are done left-to-right, and, once such a replacement is performed,\n  //     the new replacement text is not subject to further replacements.\n  let result = \"\";\n  for (let i = 0; i < replacement.length; ++i) {\n    let ch = replacement.charAt(i);\n    if (ch !== \"$\" || i + 1 >= replacement.length) {\n      result += ch;\n      continue;\n    }\n    let peek = replacement.charAt(i + 1);\n    if (peek === \"&\") {\n      result += matched;\n    } else if (peek === \"$\") {\n      result += \"$\";\n    } else if (peek === \"`\") {\n      result += str.substr(0, position);\n    } else if (peek === \"'\") {\n      result += str.substr(tailPos);\n    } else if (peek >= \"0\" && peek <= \"9\") {\n      let idx = peek.charCodeAt(0) - \"0\".charCodeAt(0);\n      if (i + 2 < replacement.length) {\n        let peek2 = replacement.charAt(i + 2);\n        if (peek2 >= \"0\" && peek2 <= \"9\") {\n          let newIdx = idx * 10 + (peek2.charCodeAt(0) - \"0\".charCodeAt(0));\n          if (newIdx <= m) {\n            idx = newIdx;\n            i += 1;\n          }\n        }\n      }\n      if (idx > 0 && idx <= m) {\n        result += captures[idx - 1] || \"\";\n      } else {\n        result += \"$\" + idx;\n      }\n    } else {\n      result += \"$\" + peek;\n    }\n    i += 1;\n  }\n\n  // 12. Return result.\n  return result;\n}\n\n// ECMA262 7.3.9\nexport function GetMethod(realm: Realm, V: Value, P: PropertyKeyValue): UndefinedValue | CallableObjectValue {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let func be ? GetV(V, P).\n  let func = GetV(realm, V, P);\n\n  // 3. If func is either undefined or null, return undefined.\n  if (HasSomeCompatibleType(realm, func, NullValue, UndefinedValue)) {\n    return realm.intrinsics.undefined;\n  }\n\n  // 4. If IsCallable(func) is false, throw a TypeError exception.\n  if (!IsCallable(realm, func)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n\n  // 5. Return func.\n  return ((func: any): CallableObjectValue);\n}\n\n// ECMA262 9.1.14\nexport function GetPrototypeFromConstructor(realm: Realm, constructor: ObjectValue, intrinsicDefaultProto: string): ObjectValue {\n  // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic\n  //   object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]]\n  //   value of an object.\n  invariant(realm.intrinsics[intrinsicDefaultProto], \"not a valid proto ref\");\n\n  // 2. Assert: IsCallable(constructor) is true.\n  invariant(IsCallable(realm, constructor) === true, \"expected constructor to be callable\");\n\n  // 3. Let proto be ? Get(constructor, \"prototype\").\n  let proto = Get(realm, constructor, new StringValue(realm, \"prototype\"));\n\n  // 4. If Type(proto) is not Object, then\n  if (!(proto instanceof ObjectValue)) {\n    // a. Let realm be ? GetFunctionRealm(constructor).\n    realm = GetFunctionRealm(realm, constructor);\n\n    // b. Let proto be realm's intrinsic object named intrinsicDefaultProto.\n    proto = realm.intrinsics[intrinsicDefaultProto];\n  }\n\n  // 5. Return proto.\n  return proto;\n}\n\n// ECMA262 7.3.1\nexport function Get(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue): Value {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue, \"Not an object value\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"Not a valid property key\");\n\n  // 3. Return ? O.[[Get]](P, O).\n  return O.$Get(P, O);\n}\n\n// ECMA262 7.3.2\nexport function GetV(realm: Realm, V: Value, P: PropertyKeyValue): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"Not a valid property key\");\n\n  // 2. Let O be ? ToObject(V).\n  let O = ToObjectPartial(realm, V);\n\n  // 3. Return ? O.[[Get]](P, V).\n  return O.$Get(P, V);\n}\n\n// ECMA262 6.2.3.3\nexport function GetThisValue(realm: Realm, V: Reference): Value {\n  // 1. Assert: IsPropertyReference(V) is true.\n  invariant(IsPropertyReference(realm, V), \"expected property reference\");\n\n  // 2. If IsSuperReference(V) is true, then\n  if (IsSuperReference(realm, V)) {\n    invariant(V.thisValue !== undefined);\n    // a. Return the value of the thisValue component of the reference V.\n    return V.thisValue;\n  }\n\n  // 3. Return GetBase(V).\n  let result = GetBase(realm, V);\n  invariant(result instanceof Value);\n  return result;\n}\n\n// ECMA262 8.3.5\nexport function GetNewTarget(realm: Realm): UndefinedValue | ObjectValue {\n  // 1. Let envRec be GetThisEnvironment( ).\n  let envRec = GetThisEnvironment(realm);\n\n  // 2. Assert: envRec has a [[NewTarget]] field.\n  if (!('$NewTarget' in envRec)) {\n    // In the spec we should not get here because earlier static checks are supposed to prevent it.\n    // However, we do not have an appropriate place to do this check earlier.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"new.target not allowed here\");\n  }\n\n  // 3. Return envRec.[[NewTarget]].\n  return envRec.$NewTarget || realm.intrinsics.undefined;\n}\n\nexport function GetTemplateObject(realm: Realm, templateLiteral: BabelNodeTemplateLiteral): ObjectValue {\n  // 1. Let rawStrings be TemplateStrings of templateLiteral with argument true.\n  let rawStrings = templateLiteral.quasis.map((quasi) => quasi.value.raw);\n\n  // 2. Let realm be the current Realm Record.\n  realm;\n\n  // 3. Let templateRegistry be realm.[[TemplateMap]].\n  let templateRegistry = realm.$TemplateMap;\n\n  // 4. For each element e of templateRegistry, do\n  for (let e of templateRegistry) {\n    let same;\n    if (e.$Strings.length === rawStrings.length) {\n      same = true;\n      for (let i = 0; i < rawStrings.length; ++i) {\n        if (e.$Strings[i] !== rawStrings[i]) {\n          same = false;\n          break;\n        }\n      }\n    } else {\n      same = false;\n    }\n\n    // a. If e.[[Strings]] and rawStrings contain the same values in the same order, then\n    if (same) {\n      // i. Return e.[[Array]].\n      return e.$Array;\n    }\n  }\n\n  // 5. Let cookedStrings be TemplateStrings of templateLiteral with argument false.\n  let cookedStrings = templateLiteral.quasis.map((quasi) => quasi.value.cooked);\n\n  // 6. Let count be the number of elements in the List cookedStrings.\n  let count = cookedStrings.length;\n\n  // 7. Let template be ArrayCreate(count).\n  let template = ArrayCreate(realm, count);\n\n  // 8. Let rawObj be ArrayCreate(count).\n  let rawObj = ArrayCreate(realm, count);\n\n  // 9. Let index be 0.\n  let index = 0;\n\n  // 10. Repeat while index < count\n  while (index < count) {\n    // a. Let prop be ! ToString(index).\n    let prop = ToString(realm, new NumberValue(realm, index));\n\n    // b. Let cookedValue be the String value cookedStrings[index].\n    let cookedValue = new StringValue(realm, cookedStrings[index]);\n\n    // c. Call template.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).\n    template.$DefineOwnProperty(prop, {\n        value: cookedValue,\n        writable: false,\n        enumerable: true,\n        configurable: false\n    });\n\n    // d. Let rawValue be the String value rawStrings[index].\n    let rawValue = new StringValue(realm, rawStrings[index]);\n\n    // e. Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).\n    rawObj.$DefineOwnProperty(prop, {\n        value: rawValue,\n        writable: false,\n        enumerable: true,\n        configurable: false\n    });\n\n    // f. Let index be index+1.\n    index = index + 1;\n  }\n\n  // 11. Perform SetIntegrityLevel(rawObj, \"frozen\").\n  SetIntegrityLevel(realm, rawObj, \"frozen\");\n\n  // 12. Call template.[[DefineOwnProperty]](\"raw\", PropertyDescriptor{[[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).\n  template.$DefineOwnProperty(\"raw\", {\n      value: rawObj,\n      writable: false,\n      enumerable: false,\n      configurable: false\n  });\n\n  // 13. Perform SetIntegrityLevel(template, \"frozen\").\n  SetIntegrityLevel(realm, template, \"frozen\");\n\n  // 14. Append the Record{[[Strings]]: rawStrings, [[Array]]: template} to templateRegistry.\n  templateRegistry.push({ $Strings: rawStrings, $Array: template });\n\n  // 15. Return template.\n  return template;\n}\n"]}