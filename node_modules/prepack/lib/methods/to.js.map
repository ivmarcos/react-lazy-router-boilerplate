{"version":3,"sources":["../../src/methods/to.js"],"names":["ToInt32","ToUint32","ToInt16","ToUint16","ToInt8","ToUint8","ToUint8Clamp","thisBooleanValue","thisNumberValue","thisStringValue","ToPropertyDescriptor","ToObject","ToObjectPartial","ToLength","ToInteger","ToIndex","ToIndexPartial","ToNumber","IsToNumberPure","ToPrimitive","GetToPrimitivePureResultType","IsToPrimitivePure","OrdinaryToPrimitive","ToString","ToStringPartial","ToBoolean","ToBooleanPartial","ToPropertyKey","ToPropertyKeyPartial","CanonicalNumericIndexString","ElementConv","Int8","Int16","Int32","Uint8","Uint16","Uint32","Uint8Clamped","modulo","x","y","realm","argument","number","isNaN","isFinite","int","Math","floor","abs","int32bit","pow","int16bit","int8bit","f","value","$BooleanData","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","$NumberData","$StringData","Obj","desc","hasEnumerable","enu","enumerable","hasConfigurable","conf","configurable","hasValue","hasWritable","writable","hasGet","getter","mightBeUndefined","get","hasSet","setter","set","arg","obj","BooleanPrototype","NumberPrototype","StringPrototype","SymbolPrototype","$SymbolData","len","Infinity","min","index","integerIndex","RangeError","val","createIntrospectionErrorThrowCompletion","NaN","prim","Number","input","hint","exoticToPrim","SymbolToPrimitive","result","getType","undefined","methodNames","name","method","primValue","length","mightNotBeObject","key","mightNotBeString","n"],"mappings":"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","file":"to.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Descriptor, CallableObjectValue } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { GetMethod, Get } from \"./get.js\";\nimport { StringCreate } from \"./create.js\";\nimport { HasProperty } from \"./has.js\";\nimport { Call } from \"./call.js\";\nimport { IsCallable } from \"./is.js\";\nimport { SameValue, SameValueZero } from \"./abstract.js\";\nimport { Value, ConcreteValue, PrimitiveValue, UndefinedValue, BooleanValue, ObjectValue, SymbolValue, StringValue, NumberValue, NullValue, AbstractValue, AbstractObjectValue } from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\n\nexport const ElementConv = {\n  Int8: ToInt8,\n  Int16: ToInt16,\n  Int32: ToInt32,\n  Uint8: ToUint8,\n  Uint16: ToUint16,\n  Uint32: ToUint32,\n  Uint8Clamped: ToUint8Clamp\n};\n\ntype numberOrValue = number | Value;\n\nfunction modulo(x: number, y: number): number {\n  return x < 0 ? (x % y + y) : (x % y);\n}\n\n// ECMA262 7.1.5\nexport function ToInt32(realm: Realm, argument: numberOrValue): number {\n  // 1. Let number be ? ToNumber(argument).\n  let number = ToNumber(realm, argument);\n\n  // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n  if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n  let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n  // 4. Let int16bit be int modulo 2^32.\n  let int32bit = modulo(int, Math.pow(2, 32));\n\n  // 5. If int32bit ≥ 2^31, return int32bit - 2^32; otherwise return int32bit.\n  return int32bit >= Math.pow(2, 31) ? int32bit - Math.pow(2, 32) : int32bit;\n}\n\n// ECMA262 7.1.6\nexport function ToUint32(realm: Realm, argument: numberOrValue): number {\n  // 1. Let number be ? ToNumber(argument).\n  let number = ToNumber(realm, argument);\n\n  // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n  if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n  let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n  // 4. Let int16bit be int modulo 2^32.\n  let int32bit = modulo(int, Math.pow(2, 32));\n\n  // 5. Return int32bit.\n  return int32bit;\n}\n\n// ECMA262 7.1.7\nexport function ToInt16(realm: Realm, argument: numberOrValue): number {\n  // 1. Let number be ? ToNumber(argument).\n  let number = ToNumber(realm, argument);\n\n  // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n  if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n  let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n  // 4. Let int16bit be int modulo 2^16.\n  let int16bit = modulo(int, Math.pow(2, 16));\n\n  // 5. If int16bit ≥ 2^15, return int16bit - 2^16; otherwise return int16bit.\n  return int16bit >= Math.pow(2, 15) ? int16bit - Math.pow(2, 16) : int16bit;\n}\n\n// ECMA262 7.1.8\nexport function ToUint16(realm: Realm, argument: numberOrValue): number {\n  // 1. Let number be ? ToNumber(argument).\n  let number = ToNumber(realm, argument);\n\n  // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n  if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n  let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n  // 4. Let int16bit be int modulo 2^16.\n  let int16bit = modulo(int, Math.pow(2, 16));\n\n  // 5. Return int16bit.\n  return int16bit;\n}\n\n// ECMA262 7.1.9\nexport function ToInt8(realm: Realm, argument: numberOrValue): number {\n  // 1. Let number be ? ToNumber(argument).\n  let number = ToNumber(realm, argument);\n\n  // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n  if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n  let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n  // 4. Let int8bit be int modulo 2^8.\n  let int8bit = modulo(int, Math.pow(2, 8));\n\n  // 5. If int8bit ≥ 2^7, return int8bit - 2^8; otherwise return int8bit.\n  return int8bit >= Math.pow(2, 7) ? int8bit - Math.pow(2, 8) : int8bit;\n}\n\n// ECMA262 7.1.10\nexport function ToUint8(realm: Realm, argument: numberOrValue): number {\n  // 1. Let number be ? ToNumber(argument).\n  let number = ToNumber(realm, argument);\n\n  // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n  if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n  // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n  let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n  // 4. Let int8bit be int modulo 2^8.\n  let int8bit = modulo(int, Math.pow(2, 8));\n\n  // 5. Return int8bit.\n  return int8bit;\n}\n\n// ECMA262 7.1.11\nexport function ToUint8Clamp(realm: Realm, argument: numberOrValue): number {\n  // 1. Let number be ? ToNumber(argument).\n  let number = ToNumber(realm, argument);\n\n  // 2. If number is NaN, return +0.\n  if (isNaN(number)) return +0;\n\n  // 3. If number ≤ 0, return +0.\n  if (number <= 0) return +0;\n\n  // 4. If number ≥ 255, return 255.\n  if (number >= 255) return 255;\n\n  // 5. Let f be floor(number).\n  let f = Math.floor(number);\n\n  // 6. If f + 0.5 < number, return f + 1.\n  if (f + 0.5 < number) return f + 1;\n\n  // 7. If number < f + 0.5, return f.\n  if (number < f + 0.5) return f;\n\n  // 8. If f is odd, return f + 1.\n  if (f % 2 === 1) return f + 1;\n\n  // 9. Return f.\n  return f;\n}\n\n// ECMA262 19.3.3.1\nexport function thisBooleanValue(realm: Realm, value: Value): BooleanValue {\n  // 1. If Type(value) is Boolean, return value.\n  if (value instanceof BooleanValue) return value;\n\n  // 2. If Type(value) is Object and value has a [[BooleanData]] internal slot, then\n  if (value instanceof ObjectValue && value.$BooleanData) {\n    // a. Assert: value's [[BooleanData]] internal slot is a Boolean value.\n    invariant(value.$BooleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n\n    // b. Return the value of value's [[BooleanData]] internal slot.\n    return value.$BooleanData;\n  }\n\n  value.throwIfNotConcrete();\n\n  // 3. Throw a TypeError exception.\n  throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n}\n\n// ECMA262 20.1.3\nexport function thisNumberValue(realm: Realm, value: Value): NumberValue {\n  // 1. If Type(value) is Number, return value.\n  if (value instanceof NumberValue) return value;\n\n  // 2. If Type(value) is Object and value has a [[NumberData]] internal slot, then\n  if (value instanceof ObjectValue && value.$NumberData) {\n    // a. Assert: value's [[NumberData]] internal slot is a Number value.\n    invariant(value.$NumberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n\n    // b. Return the value of value's [[NumberData]] internal slot.\n    return value.$NumberData;\n  }\n\n  value = value.throwIfNotConcrete();\n\n  // 3. Throw a TypeError exception.\n  throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n}\n\n// ECMA262 21.1.3\nexport function thisStringValue(realm: Realm, value: Value): StringValue {\n  // 1. If Type(value) is String, return value.\n  if (value instanceof StringValue) return value;\n\n  // 2. If Type(value) is Object and value has a [[StringData]] internal slot, then\n  if (value instanceof ObjectValue && value.$StringData) {\n    // a. Assert: value's [[StringData]] internal slot is a String value.\n    invariant(value.$StringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n\n    // b. Return the value of value's [[StringData]] internal slot.\n    return value.$StringData;\n  }\n\n  value = value.throwIfNotConcrete();\n\n  // 3. Throw a TypeError exception.\n  throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n}\n\n// ECMA262 6.2.4.5\nexport function ToPropertyDescriptor(realm: Realm, Obj: Value): Descriptor {\n  Obj = Obj.throwIfNotConcrete();\n\n  // 1. If Type(Obj) is not Object, throw a TypeError exception.\n  if (!(Obj instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // 2. Let desc be a new Property Descriptor that initially has no fields.\n  let desc: Descriptor = {};\n\n  // 3. Let hasEnumerable be ? HasProperty(Obj, \"enumerable\").\n  let hasEnumerable = HasProperty(realm, Obj, \"enumerable\");\n\n  // 4. If hasEnumerable is true, then\n  if (hasEnumerable === true) {\n    // a. Let enum be ToBoolean(? Get(Obj, \"enumerable\")).\n    let enu = ToBooleanPartial(realm, Get(realm, Obj, \"enumerable\"));\n\n    // b. Set the [[Enumerable]] field of desc to enum.\n    desc.enumerable = enu === true;\n  }\n\n  // 5. Let hasConfigurable be ? HasProperty(Obj, \"configurable\").\n  let hasConfigurable = HasProperty(realm, Obj, \"configurable\");\n\n  // 6. If hasConfigurable is true, then\n  if (hasConfigurable === true) {\n    // a. Let conf be ToBoolean(? Get(Obj, \"configurable\")).\n    let conf = ToBooleanPartial(realm, Get(realm, Obj, \"configurable\"));\n\n    // b. Set the [[Configurable]] field of desc to conf.\n    desc.configurable = conf === true;\n  }\n\n  // 7. Let hasValue be ? HasProperty(Obj, \"value\").\n  let hasValue = HasProperty(realm, Obj, \"value\");\n\n  // 8. If hasValue is true, then\n  if (hasValue === true) {\n    // a. Let value be ? Get(Obj, \"value\").\n    let value = Get(realm, Obj, \"value\");\n\n    // b. Set the [[Value]] field of desc to value.\n    desc.value = value;\n  }\n\n  // 9. Let hasWritable be ? HasProperty(Obj, \"writable\").\n  let hasWritable = HasProperty(realm, Obj, \"writable\");\n\n  // 10. If hasWritable is true, then\n  if (hasWritable === true) {\n    // a. Let writable be ToBoolean(? Get(Obj, \"writable\")).\n    let writable = ToBooleanPartial(realm, Get(realm, Obj, \"writable\"));\n\n    // b. Set the [[Writable]] field of desc to writable.\n    desc.writable = writable === true;\n  }\n\n  // 11. Let hasGet be ? HasProperty(Obj, \"get\").\n  let hasGet = HasProperty(realm, Obj, \"get\");\n\n  // 12. If hasGet is true, then\n  if (hasGet === true) {\n    // a. Let getter be ? Get(Obj, \"get\").\n    let getter = Get(realm, Obj, \"get\");\n\n    // b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.\n    if (IsCallable(realm, getter) === false && !getter.mightBeUndefined()) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n    getter.throwIfNotConcrete();\n\n    // c. Set the [[Get]] field of desc to getter.\n    desc.get = ((getter: any): CallableObjectValue | UndefinedValue);\n  }\n\n  // 13. Let hasSet be ? HasProperty(Obj, \"set\").\n  let hasSet = HasProperty(realm, Obj, \"set\");\n\n  // 14. If hasSet is true, then\n  if (hasSet === true) {\n    // a. Let setter be ? Get(Obj, \"set\").\n    let setter = Get(realm, Obj, \"set\");\n\n    // b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.\n    if (IsCallable(realm, setter) === false && !setter.mightBeUndefined()) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n    setter.throwIfNotConcrete();\n\n    // c. Set the [[Set]] field of desc to setter.\n    desc.set = ((setter: any): CallableObjectValue | UndefinedValue);\n  }\n\n  // 15. If either desc.[[Get]] or desc.[[Set]] is present, then\n  if (desc.get || desc.set) {\n    // a. If either desc.[[Value]] or desc.[[Writable]] is present, throw a TypeError exception.\n    if (\"value\" in desc || \"writable\" in desc) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n  }\n\n  // 16. Return desc.\n  return desc;\n}\n\n// ECMA262 7.1.13\nexport function ToObject(realm: Realm, arg: ConcreteValue): ObjectValue {\n  if (arg instanceof UndefinedValue) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  } else if (arg instanceof NullValue) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  } else if (arg instanceof BooleanValue) {\n    let obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n    obj.$BooleanData = arg;\n    return obj;\n  } else if (arg instanceof NumberValue) {\n    let obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n    obj.$NumberData = arg;\n    return obj;\n  } else if (arg instanceof StringValue) {\n    let obj = StringCreate(realm, arg, realm.intrinsics.StringPrototype);\n    return obj;\n  } else if (arg instanceof SymbolValue) {\n    let obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n    obj.$SymbolData = arg;\n    return obj;\n  } else if (arg instanceof ObjectValue) {\n    return arg;\n  }\n  invariant(false);\n}\n\nexport function ToObjectPartial(realm: Realm, arg: Value): ObjectValue | AbstractObjectValue {\n  if (arg instanceof AbstractObjectValue) return arg;\n  arg = arg.throwIfNotConcrete();\n  return ToObject(realm, arg);\n}\n\n// ECMA262 7.1.15\nexport function ToLength(realm: Realm, argument: numberOrValue): number {\n  // Let len be ? ToInteger(argument).\n  let len = ToInteger(realm, argument);\n\n  // If len ≤ +0, return +0.\n  if (len <= 0) return +0;\n\n  // If len is +∞, return 2^53-1.\n  if (len === +Infinity) return Math.pow(2, 53) - 1;\n\n  // Return min(len, 2^53-1).\n  return Math.min(len, Math.pow(2, 53) - 1);\n}\n\n// ECMA262 7.1.4\nexport function ToInteger(realm: Realm, argument: numberOrValue): number {\n  // 1. Let number be ? ToNumber(argument).\n  let number = ToNumber(realm, argument);\n\n  // 2. If number is NaN, return +0.\n  if (isNaN(number)) return +0;\n\n  // 3. If number is +0, -0, +∞, or -∞, return number.\n  if (!isFinite(number) || number === 0) return number;\n\n  // 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).\n  return number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n}\n\n// ECMA262 7.1.17\nexport function ToIndex(realm: Realm, value: number | ConcreteValue): number {\n  let index;\n  // 1. If value is undefined, then\n  if (value instanceof UndefinedValue) {\n    // a. Let index be 0.\n    index = 0;\n  } else { // 2. Else,\n    // a. Let integerIndex be ? ToInteger(value).\n    let integerIndex = ToInteger(realm, value);\n\n    // b. If integerIndex < 0, throw a RangeError exception.\n    if (integerIndex < 0) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n    }\n\n    // c. Let index be ! ToLength(integerIndex).\n    index = ToLength(realm, integerIndex);\n\n    // d. If SameValueZero(integerIndex, index) is false, throw a RangeError exception.\n    if (SameValueZero(realm, new NumberValue(realm, integerIndex), new NumberValue(realm, index)) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n    }\n  }\n  // 3. Return index.\n  return index;\n}\n\nexport function ToIndexPartial(realm: Realm, value: numberOrValue): number {\n  return ToIndex(realm, typeof value === \"number\" ? value : value.throwIfNotConcrete());\n}\n\n// ECMA262 7.1.3\nexport function ToNumber(realm: Realm, val: numberOrValue): number {\n  if (typeof val === \"number\") {\n    return val;\n  } else if (val instanceof AbstractValue) {\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(val);\n  } else if (val instanceof UndefinedValue) {\n    return NaN;\n  } else if (val instanceof NullValue) {\n    return +0;\n  } else if (val instanceof ObjectValue) {\n    let prim = ToPrimitive(realm, val, \"number\");\n    return ToNumber(realm, prim);\n  } else if (val instanceof BooleanValue) {\n    if (val.value === true) {\n      return 1;\n    } else { // `val.value === false`\n      return 0;\n    }\n  } else if (val instanceof NumberValue) {\n    return val.value;\n  } else if (val instanceof StringValue) {\n    return Number(val.value);\n  } else {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to a number\");\n  }\n}\n\nexport function IsToNumberPure(realm: Realm, val: numberOrValue): boolean {\n  // This carefully abstracts the behavior of IsToNumberSideEffectFree.\n  if (val instanceof ObjectValue) return IsToPrimitivePure(realm, val);\n  return true;\n}\n\n// ECMA262 7.1.1\nexport function ToPrimitive(realm: Realm, input: ConcreteValue, hint?: \"default\" | \"string\" | \"number\"): PrimitiveValue {\n  if (input instanceof PrimitiveValue) {\n    return input;\n  }\n\n  // When Type(input) is Object, the following steps are taken\n  invariant(input instanceof ObjectValue, \"expected an object\");\n\n  // 1. If PreferredType was not passed, let hint be \"default\".\n  hint = hint || \"default\";\n\n  // Following two steps are redundant since we just pass string hints.\n  // 2. Else if PreferredType is hint String, let hint be \"string\".\n  // 3. Else PreferredType is hint Number, let hint be \"number\".\n\n  // 4. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).\n  let exoticToPrim = GetMethod(realm, input, realm.intrinsics.SymbolToPrimitive);\n\n  // 5. If exoticToPrim is not undefined, then\n  if (!(exoticToPrim instanceof UndefinedValue)) {\n    // a. Let result be ? Call(exoticToPrim, input, « hint »).\n    let result = Call(realm, exoticToPrim, input, [new StringValue(realm, hint)]);\n\n    // b. If Type(result) is not Object, return result.\n    if (!(result instanceof ObjectValue)) {\n      invariant(result instanceof PrimitiveValue);\n      return result;\n    }\n\n    // c. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // 6. If hint is \"default\", let hint be \"number\".\n  if (hint === \"default\") hint = \"number\";\n\n  // 7. Return ? OrdinaryToPrimitive(input, hint).\n  return OrdinaryToPrimitive(realm, input, hint);\n}\n\n// Returns result type of ToPrimitive if it is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\nexport function GetToPrimitivePureResultType(realm: Realm, input: Value): void | typeof Value {\n  // This carefully abstracts the behavior of ToPrimitive.\n  if (input instanceof PrimitiveValue || input instanceof AbstractValue) return input.getType();\n  invariant(input instanceof ObjectValue);\n  return undefined;\n}\n\nexport function IsToPrimitivePure(realm: Realm, input: Value) {\n  return GetToPrimitivePureResultType(realm, input) !== undefined;\n}\n\n// ECMA262 7.1.1\nexport function OrdinaryToPrimitive(realm: Realm, input: ObjectValue, hint: \"string\" | \"number\"): PrimitiveValue {\n  let methodNames;\n\n  // 1. Assert: Type(O) is Object.\n  invariant(input instanceof ObjectValue, \"Expected object\");\n\n  // 2. Assert: Type(hint) is String and its value is either \"string\" or \"number\".\n  invariant(hint === \"string\" || hint === \"number\", \"Expected string or number hint\");\n\n  // 3. If hint is \"string\", then\n  if (hint === \"string\") {\n    // a. Let methodNames be « \"toString\", \"valueOf\" ».\n    methodNames = [\"toString\", \"valueOf\"];\n  } else { // 4. Else,\n    // a. Let methodNames be « \"valueOf\", \"toString\" ».\n    methodNames = [\"valueOf\", \"toString\"];\n  }\n\n  // 5. For each name in methodNames in List order, do\n  for (let name of methodNames) {\n    // a. Let method be ? Get(O, name).\n    let method = Get(realm, input, new StringValue(realm, name));\n\n    // b. If IsCallable(method) is true, then\n    if (IsCallable(realm, method)) {\n      // i. Let result be ? Call(method, O).\n      let result = Call(realm, method, input).throwIfNotConcrete();\n\n      // ii. If Type(result) is not Object, return result.\n      if (!(result instanceof ObjectValue)) {\n        invariant(result instanceof PrimitiveValue);\n        return result;\n      }\n    }\n  }\n\n  // 6. Throw a TypeError exception.\n  throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"can't turn to primitive\");\n}\n\n// ECMA262 7.1.12\nexport function ToString(realm: Realm, val: string | ConcreteValue): string {\n  if (typeof val === \"string\") {\n    return val;\n  } else if (val instanceof StringValue) {\n    return val.value;\n  } else if (val instanceof NumberValue) {\n    return val.value + \"\";\n  } else if (val instanceof UndefinedValue) {\n    return \"undefined\";\n  } else if (val instanceof NullValue) {\n    return \"null\";\n  } else if (val instanceof SymbolValue) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  } else if (val instanceof BooleanValue) {\n    return val.value ? \"true\" : \"false\";\n  } else if (val instanceof ObjectValue) {\n    let primValue = ToPrimitive(realm, val, \"string\");\n    return ToString(realm, primValue);\n  } else {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to string\");\n  }\n}\n\nexport function ToStringPartial(realm: Realm, val: string | Value): string {\n  return ToString(realm, typeof val === \"string\" ? val : val.throwIfNotConcrete());\n}\n\n// ECMA262 7.1.2\nexport function ToBoolean(realm: Realm, val: ConcreteValue): boolean {\n  if (val instanceof BooleanValue) {\n    return val.value;\n  } else if (val instanceof UndefinedValue) {\n    return false;\n  } else if (val instanceof NullValue) {\n    return false;\n  } else if (val instanceof NumberValue) {\n    return val.value !== 0 && !isNaN(val.value);\n  } else if (val instanceof StringValue) {\n    return val.value.length > 0;\n  } else if (val instanceof ObjectValue) {\n    return true;\n  } else if (val instanceof SymbolValue) {\n    return true;\n  } else {\n    invariant(!(val instanceof AbstractValue));\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to a boolean\");\n  }\n}\n\nexport function ToBooleanPartial(realm: Realm, val: Value): boolean {\n  if (!val.mightNotBeObject()) return true;\n  return ToBoolean(realm, val.throwIfNotConcrete());\n}\n\n\n// ECMA262 7.1.14\nexport function ToPropertyKey(realm: Realm, arg: ConcreteValue): SymbolValue | string /* but not StringValue */ {\n  // 1. Let key be ? ToPrimitive(argument, hint String).\n  let key = ToPrimitive(realm, arg, \"string\");\n\n  // 2. If Type(key) is Symbol, then\n  if (key instanceof SymbolValue) {\n    // a. Return key.\n    return key;\n  }\n\n  // 3. Return ! ToString(key).\n  return ToString(realm, key);\n}\n\nexport function ToPropertyKeyPartial(realm: Realm, arg: Value): AbstractValue | SymbolValue | string /* but not StringValue */ {\n  if (arg instanceof ConcreteValue) return ToPropertyKey(realm, arg);\n  if (arg.mightNotBeString()) arg.throwIfNotConcrete();\n  return arg;\n}\n\n// ECMA262 7.1.16\nexport function CanonicalNumericIndexString(realm: Realm, argument: StringValue): number | void {\n  // 1. Assert: Type(argument) is String.\n  invariant(argument instanceof StringValue);\n\n  // 2. If argument is \"-0\", return −0.\n  if (argument.value === \"-0\") return -0;\n\n  // 3. Let n be ToNumber(argument).\n  let n = ToNumber(realm, argument);\n\n  // 4. If SameValue(ToString(n), argument) is false, return undefined.\n  if (SameValue(realm, new StringValue(realm, ToString(realm, new NumberValue(realm, n))), argument) === false) return undefined;\n\n  // 5. Return n.\n  return n;\n}\n"]}