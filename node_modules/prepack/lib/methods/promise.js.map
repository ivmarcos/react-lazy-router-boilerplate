{"version":3,"sources":["../../src/methods/promise.js"],"names":["EnqueueJob","NewPromiseCapability","PerformPromiseAll","PerformPromiseRace","PerformPromiseThen","PromiseReactionJob","CreateResolvingFunctions","FulfillPromise","RejectPromise","TriggerPromiseReactions","HostPromiseRejectionTracker","PromiseResolveThenableJob","realm","queueName","job","args","C","createErrorThrowCompletion","intrinsics","TypeError","promiseCapability","promise","undefined","resolve","reject","executor","context","$Capability","mightBeUndefined","throwIfNotConcrete","createResolveElementFunction","resolveElement","x","alreadyCalled","$AlreadyCalled","value","myIndex","$Index","values","$Values","Array","$Capabilities","remainingElementsCount","$RemainingElements","valuesArray","iteratorRecord","constructor","resultCapability","index","next","$Iterator","e","$Done","nextValue","push","nextPromise","onFulfilled","onRejected","fulfillReaction","capabilities","handler","rejectReaction","$PromiseState","$PromiseFulfillReactions","$PromiseRejectReactions","$PromiseResult","reason","$PromiseIsHandled","reaction","argument","createResolveFunction","resolution","$Promise","alreadyResolved","$AlreadyResolved","selfResolutionError","then","thenAction","createRejectFunction","reactions","operation","promiseToResolve","thenable"],"mappings":"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","file":"promise.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { ResolvingFunctions, PromiseCapability, PromiseReaction } from \"../types.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { Value, ObjectValue, StringValue, NativeFunctionValue, FunctionValue } from \"../values/index.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { Get } from \"../methods/get.js\";\nimport { Invoke, Call } from \"../methods/call.js\";\nimport { CreateArrayFromList } from \"../methods/create.js\";\nimport { IsCallable, IsConstructor, IsPromise } from \"../methods/is.js\";\nimport { IteratorStep, IteratorValue } from \"../methods/iterator.js\";\nimport { ThrowIfInternalSlotNotWritable } from \"../methods/properties.js\";\nimport invariant from \"../invariant.js\";\n\n\n// ECMA262 8.4.1\nexport function EnqueueJob(realm: Realm, queueName: string, job: Function, args: Array<any>) {\n}\n\n// ECMA262 25.4.1.5\nexport function NewPromiseCapability(realm: Realm, C: Value): PromiseCapability {\n  // 1. If IsConstructor(C) is false, throw a TypeError exception.\n  if (IsConstructor(realm, C) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n  }\n  invariant(C instanceof ObjectValue);\n\n  // 2. NOTE C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 25.4.3.1).\n\n  // 3. Let promiseCapability be a new PromiseCapability { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.\n  let promiseCapability = {\n    promise: realm.intrinsics.undefined,\n    resolve: realm.intrinsics.undefined,\n    reject: realm.intrinsics.undefined\n  };\n\n  // 4. Let executor be a new built-in function object as defined in GetCapabilitiesExecutor Functions (25.4.1.5.1).\n  let executor = new NativeFunctionValue(realm, undefined, undefined, 2, (context, [resolve, reject]) => {\n    // 1. Assert: F has a [[Capability]] internal slot whose value is a PromiseCapability Record.\n    invariant(executor.$Capability, \"F has a [[Capability]] internal slot whose value is a PromiseCapability Record\");\n\n    // 2. Let promiseCapability be the value of F's [[Capability]] internal slot.\n    invariant(promiseCapability === executor.$Capability);\n\n    // 3. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.\n    if (!promiseCapability.resolve.mightBeUndefined()) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"promiseCapability.[[Resolve]] is not undefined\");\n    }\n    promiseCapability.resolve.throwIfNotConcrete();\n\n    // 4. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.\n    if (!promiseCapability.reject.mightBeUndefined()) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"promiseCapability.[[Reject]] is not undefined\");\n    }\n    promiseCapability.reject.throwIfNotConcrete();\n\n    // 5. Set promiseCapability.[[Resolve]] to resolve.\n    promiseCapability.resolve = resolve;\n\n    // 6. Set promiseCapability.[[Reject]] to reject.\n    promiseCapability.reject = reject;\n\n    // 7. Return undefined.\n    return realm.intrinsics.undefined;\n  }, false);\n\n  // 5. Set the [[Capability]] internal slot of executor to promiseCapability.\n  executor.$Capability = promiseCapability;\n\n  // 6. Let promise be ? Construct(C, « executor »).\n  let promise = Construct(realm, C, [executor]);\n\n  // 7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.\n  if (IsCallable(realm, promiseCapability.resolve) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(promiseCapability.[[Resolve]]) is false\");\n  }\n\n  // 8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.\n  if (IsCallable(realm, promiseCapability.reject) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(promiseCapability.[[Reject]]) is false\");\n  }\n\n  // 9. Set promiseCapability.[[Promise]] to promise.\n  promiseCapability.promise = promise;\n\n  // 10. Return promiseCapability.\n  return promiseCapability;\n}\n\n// ECMA262 25.4.4.1.1j\nfunction createResolveElementFunction(realm) {\n  let resolveElement = new NativeFunctionValue(realm, undefined, undefined, 1, (context, [x]) => {\n\n    // 1. Let alreadyCalled be the value of F's [[AlreadyCalled]] internal slot.\n    let alreadyCalled = resolveElement.$AlreadyCalled; invariant(alreadyCalled);\n\n    // 2. If alreadyCalled.[[Value]] is true, return undefined.\n    if (alreadyCalled.value === true) {\n      return realm.intrinsics.undefined;\n    }\n\n    // 3. Set alreadyCalled.[[Value]] to true.\n    alreadyCalled.value = true;\n\n    // 4. Let index be the value of F's [[Index]] internal slot.\n    let myIndex = resolveElement.$Index; invariant(typeof myIndex === \"number\");\n\n    // 5. Let values be the value of F's [[Values]] internal slot.\n    let values = resolveElement.$Values; invariant(values instanceof Array);\n\n    // 6. Let promiseCapability be the value of F's [[Capabilities]] internal slot.\n    let promiseCapability = resolveElement.$Capabilities; invariant(promiseCapability);\n\n    // 7. Let remainingElementsCount be the value of F's [[RemainingElements]] internal slot.\n    let remainingElementsCount = resolveElement.$RemainingElements; invariant(remainingElementsCount);\n\n    // 8. Set values[index] to x.\n    values[myIndex] = x;\n\n    // 9. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n    remainingElementsCount.value = remainingElementsCount.value - 1;\n\n    // 10. If remainingElementsCount.[[Value]] is 0, then\n    if (remainingElementsCount.value === 0) {\n      // a. Let valuesArray be CreateArrayFromList(values).\n      let valuesArray = CreateArrayFromList(realm, values);\n\n      // b. Return ? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »).\n      Call(realm, promiseCapability.resolve, realm.intrinsics.undefined, [valuesArray]);\n    }\n\n    // 11. Return undefined.\n    return realm.intrinsics.undefined;\n  }, false);\n  return resolveElement;\n}\n\n// ECMA262 25.4.4.1.1\nexport function PerformPromiseAll(realm: Realm, iteratorRecord: { $Iterator: ObjectValue, $Done: boolean }, constructor: FunctionValue, resultCapability: PromiseCapability): Value {\n  // 1. Assert: constructor is a constructor function.\n  invariant(constructor instanceof FunctionValue && IsConstructor(realm, constructor), \"constructor is a constructor function\");\n\n  // 2. Assert: resultCapability is a PromiseCapability record.\n  resultCapability;\n\n  // 3. Let values be a new empty List.\n  let values = [];\n\n  // 4. Let remainingElementsCount be a new Record { [[Value]]: 1 }.\n  let remainingElementsCount = { value: 1 };\n\n  // 5. Let index be 0.\n  let index = 0;\n\n  // 6. Repeat\n  while (true) {\n    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n    let next;\n    try {\n      next = IteratorStep(realm, iteratorRecord.$Iterator);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // c. ReturnIfAbrupt(next).\n      throw e;\n    }\n\n    // d. If next is false, then\n    if (next === false) {\n      // i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord.$Done = true;\n\n      // ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n      remainingElementsCount.value = remainingElementsCount.value - 1;\n\n      // iii. If remainingElementsCount.[[Value]] is 0, then\n      if (remainingElementsCount.value === 0) {\n        // 1. Let valuesArray be CreateArrayFromList(values).\n        let valuesArray = CreateArrayFromList(realm, values);\n\n        // 2. Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).\n        Call(realm, resultCapability.resolve, realm.intrinsics.undefined, [valuesArray]);\n      }\n\n      // iv. Return resultCapability.[[Promise]].\n      return resultCapability.promise;\n    }\n\n    // e. Let nextValue be IteratorValue(next).\n    let nextValue;\n    try {\n      nextValue = IteratorValue(realm, next);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // g. ReturnIfAbrupt(nextValue).\n      throw e;\n    }\n\n    // h. Append undefined to values.\n    values.push(realm.intrinsics.undefined);\n\n    // i. Let nextPromise be ? Invoke(constructor, \"resolve\", « nextValue »).\n    let nextPromise = Invoke(realm, constructor, \"resolve\", [nextValue]);\n\n    // j. Let resolveElement be a new built-in function object as defined in Promise.all Resolve Element Functions.\n    let resolveElement = createResolveElementFunction(realm);\n\n    // k. Set the [[AlreadyCalled]] internal slot of resolveElement to a new Record {[[Value]]: false }.\n    resolveElement.$AlreadyCalled = { value: false };\n\n    // l. Set the [[Index]] internal slot of resolveElement to index.\n    resolveElement.$Index = index;\n\n    // m. Set the [[Values]] internal slot of resolveElement to values.\n    resolveElement.$Values = values;\n\n    // n. Set the [[Capabilities]] internal slot of resolveElement to resultCapability.\n    resolveElement.$Capabilities = resultCapability;\n\n    // o. Set the [[RemainingElements]] internal slot of resolveElement to remainingElementsCount.\n    resolveElement.$RemainingElements = remainingElementsCount;\n\n    // p. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.\n    remainingElementsCount.value = remainingElementsCount.value + 1;\n\n    // q. Perform ? Invoke(nextPromise, \"then\", « resolveElement, resultCapability.[[Reject]] »).\n    Invoke(realm, nextPromise, \"then\", [resolveElement, resultCapability.reject]);\n\n    // r. Set index to index + 1.\n    index = index + 1;\n  }\n  invariant(false);\n}\n\n// ECMA262 25.4.4.3.1\nexport function PerformPromiseRace(realm: Realm, iteratorRecord: { $Iterator: ObjectValue, $Done: boolean }, resultCapability: PromiseCapability, C: ObjectValue): ObjectValue {\n  // 1. Assert: constructor is a constructor function.\n  invariant(IsConstructor(realm, C), \"constructor is a constructor function\");\n\n  // 2. Assert: resultCapability is a PromiseCapability Record.\n  resultCapability;\n\n  // 3. Repeat\n  while (true) {\n    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n    let next;\n    try {\n      next = IteratorStep(realm, iteratorRecord.$Iterator);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // c. ReturnIfAbrupt(next).\n      throw e;\n    }\n\n    // d. If next is false, then\n    if (next === false) {\n      // i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord.$Done = true;\n\n      // ii. Return resultCapability.[[Promise]].\n      invariant(resultCapability.promise instanceof ObjectValue);\n      return resultCapability.promise;\n    }\n\n    // e. Let nextValue be IteratorValue(next).\n    let nextValue;\n    try {\n      nextValue = IteratorValue(realm, next);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // g. ReturnIfAbrupt(nextValue).\n      throw e;\n    }\n\n    // h. Let nextPromise be ? Invoke(C, \"resolve\", « nextValue »).\n    let nextPromise = Invoke(realm, C, \"resolve\", [nextValue]);\n\n    // i. Perform ? Invoke(nextPromise, \"then\", « resultCapability.[[Resolve]], resultCapability.[[Reject]] »).\n    Invoke(realm, nextPromise, \"then\", [resultCapability.resolve, resultCapability.reject]);\n  }\n  invariant(false);\n}\n\n// ECMA262 25.4.5.3.1\nexport function PerformPromiseThen(realm: Realm, promise: ObjectValue, onFulfilled: Value, onRejected: Value, resultCapability: PromiseCapability): ObjectValue {\n  // 1. Assert: IsPromise(promise) is true.\n  invariant(IsPromise(realm, promise), \"IsPromise(promise) is true\");\n\n  // 2. Assert: resultCapability is a PromiseCapability record.\n  resultCapability;\n\n  // 3. If IsCallable(onFulfilled) is false, then\n  if (IsCallable(realm, onFulfilled) === false) {\n    // a. Let onFulfilled be \"Identity\".\n    onFulfilled = new StringValue(realm, \"Identity\");\n  }\n\n  // 4. If IsCallable(onRejected) is false, then\n  if (IsCallable(realm, onRejected)) {\n    // a. Let onRejected be \"Thrower\".\n    onRejected = new StringValue(realm, \"Thrower\");\n  }\n\n  // 5. Let fulfillReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onFulfilled }.\n  let fulfillReaction = { capabilities: resultCapability, handler: onFulfilled };\n\n  // 6. Let rejectReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onRejected}.\n  let rejectReaction = { capabilities: resultCapability, handler: onRejected };\n\n  // 7. If the value of promise's [[PromiseState]] internal slot is \"pending\", then\n  if (promise.$PromiseState === \"pending\") {\n    // a. Append fulfillReaction as the last element of the List that is the value of promise's [[PromiseFulfillReactions]] internal slot.\n    ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseFulfillReactions\"); invariant(promise.$PromiseFulfillReactions); promise.$PromiseFulfillReactions.push(fulfillReaction);\n    // b. Append rejectReaction as the last element of the List that is the value of promise's [[PromiseRejectReactions]] internal slot.\n    ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseRejectReactions\"); invariant(promise.$PromiseRejectReactions); promise.$PromiseRejectReactions.push(rejectReaction);\n  } else if (promise.$PromiseState === \"fulfilled\") { // 8. Else if the value of promise's [[PromiseState]] internal slot is \"fulfilled\", then\n    // a. Let value be the value of promise's [[PromiseResult]] internal slot.\n    let value = promise.$PromiseResult;\n    // b. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « fulfillReaction, value »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [fulfillReaction, value]);\n  } else { // 9. Else,\n    // a. Assert: The value of promise's [[PromiseState]] internal slot is \"rejected\".\n    invariant(promise.$PromiseState === \"rejected\");\n\n    // b. Let reason be the value of promise's [[PromiseResult]] internal slot.\n    let reason = promise.$PromiseResult;\n\n    // c. If the value of promise's [[PromiseIsHandled]] internal slot is false, perform HostPromiseRejectionTracker(promise, \"handle\").\n    if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, \"handle\");\n\n    // d. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « rejectReaction, reason »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [rejectReaction, reason]);\n  }\n\n  // 10. Set promise's [[PromiseIsHandled]] internal slot to true.\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseIsHandled\").$PromiseIsHandled = true;\n\n  // 11. Return resultCapability.[[Promise]].\n  invariant(resultCapability.promise instanceof ObjectValue);\n  return resultCapability.promise;\n}\n\n// ECMA262 25.4.2.1\nexport function PromiseReactionJob(realm: Realm, reaction: Function, argument: Value): Value {\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 25.4.1.3.2\nfunction createResolveFunction(realm) {\n  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).\n  let resolve = new NativeFunctionValue(realm, undefined, undefined, 1, (context, [resolution]) => {\n    // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.\n    invariant(resolve.$Promise instanceof ObjectValue, \"F has a [[Promise]] internal slot whose value is an Object\");\n\n    // 2. Let promise be the value of F's [[Promise]] internal slot.\n    let promise = resolve.$Promise;\n\n    // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.\n    let alreadyResolved = resolve.$AlreadyResolved; invariant(alreadyResolved !== undefined);\n\n    // 4. If alreadyResolved.[[Value]] is true, return undefined.\n    if (alreadyResolved.value === true) return realm.intrinsics.undefined;\n\n    // 5. Set alreadyResolved.[[Value]] to true.\n    alreadyResolved.value = true;\n\n    // 6. If SameValue(resolution, promise) is true, then\n    if (SameValue(realm, resolution.throwIfNotConcrete(), promise)) {\n      // a. Let selfResolutionError be a newly created TypeError object.\n      let selfResolutionError = Construct(realm, realm.intrinsics.TypeError, [new StringValue(realm, \"resolve\")]);\n\n      // b. Return RejectPromise(promise, selfResolutionError).\n      return RejectPromise(realm, promise, selfResolutionError);\n    }\n    // 7. If Type(resolution) is not Object, then\n    if (!(resolution instanceof ObjectValue)) {\n      // a. Return FulfillPromise(promise, resolution).\n      return FulfillPromise(realm, promise, resolution);\n    }\n\n    // 8. Let then be Get(resolution, \"then\").\n    let then;\n    try {\n      then = Get(realm, resolution, \"then\");\n    } catch (e) { // 9. If then is an abrupt completion, then\n      if (e instanceof AbruptCompletion) {\n        // a. Return RejectPromise(promise, then.[[Value]]).\n        return RejectPromise(realm, promise, e);\n      } else\n        throw e;\n    }\n\n    // 10. Let thenAction be then.[[Value]].\n    let thenAction = then;\n\n    // 11. If IsCallable(thenAction) is false, then\n    if (IsCallable(realm, thenAction)) {\n      // a. Return FulfillPromise(promise, resolution).\n      return FulfillPromise(realm, promise, resolution);\n    }\n\n    // 12. Perform EnqueueJob(\"PromiseJobs\", PromiseResolveThenableJob, « promise, resolution, thenAction »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseResolveThenableJob, [promise, resolution, thenAction]);\n\n    // 13. Return undefined.\n    return realm.intrinsics.undefined;\n  }, false);\n  return resolve;\n}\n\n// ECMA262 25.4.1.3.1\nfunction createRejectFunction(realm) {\n  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).\n  let reject = new NativeFunctionValue(realm, undefined, undefined, 1, (context, [reason]) => {\n    // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.\n    invariant(reject.$Promise instanceof ObjectValue, \"F has a [[Promise]] internal slot whose value is an Object\");\n\n    // 2. Let promise be the value of F's [[Promise]] internal slot.\n    let promise = reject.$Promise;\n\n    // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.\n    let alreadyResolved = reject.$AlreadyResolved; invariant(alreadyResolved !== undefined);\n\n    // 4. If alreadyResolved.[[Value]] is true, return undefined.\n    if (alreadyResolved.value === true) return realm.intrinsics.undefined;\n\n    // 5. Set alreadyResolved.[[Value]] to true.\n    alreadyResolved.value = true;\n\n    // 6. Return RejectPromise(promise, reason).\n    return RejectPromise(realm, promise, reason);\n  }, false);\n  return reject;\n}\n\n// ECMA262 25.4.1.3\nexport function CreateResolvingFunctions(realm: Realm, promise: ObjectValue): ResolvingFunctions {\n  // 1. Let alreadyResolved be a new Record { [[Value]]: false }.\n  let alreadyResolved = { value: false };\n\n  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).\n  let resolve = createResolveFunction(realm);\n\n  // 3. Set the [[Promise]] internal slot of resolve to promise.\n  resolve.$Promise = promise;\n\n  // 4. Set the [[AlreadyResolved]] internal slot of resolve to alreadyResolved.\n  resolve.$AlreadyResolved = alreadyResolved;\n\n  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).\n  let reject = createRejectFunction(realm);\n\n  // 6. Set the [[Promise]] internal slot of reject to promise.\n  reject.$Promise = promise;\n\n  // 7. Set the [[AlreadyResolved]] internal slot of reject to alreadyResolved.\n  reject.$AlreadyResolved = alreadyResolved;\n\n  // 8. Return a new Record { [[Resolve]]: resolve, [[Reject]]: reject }.\n  return { resolve: resolve, reject: reject };\n}\n\n// ECMA262 25.4.1.4\nexport function FulfillPromise(realm: Realm, promise: ObjectValue, value: Value): Value {\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  invariant(promise.$PromiseState === \"pending\");\n\n  // 2. Let reactions be promise.[[PromiseFulfillReactions]].\n  let reactions = promise.$PromiseFulfillReactions; invariant(reactions);\n\n  // 3. Set promise.[[PromiseResult]] to value.\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseResult\").$PromiseResult = value;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseFulfillReactions\").$PromiseFulfillReactions = undefined;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseRejectReactions\").$PromiseRejectReactions = undefined;\n\n  // 6. Set promise.[[PromiseState]] to \"fulfilled\".\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseState\").$PromiseState = \"fulfilled\";\n\n  // 7. Return TriggerPromiseReactions(reactions, value).\n  return TriggerPromiseReactions(realm, reactions, value);\n}\n\n// ECMA262 25.4.1.7\nexport function RejectPromise(realm: Realm, promise: ObjectValue, reason: Value): Value {\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  invariant(promise.$PromiseState === \"pending\");\n\n  // 2. Let reactions be promise.[[PromiseRejectReactions]].\n  let reactions = promise.$PromiseFulfillReactions; invariant(reactions);\n\n  // 3. Set promise.[[PromiseResult]] to reason.\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseResult\").$PromiseResult = reason;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseFulfillReactions\").$PromiseFulfillReactions = undefined;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseRejectReactions\").$PromiseRejectReactions = undefined;\n\n  // 6. Set promise.[[PromiseState]] to \"rejected\".\n  ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseState\").$PromiseState = \"rejected\";\n\n  // 7. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, \"reject\").\n  if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, \"reject\");\n\n  // 8. Return TriggerPromiseReactions(reactions, reason).\n  return TriggerPromiseReactions(realm, reactions, reason);\n}\n\n// ECMA262 25.4.1.8\nexport function TriggerPromiseReactions(realm: Realm, reactions: Array<PromiseReaction>, argument: Value) {\n  // 1. Repeat for each reaction in reactions, in original insertion order\n  for (let reaction of reactions) {\n    // a. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « reaction, argument »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [reaction, argument]);\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 25.4.1.9\nexport function HostPromiseRejectionTracker(realm: Realm, promise: ObjectValue, operation: \"reject\" | \"handle\") {\n}\n\n// ECMA262 25.4.2.2\nexport function PromiseResolveThenableJob(realm: Realm, promiseToResolve: ObjectValue, thenable: Value, then: Value) {\n\n}\n"]}