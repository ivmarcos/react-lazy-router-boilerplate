{"version":3,"sources":["../../src/methods/call.js"],"names":["ArgumentListEvaluation","Invoke","EvaluateCall","PrepareForOrdinaryCall","OrdinaryCallBindThis","OrdinaryCallEvaluateBody","EvaluateDirectCall","PrepareForTailCall","Call","t","realm","strictCode","env","argNodes","Array","isArray","args","node_","type","node","list","spreadRef","evaluate","argument","spreadObj","iterator","next","nextArg","push","ref","expr","expressions","length","templateLiteral","siteObj","firstSubRef","firstSub","restSub","slice","map","constructor","V","P","argumentsList","func","thisValue","refEnv","WithBaseObject","intrinsics","undefined","F","newTarget","callerContext","getRunningContext","calleeContext","createExecutionContext","setFunction","setCaller","calleeRealm","ScriptOrModule","$ScriptOrModule","localEnv","lexicalEnvironment","variableEnvironment","suspend","pushContext","thisArgument","thisMode","$ThisMode","$Realm","globalEnv","$GlobalEnv","globalEnvRec","environmentRecord","$GlobalThisValue","envRec","BindThisValue","callCallback","GetThisBinding","$NewTarget","err","Error","$FunctionKind","G","$GeneratorState","$GeneratorContext","code","$ECMAScriptCode","c","evaluateAbstractCompletion","$Strict","e","get_captured_effects","stop_effect_capture","_c","_g","b","p","_o","restoreBindings","restoreProperties","apply_effects","createIntrospectionErrorThrowCompletion","joinCondition","joinedEffects","tailPosition","argList","getType","fullArgs","concat","deriveAbstract","topVal","nodes","fun_args","callExpression","throwIfNotConcrete","createErrorThrowCompletion","TypeError","result","leafContext","popContext","argsList","$Call"],"mappings":"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","file":"call.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { LexicalEnvironment, Reference, EnvironmentRecord, GlobalEnvironmentRecord } from \"../environment.js\";\nimport { Realm, ExecutionContext } from \"../realm.js\";\nimport Value from \"../values/Value.js\";\nimport { FunctionValue, ObjectValue, NullValue, UndefinedValue, NativeFunctionValue, AbstractObjectValue, AbstractValue } from \"../values/index.js\";\nimport {\n  GetBase,\n  GetValue,\n  ToObjectPartial,\n  IsCallable,\n  IsPropertyReference,\n  IsPropertyKey,\n  FunctionDeclarationInstantiation,\n  NewFunctionEnvironment,\n  GetIterator,\n  IteratorStep,\n  IteratorValue,\n  HasSomeCompatibleType,\n  joinEffectsAndRemoveNestedReturnCompletions,\n} from \"./index.js\";\nimport { GeneratorStart } from \"../methods/generator.js\";\nimport { OrdinaryCreateFromConstructor } from \"../methods/create.js\";\nimport { ReturnCompletion, AbruptCompletion, ComposedAbruptCompletion, JoinedAbruptCompletions, PossiblyNormalCompletion } from \"../completions.js\";\nimport { GetTemplateObject, GetV, GetThisValue } from \"../methods/get.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNode, BabelNodeExpression, BabelNodeSpreadElement, BabelNodeTemplateLiteral } from \"babel-types\";\nimport * as t from \"babel-types\";\n\n// ECMA262 12.3.6.1\nexport function ArgumentListEvaluation(realm: Realm, strictCode: boolean, env: LexicalEnvironment, argNodes: Array<BabelNode> | BabelNodeTemplateLiteral): Array<Value> {\n  if (Array.isArray(argNodes)) {\n    let args = [];\n    for (let node_ of ((argNodes: any): Array<BabelNode>)) {\n      if (node_.type === \"SpreadElement\") {\n        let node = ((node_: any): BabelNodeSpreadElement);\n        // 1. Let list be a new empty List.\n        let list = args;\n\n        // 2. Let spreadRef be the result of evaluating AssignmentExpression.\n        let spreadRef = env.evaluate(node.argument, strictCode);\n\n        // 3. Let spreadObj be ? GetValue(spreadRef).\n        let spreadObj = GetValue(realm, spreadRef);\n\n        // 4. Let iterator be ? GetIterator(spreadObj).\n        let iterator = GetIterator(realm, spreadObj);\n\n        // 5. Repeat\n        while (true) {\n          // a. Let next be ? IteratorStep(iterator).\n          let next = IteratorStep(realm, iterator);\n\n          // b. If next is false, return list.\n          if (!next) {\n            break;\n          }\n\n          // c. Let nextArg be ? IteratorValue(next).\n          let nextArg = IteratorValue(realm, next);\n\n          // d. Append nextArg as the last element of list.\n          list.push(nextArg);\n        }\n      } else {\n        let ref = env.evaluate(node_, strictCode);\n        let expr = GetValue(realm, ref);\n        args.push(expr);\n      }\n    }\n    return args;\n  } else {\n    let node = ((argNodes: any): BabelNodeTemplateLiteral);\n    if (node.expressions.length === 0) {\n      // 1. Let templateLiteral be this TemplateLiteral.\n      let templateLiteral = node;\n\n      // 2. Let siteObj be GetTemplateObject(templateLiteral).\n      let siteObj = GetTemplateObject(realm, templateLiteral);\n\n      // 3. Return a List containing the one element which is siteObj.\n      return [siteObj];\n    } else {\n      // 1. Let templateLiteral be this TemplateLiteral.\n      let templateLiteral = node;\n\n      // 2. Let siteObj be GetTemplateObject(templateLiteral).\n      let siteObj = GetTemplateObject(realm, templateLiteral);\n\n      // 3. Let firstSubRef be the result of evaluating Expression.\n      let firstSubRef = env.evaluate(node.expressions[0], strictCode);\n\n      // 4. Let firstSub be ? GetValue(firstSubRef).\n      let firstSub = GetValue(realm, firstSubRef);\n\n      // 5. Let restSub be SubstitutionEvaluation of TemplateSpans.\n      let restSub = node.expressions.slice(1, node.expressions.length).map((expr) => {\n        return GetValue(realm, env.evaluate(expr, strictCode));\n      });\n\n      // 6. ReturnIfAbrupt(restSub).\n\n      // 7. Assert: restSub is a List.\n      invariant(restSub.constructor === Array, \"restSub is a List\");\n\n      // 8. Return a List whose first element is siteObj, whose second elements is firstSub, and whose subsequent elements are the elements of restSub, in order. restSub may contain no elements.\n      return [siteObj, firstSub, ...restSub];\n    }\n  }\n}\n\n// ECMA262 7.3.18\nexport function Invoke(realm: Realm, V: Value, P: PropertyKeyValue, argumentsList?: Array<Value>): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. If argumentsList was not passed, let argumentsList be a new empty List.\n  if (!argumentsList) argumentsList = [];\n\n  // 3. Let func be ? GetV(V, P).\n  let func = GetV(realm, V, P);\n\n  // 4. Return ? Call(func, V, argumentsList).\n  return Call(realm, func, V, argumentsList);\n}\n\n// ECMA262 12.3.4.2\nexport function EvaluateCall(realm: Realm, strictCode: boolean, env: LexicalEnvironment, ref: Reference | Value, args: Array<BabelNode> | BabelNodeTemplateLiteral): Value {\n  let thisValue;\n\n  // 1. Let func be ? GetValue(ref).\n  let func = GetValue(realm, ref);\n\n  // 2. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else { // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else { // 3. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 4. Return ? EvaluateDirectCall(func, thisValue, arguments, tailPosition).\n  return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, args);\n}\n\n// ECMA262 9.2.1.1\nexport function PrepareForOrdinaryCall(realm: Realm, F: FunctionValue, newTarget?: ObjectValue): ExecutionContext {\n  // 1. Assert: Type(newTarget) is Undefined or Object.\n  invariant(newTarget === undefined || newTarget instanceof ObjectValue, \"expected undefined or object value for new target\");\n\n  // 2. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 3. Let calleeContext be a new ECMAScript code execution context.\n  let calleeContext = realm.createExecutionContext();\n\n  // 4. Set the Function of calleeContext to F.\n  calleeContext.setFunction(F);\n  calleeContext.setCaller(realm.getRunningContext());\n\n  // 5. Let calleeRealm be the value of F's [[Realm]] internal slot.\n  let calleeRealm = realm;\n\n  // 6. Set the Realm of calleeContext to calleeRealm.\n  calleeContext.realm = calleeRealm;\n\n  // 7. Set the ScriptOrModule of calleeContext to the value of F's [[ScriptOrModule]] internal slot.\n  calleeContext.ScriptOrModule = F.$ScriptOrModule;\n\n  // 8. Let localEnv be NewFunctionEnvironment(F, newTarget).\n  let localEnv = NewFunctionEnvironment(realm, F, newTarget);\n\n  // 9. Set the LexicalEnvironment of calleeContext to localEnv.\n  calleeContext.lexicalEnvironment = localEnv;\n\n  // 10. Set the VariableEnvironment of calleeContext to localEnv.\n  calleeContext.variableEnvironment = localEnv;\n\n  // 11. If callerContext is not already suspended, suspend callerContext.\n  callerContext.suspend();\n\n  // 12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.\n  realm.pushContext(calleeContext);\n\n  // 13. NOTE Any exception objects produced after this point are associated with calleeRealm.\n\n  // 14. Return calleeContext.\n  return calleeContext;\n}\n\n// ECMA262 9.2.1.2\nexport function OrdinaryCallBindThis(realm: Realm, F: FunctionValue, calleeContext: ExecutionContext, thisArgument: Value): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n  // 1. Let thisMode be the value of F's [[ThisMode]] internal slot.\n  let thisMode = F.$ThisMode;\n\n  // 2. If thisMode is lexical, return NormalCompletion(undefined).\n  if (thisMode === \"lexical\") return realm.intrinsics.undefined;\n\n  // 3. Let calleeRealm be the value of F's [[Realm]] internal slot.\n  let calleeRealm = F.$Realm;\n\n  // 4. Let localEnv be the LexicalEnvironment of calleeContext.\n  let localEnv = calleeContext.lexicalEnvironment;\n\n  let thisValue;\n  // 5. If thisMode is strict, let thisValue be thisArgument.\n  if (thisMode === \"strict\" || F instanceof NativeFunctionValue) {\n    thisValue = (thisArgument: any);\n  } else { // 6. Else,\n    // a. If thisArgument is null or undefined, then\n    if (HasSomeCompatibleType(realm, thisArgument, NullValue, UndefinedValue)) {\n      // i. Let globalEnv be calleeRealm.[[GlobalEnv]].\n      let globalEnv = realm.$GlobalEnv;\n\n      // ii. Let globalEnvRec be globalEnv's EnvironmentRecord.\n      let globalEnvRec = globalEnv.environmentRecord;\n      invariant(globalEnvRec instanceof GlobalEnvironmentRecord);\n\n      // iii. Let thisValue be globalEnvRec.[[GlobalThisValue]].\n      thisValue = globalEnvRec.$GlobalThisValue;\n    } else { //  b. Else,\n      // i. Let thisValue be ! ToObject(thisArgument).\n      thisValue = ToObjectPartial(calleeRealm, thisArgument);\n\n      // ii. NOTE ToObject produces wrapper objects using calleeRealm.\n    }\n  }\n\n  // 7. Let envRec be localEnv's EnvironmentRecord.\n  invariant(localEnv !== undefined);\n  let envRec = localEnv.environmentRecord;\n\n  // 8. Assert: The next step never returns an abrupt completion because envRec.[[ThisBindingStatus]] is not \"initialized\".\n\n  // 9. Return envRec.BindThisValue(thisValue).\n  return envRec.BindThisValue(thisValue);\n}\n\n// ECMA262 9.2.1.3\nexport function OrdinaryCallEvaluateBody(realm: Realm, F: FunctionValue, argumentsList: Array<Value>): Reference | Value | AbruptCompletion {\n  if (F instanceof NativeFunctionValue) {\n    let env = realm.getRunningContext().lexicalEnvironment;\n    try {\n      return F.callCallback(env.environmentRecord.GetThisBinding(), argumentsList, env.environmentRecord.$NewTarget);\n    } catch (err) {\n      if (err instanceof AbruptCompletion) {\n        return err;\n      } else  if (err instanceof Error) {\n        throw err;\n      } else {\n        throw new Error(err);\n      }\n    }\n  } else if (F.$FunctionKind === \"generator\") {\n    // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).\n    FunctionDeclarationInstantiation(realm, F, argumentsList);\n\n    // 2. Let G be ? OrdinaryCreateFromConstructor(functionObject, \"%GeneratorPrototype%\", « [[GeneratorState]], [[GeneratorContext]] »).\n    let G = OrdinaryCreateFromConstructor(realm, F, \"GeneratorPrototype\", {\n      $GeneratorState: undefined,\n      $GeneratorContext: undefined\n    });\n\n    // 3. Perform GeneratorStart(G, FunctionBody).\n    let code = F.$ECMAScriptCode;\n    invariant(code !== undefined);\n    GeneratorStart(realm, G, code);\n\n    // 4. Return Completion{[[Type]]: return, [[Value]]: G, [[Target]]: empty}.\n    return new ReturnCompletion(G);\n  } else {\n    // 1. Perform ? FunctionDeclarationInstantiation(F, argumentsList).\n    FunctionDeclarationInstantiation(realm, F, argumentsList);\n\n    // 2. Return the result of EvaluateBody of the parsed code that is the value of F's\n    //    [[ECMAScriptCode]] internal slot passing F as the argument.\n    let code = F.$ECMAScriptCode;\n    invariant(code !== undefined);\n    let c = realm.getRunningContext().lexicalEnvironment.evaluateAbstractCompletion(code, F.$Strict);\n    let e = realm.get_captured_effects();\n    if (e !== undefined) {\n      realm.stop_effect_capture();\n      let [_c, _g, b, p, _o] = e;\n      _c; _g; _o;\n      realm.restoreBindings(b);\n      realm.restoreProperties(p);\n    }\n    if (c instanceof JoinedAbruptCompletions) {\n      if (e !== undefined) realm.apply_effects(e);\n      throw AbstractValue.createIntrospectionErrorThrowCompletion(c.joinCondition);\n    } else if (c instanceof ComposedAbruptCompletion) {\n      if (e !== undefined) realm.apply_effects(e);\n      throw c.createIntrospectionErrorThrowCompletion();\n    } else if (c instanceof PossiblyNormalCompletion) {\n      // If the abrupt part of the completion is a return completion, then the\n      // effects of its independent control path must be joined with the effects\n      // from the normal path, which is to say the currently tracked effects\n      // in the realm.\n      invariant(e !== undefined);\n      let joinedEffects = joinEffectsAndRemoveNestedReturnCompletions(realm, c, e);\n      realm.apply_effects(joinedEffects);\n      invariant(joinedEffects[0] instanceof ReturnCompletion);\n      return joinedEffects[0];\n    } else {\n      invariant(c instanceof Value || c instanceof AbruptCompletion);\n      if (e !== undefined) realm.apply_effects(e);\n      return c;\n    }\n  }\n}\n\n// ECMA262 12.3.4.3\nexport function EvaluateDirectCall(realm: Realm, strictCode: boolean, env: LexicalEnvironment, ref: Value | Reference, func: Value, thisValue: Value, args: Array<BabelNode> | BabelNodeTemplateLiteral, tailPosition?: boolean): Value {\n  // 1. Let argList be ? ArgumentListEvaluation(arguments).\n  let argList = ArgumentListEvaluation(realm, strictCode, env, args);\n\n  if (func instanceof AbstractValue && func.getType() === FunctionValue) {\n    let fullArgs = [func].concat(argList);\n    return realm.deriveAbstract(\n      TypesDomain.topVal,\n      ValuesDomain.topVal,\n      fullArgs,\n      (nodes) => {\n        let fun_args = ((nodes.slice(1): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n        return t.callExpression(nodes[0], fun_args);\n      });\n  }\n  func = func.throwIfNotConcrete();\n\n  // 2. If Type(func) is not Object, throw a TypeError exception.\n  if (!(func instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an object\");\n  }\n\n  // 3. If IsCallable(func) is false, throw a TypeError exception.\n  if (!IsCallable(realm, func)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n\n  // 4. If tailPosition is true, perform PrepareForTailCall().\n  if (tailPosition === true) PrepareForTailCall(realm);\n\n  // 5. Let result be Call(func, thisValue, argList).\n  let result = Call(realm, func, thisValue, argList);\n\n  // 6. Assert: If tailPosition is true, the above call will not return here, but instead\n  //    evaluation will continue as if the following return has already occurred.\n\n  // 7. Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.\n  invariant(result instanceof Value, \"expected language value type\");\n\n  // 8. Return result.\n  return result;\n}\n\n// ECMA262 14.6.3\nexport function PrepareForTailCall(realm: Realm) {\n  // 1. Let leafContext be the running execution context.\n  let leafContext = realm.getRunningContext();\n\n  // 2. Suspend leafContext.\n  leafContext.suspend();\n\n  // 3. Pop leafContext from the execution context stack. The execution context now on the\n  //    top of the stack becomes the running execution context.\n  realm.popContext(leafContext);\n\n  // TODO 4. Assert: leafContext has no further use. It will never be activated as the running execution context.\n}\n\n// ECMA262 7.3.12\nexport function Call(realm: Realm, F: Value, V: Value, argsList?: Array<Value>): Value {\n  // 1. If argumentsList was not passed, let argumentsList be a new empty List.\n  argsList = argsList || [];\n\n  // 2. If IsCallable(F) is false, throw a TypeError exception.\n  if (IsCallable(realm, F) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n  invariant(F instanceof ObjectValue);\n\n  // 3. Return ? F.[[Call]](V, argumentsList).\n  invariant(F.$Call, \"no call method on this value\");\n  return F.$Call(V, argsList);\n}\n"]}