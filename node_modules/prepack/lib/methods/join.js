"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.joinPossiblyNormalCompletions = joinPossiblyNormalCompletions;
exports.joinPossiblyNormalCompletionWithAbruptCompletion = joinPossiblyNormalCompletionWithAbruptCompletion;
exports.joinEffectsAndRemoveNestedReturnCompletions = joinEffectsAndRemoveNestedReturnCompletions;
exports.joinEffects = joinEffects;
exports.joinMaps = joinMaps;
exports.joinBindings = joinBindings;
exports.joinValues = joinValues;
exports.joinValuesAsConditional = joinValuesAsConditional;
exports.joinPropertyBindings = joinPropertyBindings;
exports.joinDescriptors = joinDescriptors;
exports.joinBooleans = joinBooleans;

var _completions = require("../completions.js");

var _index = require("../domains/index.js");

var _environment = require("../environment.js");

var _index2 = require("../methods/index.js");

var _realm = require("../realm.js");

var _generator = require("../utils/generator.js");

var _index3 = require("../values/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function joinPossiblyNormalCompletions(realm, pnc, c) {
  var empty_effects = (0, _realm.construct_empty_effects)(realm);
  if (pnc.consequent instanceof _completions.AbruptCompletion) {
    if (pnc.alternate instanceof _index3.Value) {
      return new _completions.PossiblyNormalCompletion(pnc.joinCondition, pnc.consequent, pnc.consequentEffects, c, empty_effects);
    }
    (0, _invariant2.default)(pnc.alternate instanceof _completions.PossiblyNormalCompletion);
    var new_alternate = joinPossiblyNormalCompletions(realm, pnc.alternate, c);
    return new _completions.PossiblyNormalCompletion(pnc.joinCondition, pnc.consequent, pnc.consequentEffects, new_alternate, empty_effects);
  } else {
    (0, _invariant2.default)(pnc.alternate instanceof _completions.AbruptCompletion);
    if (pnc.consequent instanceof _index3.Value) {
      return new _completions.PossiblyNormalCompletion(pnc.joinCondition, c, empty_effects, pnc.alternate, pnc.alternateEffects);
    }
    (0, _invariant2.default)(pnc.consequent instanceof _completions.PossiblyNormalCompletion);
    var new_consequent = joinPossiblyNormalCompletions(realm, pnc.consequent, c);
    return new _completions.PossiblyNormalCompletion(pnc.joinCondition, new_consequent, empty_effects, pnc.alternate, pnc.alternateEffects);
  }
}

function joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc, ac, e) {
  if (pnc.consequent instanceof _completions.AbruptCompletion) {
    if (pnc.alternate instanceof _index3.Value) return joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, e);
    (0, _invariant2.default)(pnc.alternate instanceof _completions.PossiblyNormalCompletion);
    var alternate_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.alternate, ac, e);
    (0, _invariant2.default)(pnc.consequent instanceof _completions.AbruptCompletion);
    return joinEffects(realm, pnc.joinCondition, pnc.consequentEffects, alternate_effects);
  } else {
    (0, _invariant2.default)(pnc.alternate instanceof _completions.AbruptCompletion);
    if (pnc.consequent instanceof _index3.Value) return joinEffects(realm, pnc.joinCondition, e, pnc.alternateEffects);
    (0, _invariant2.default)(pnc.consequent instanceof _completions.PossiblyNormalCompletion);
    var consequent_effects = joinPossiblyNormalCompletionWithAbruptCompletion(realm, pnc.consequent, ac, e);
    (0, _invariant2.default)(pnc.alternate instanceof _completions.AbruptCompletion);
    return joinEffects(realm, pnc.joinCondition, consequent_effects, pnc.alternateEffects);
  }
}

function joinEffectsAndRemoveNestedReturnCompletions(realm, c, e, nested_effects) {
  if (c instanceof _index3.Value) return e;
  if (c instanceof _completions.AbruptCompletion) {
    (0, _invariant2.default)(nested_effects !== undefined);
    return nested_effects;
  }
  if (c instanceof _completions.PossiblyNormalCompletion) {
    var e1 = joinEffectsAndRemoveNestedReturnCompletions(realm, c.consequent, e, c.consequentEffects);
    var e2 = joinEffectsAndRemoveNestedReturnCompletions(realm, c.alternate, e, c.alternateEffects);
    if (e1[0] instanceof _completions.ReturnCompletion) {
      if (!(e2[0] instanceof _completions.ReturnCompletion)) {
        (0, _invariant2.default)(e2[0] instanceof _index3.Value); // otherwise c cannot possibly be normal
        e2[0] = new _completions.ReturnCompletion(realm.intrinsics.undefined);
      }
      return joinEffects(realm, c.joinCondition, e1, e2);
    } else if (e2[0] instanceof _completions.ReturnCompletion) {
      (0, _invariant2.default)(e1[0] instanceof _index3.Value); // otherwise c cannot possibly be normal
      e1[0] = new _completions.ReturnCompletion(realm.intrinsics.undefined);
      return joinEffects(realm, c.joinCondition, e1, e2);
    } else {
      throw _index3.AbstractValue.createIntrospectionErrorThrowCompletion(c.joinCondition);
    }
  }
  (0, _invariant2.default)(false);
}

function joinEffects(realm, joinCondition, e1, e2) {
  var _e = _slicedToArray(e1, 5),
      result1 = _e[0],
      gen1 = _e[1],
      bindings1 = _e[2],
      properties1 = _e[3],
      createdObj1 = _e[4];

  var _e2 = _slicedToArray(e2, 5),
      result2 = _e2[0],
      gen2 = _e2[1],
      bindings2 = _e2[2],
      properties2 = _e2[3],
      createdObj2 = _e2[4];

  if (result1 instanceof _completions.IntrospectionThrowCompletion) return e1;
  if (result2 instanceof _completions.IntrospectionThrowCompletion) return e2;
  var result = joinResults(realm, joinCondition, result1, result2, e1, e2);
  if (result1 instanceof _completions.AbruptCompletion) {
    if (!(result2 instanceof _completions.AbruptCompletion)) {
      (0, _invariant2.default)(result instanceof _completions.PossiblyNormalCompletion);
      return [result, gen2, bindings2, properties2, createdObj2];
    }
  } else if (result2 instanceof _completions.AbruptCompletion) {
    (0, _invariant2.default)(result instanceof _completions.PossiblyNormalCompletion);
    return [result, gen1, bindings1, properties1, createdObj1];
  }

  var bindings = joinBindings(realm, joinCondition, bindings1, bindings2);
  var properties = joinPropertyBindings(realm, joinCondition, properties1, properties2, createdObj1, createdObj2);
  var createdObjects = new Set();
  createdObj1.forEach(function (o) {
    createdObjects.add(o);
  });
  createdObj2.forEach(function (o) {
    createdObjects.add(o);
  });

  var generator = joinGenerators(realm, joinCondition, gen1, gen2, result1, result2);

  return [result, generator, bindings, properties, createdObjects];
}

function joinResults(realm, joinCondition, result1, result2, e1, e2) {
  function getAbstractValue(v1, v2) {
    return joinValuesAsConditional(realm, joinCondition, v1, v2);
  }
  if (result1 instanceof _environment.Reference || result2 instanceof _environment.Reference) throw _index3.AbstractValue.createIntrospectionErrorThrowCompletion(joinCondition);
  if (result1 instanceof _completions.BreakCompletion && result2 instanceof _completions.BreakCompletion && result1.target === result2.target) {
    return new _completions.BreakCompletion(realm.intrinsics.empty, result1.target);
  }
  if (result1 instanceof _completions.ContinueCompletion && result2 instanceof _completions.ContinueCompletion && result1.target === result2.target) {
    return new _completions.ContinueCompletion(realm.intrinsics.empty, result1.target);
  }
  if (result1 instanceof _completions.ReturnCompletion && result2 instanceof _completions.ReturnCompletion) {
    var val = joinValues(realm, result1.value, result2.value, getAbstractValue);
    return new _completions.ReturnCompletion(val);
  }
  if (result1 instanceof _completions.ThrowCompletion && result2 instanceof _completions.ThrowCompletion) {
    var _val = joinValues(realm, result1.value, result2.value, getAbstractValue);
    return new _completions.ThrowCompletion(_val);
  }
  if (result1 instanceof _completions.AbruptCompletion && result2 instanceof _completions.AbruptCompletion) {
    return new _completions.JoinedAbruptCompletions(realm, joinCondition, result1, e1, result2, e2);
  }
  if (result1 instanceof _index3.Value && result2 instanceof _index3.Value) return joinValues(realm, result1, result2, getAbstractValue);
  return new _completions.PossiblyNormalCompletion(joinCondition, result1, e1, result2, e2);
}

function joinGenerators(realm, joinCondition, generator1, generator2, result1, result2) {
  var result = new _generator.Generator(realm);
  if (!generator1.empty() || !generator2.empty()) {
    result.body.push({
      args: [joinCondition],
      buildNode: function buildNode(_ref, context) {
        var _ref2 = _slicedToArray(_ref, 1),
            cond = _ref2[0];

        var block1 = generator1.empty() ? null : serializeBody(generator1, context);
        var block2 = generator2.empty() ? null : serializeBody(generator2, context);
        if (block1) return t.ifStatement(cond, block1, block2);
        (0, _invariant2.default)(block2);
        return t.ifStatement(t.unaryExpression("!", cond), block2);
      }
    });
  }
  return result;
}

function serializeBody(generator, context) {
  var statements = context.startBody();
  generator.serialize(statements, context);
  context.endBody(statements);
  return t.blockStatement(statements);
}

// Creates a single map that joins together maps m1 and m2 using the given join
// operator. If an entry is present in one map but not the other, the missing
// entry is treated as if it were there and its value were undefined.
function joinMaps(m1, m2, join) {
  var m3 = new Map();
  m1.forEach(function (val1, key, map1) {
    var val2 = m2.get(key);
    var val3 = join(key, val1, val2);
    m3.set(key, val3);
  });
  m2.forEach(function (val2, key, map2) {
    if (!m1.has(key)) {
      m3.set(key, join(key, undefined, val2));
    }
  });
  return m3;
}

// Creates a single map that has an key, value pair for the union of the key
// sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]
// where the join is defined to be just m1[key] if m1[key] === m2[key] and
// and abstract value with expression "joinCondition ? m1[key] : m2[key]" if not.
function joinBindings(realm, joinCondition, m1, m2) {

  function getAbstractValue(v1, v2) {
    return joinValuesAsConditional(realm, joinCondition, v1, v2);
  }
  function join(b, v1, v2) {
    if (v1 === undefined) v1 = b.value;
    if (v2 === undefined) v2 = b.value;
    return joinValues(realm, v1, v2, getAbstractValue);
  }
  return joinMaps(m1, m2, join);
}

// If v1 is known and defined and v1 === v2 return v1,
// otherwise return getAbstractValue(v1, v2)
function joinValues(realm, v1, v2, getAbstractValue) {
  if (v1 !== undefined && v2 !== undefined && !(v1 instanceof _index3.AbstractValue) && !(v2 instanceof _index3.AbstractValue) && (0, _index2.StrictEqualityComparison)(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())) {
    return v1;
  } else {
    return getAbstractValue(v1, v2);
  }
}

function joinValuesAsConditional(realm, condition, v1, v2) {
  var types = _index.TypesDomain.joinValues(v1, v2);
  var values = _index.ValuesDomain.joinValues(realm, v1, v2);
  var result = realm.createAbstract(types, values, [condition, v1 || realm.intrinsics.undefined, v2 || realm.intrinsics.undefined], function (args) {
    return t.conditionalExpression(args[0], args[1], args[2]);
  });
  if (v1) result.mightBeEmpty = v1.mightHaveBeenDeleted();
  if (v2 && !result.mightBeEmpty) result.mightBeEmpty = v2.mightHaveBeenDeleted();
  return result;
}

function joinPropertyBindings(realm, joinCondition, m1, m2, c1, c2) {

  function getAbstractValue(v1, v2) {
    return joinValuesAsConditional(realm, joinCondition, v1, v2);
  }
  function join(b, d1, d2) {
    // If the PropertyBinding object has been freshly allocated do not join
    if (d1 === undefined) {
      if (c2.has(b.object)) return d2; // no join
      if (b.descriptor !== undefined && m1.has(b)) {
        // property was deleted
        d1 = (0, _index2.cloneDescriptor)(b.descriptor);
        (0, _invariant2.default)(d1 !== undefined);
        d1.value = realm.intrinsics.empty;
      } else {
        // no write to property
        d1 = b.descriptor; //Get value of property before the split
      }
    }
    if (d2 === undefined) {
      if (c1.has(b.object)) return d1; // no join
      if (b.descriptor !== undefined && m2.has(b)) {
        // property was deleted
        d2 = (0, _index2.cloneDescriptor)(b.descriptor);
        (0, _invariant2.default)(d2 !== undefined);
        d2.value = realm.intrinsics.empty;
      } else {
        // no write to property
        d2 = b.descriptor; //Get value of property before the split
      }
    }
    return joinDescriptors(realm, d1, d2, getAbstractValue);
  }
  return joinMaps(m1, m2, join);
}

// Returns a field by field join of two descriptors.
// Descriptors with get/set are not yet supported.
function joinDescriptors(realm, d1, d2, getAbstractValue) {
  function clone_with_abstract_value(d) {
    if (!(0, _index2.IsDataDescriptor)(realm, d)) throw new Error("TODO: join computed properties");
    var dc = (0, _index2.cloneDescriptor)(d);
    (0, _invariant2.default)(dc !== undefined);
    dc.value = getAbstractValue(d.value, realm.intrinsics.empty);
    return dc;
  }
  if (d1 === undefined) {
    if (d2 === undefined) return undefined;
    // d2 is a new property created in only one branch, join with empty
    return clone_with_abstract_value(d2);
  } else if (d2 === undefined) {
    // d1 is a new property created in only one branch, join with empty
    return clone_with_abstract_value(d1);
  } else {
    var d3 = {};
    var writable = joinBooleans(d1.writable, d2.writable);
    if (writable !== undefined) d3.writable = writable;
    var enumerable = joinBooleans(d1.enumerable, d2.enumerable);
    if (enumerable !== undefined) d3.enumerable = enumerable;
    var configurable = joinBooleans(d1.configurable, d2.configurable);
    if (configurable !== undefined) d3.configurable = configurable;
    if ((0, _index2.IsDataDescriptor)(realm, d1) || (0, _index2.IsDataDescriptor)(realm, d2)) d3.value = joinValues(realm, d1.value, d2.value, getAbstractValue);
    if (d1.hasOwnProperty("get") || d2.hasOwnProperty("get")) throw new Error("TODO: join callables");
    if (d1.hasOwnProperty("set") || d2.hasOwnProperty("set")) throw new Error("TODO: join callables");
    return d3;
  }
}

// Returns v1 || v2, treating undefined as false,
// but returns undefined if both v1 and v2 are undefined.
function joinBooleans(v1, v2) {
  if (v1 === undefined) {
    return v2;
  } else if (v2 === undefined) {
    return v1;
  } else {
    return v1 || v2;
  }
}
//# sourceMappingURL=join.js.map