{"version":3,"sources":["../../src/domains/TypesDomain.js"],"names":["TypesDomain","type","_type","undefined","t","getType","isTypeCompatibleWith","topVal","v1","v2","types","joinWith"],"mappings":";;;;;;qjBAAA;;;;;;;;;AAWA;;AACA;;;;;;;;AAEA;;IAEqBA,W;AACnB,uBAAYC,IAAZ,EAAuC;AAAA;;AACrC,6BAAUA,6BAAV,EAAkC,kCAAlC;AACA,SAAKC,KAAL,GAAaD,wBAAiBE,SAAjB,GAA6BF,IAA1C;AACD;;;;8BAMuB;AACtB,aAAO,KAAKC,KAAL,gBAAP;AACD;;;6BAYQE,C,EAA+B;AACtC,UAAIH,OAAO,KAAKI,OAAL,EAAX;AACA,UAAIJ,SAASG,CAAb,EAAgB,OAAO,IAAP;AAChB,UAAI,aAAME,oBAAN,CAA2BL,IAA3B,2BACA,aAAMK,oBAAN,CAA2BF,CAA3B,uBADJ,EACkD;AAChD,eAAO,IAAIJ,WAAJ,sBAAP;AACD;AACD,UAAI,aAAMM,oBAAN,CAA2BL,IAA3B,yBACA,aAAMK,oBAAN,CAA2BF,CAA3B,qBADJ,EACgD;AAC9C,eAAO,IAAIJ,WAAJ,oBAAP;AACD;AACD,UAAI,aAAMM,oBAAN,CAA2BL,IAA3B,4BACA,aAAMK,oBAAN,CAA2BF,CAA3B,wBADJ,EACmD;AACjD,eAAO,IAAIJ,WAAJ,uBAAP;AACD;AACD,aAAOA,YAAYO,MAAnB;AACD;;;+BA1BiBC,E,EAAkBC,E,EAA+B;AACjE,UAAID,OAAOL,SAAP,IAAoBM,OAAON,SAA/B,EAA0C,OAAO,IAAIH,WAAJ,uBAAP;AAC1C,UAAIQ,OAAOL,SAAP,IAAoBM,OAAON,SAA/B,EAA0C,OAAOH,YAAYO,MAAnB;AAC1C,UAAIC,kCAAJ,EACE,OAAOA,GAAGE,KAAH,CAASC,QAAT,CAAkBF,GAAGJ,OAAH,EAAlB,CAAP;AACF,UAAII,kCAAJ,EACE,OAAOA,GAAGC,KAAH,CAASC,QAAT,CAAkBH,GAAGH,OAAH,EAAlB,CAAP;AACF,aAAQ,IAAIL,WAAJ,CAAgBQ,GAAGH,OAAH,EAAhB,CAAD,CAAgCM,QAAhC,CAAyCF,GAAGJ,OAAH,EAAzC,CAAP;AACD;;;;;;AAtBkBL,W,CAMZO,M,GAAsB,IAAIP,WAAJ,CAAgBG,SAAhB,C;kBANVH,W","file":"TypesDomain.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbstractValue, ConcreteValue, FunctionValue, ObjectValue, PrimitiveValue, UndefinedValue, Value } from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\n\n/* An abstract domain for the type of value a variable might have.  */\n\nexport default class TypesDomain {\n  constructor(type: void | typeof Value) {\n    invariant(type !== ConcreteValue, \"Concrete values must be specific\");\n    this._type = type === Value ? undefined : type;\n  }\n\n  static topVal: TypesDomain = new TypesDomain(undefined);\n\n  _type: void | typeof Value;\n\n  getType(): typeof Value {\n    return this._type || Value;\n  }\n\n  static joinValues(v1: void | Value, v2: void | Value): TypesDomain {\n    if (v1 === undefined && v2 === undefined) return new TypesDomain(UndefinedValue);\n    if (v1 === undefined || v2 === undefined) return TypesDomain.topVal;\n    if (v1 instanceof AbstractValue)\n      return v1.types.joinWith(v2.getType());\n    if (v2 instanceof AbstractValue)\n      return v2.types.joinWith(v1.getType());\n    return (new TypesDomain(v1.getType())).joinWith(v2.getType());\n  }\n\n  joinWith(t: typeof Value): TypesDomain  {\n    let type = this.getType();\n    if (type === t) return this;\n    if (Value.isTypeCompatibleWith(type, FunctionValue) &&\n        Value.isTypeCompatibleWith(t, FunctionValue)) {\n      return new TypesDomain(FunctionValue);\n    }\n    if (Value.isTypeCompatibleWith(type, ObjectValue) &&\n        Value.isTypeCompatibleWith(t, ObjectValue)) {\n      return new TypesDomain(ObjectValue);\n    }\n    if (Value.isTypeCompatibleWith(type, PrimitiveValue) &&\n        Value.isTypeCompatibleWith(t, PrimitiveValue)) {\n      return new TypesDomain(PrimitiveValue);\n    }\n    return TypesDomain.topVal;\n  }\n\n}\n"]}