"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Realm = exports.ExecutionContext = exports.Tracer = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

exports.construct_empty_effects = construct_empty_effects;

var _index = require("./values/index.js");

var _index2 = require("./domains/index.js");

var _environment = require("./environment.js");

var _index3 = require("./methods/index.js");

var _completions = require("./completions.js");

var _invariant = require("./invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _seedrandom = require("seedrandom");

var _seedrandom2 = _interopRequireDefault(_seedrandom);

var _generator = require("./utils/generator.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _to = require("./methods/to.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tracer = exports.Tracer = function () {
  function Tracer() {
    _classCallCheck(this, Tracer);
  }

  _createClass(Tracer, [{
    key: "beginPartialEvaluation",
    value: function beginPartialEvaluation() {}
  }, {
    key: "endPartialEvaluation",
    value: function endPartialEvaluation(effects) {}
  }, {
    key: "detourCall",
    value: function detourCall(F, thisArgument, argumentsList, newTarget, performCall) {}
  }, {
    key: "beforeCall",
    value: function beforeCall(F, thisArgument, argumentsList, newTarget) {}
  }, {
    key: "afterCall",
    value: function afterCall(F, thisArgument, argumentsList, newTarget, result) {}
  }]);

  return Tracer;
}();

var ExecutionContext = exports.ExecutionContext = function () {
  function ExecutionContext() {
    _classCallCheck(this, ExecutionContext);
  }

  _createClass(ExecutionContext, [{
    key: "setCaller",
    value: function setCaller(context) {
      this.caller = context;
    }
  }, {
    key: "setFunction",
    value: function setFunction(F) {
      this.function = F;
    }
  }, {
    key: "setLocation",
    value: function setLocation(loc) {
      if (!loc) return;
      this.loc = loc;
    }
  }, {
    key: "setRealm",
    value: function setRealm(realm) {
      this.realm = realm;
    }

    /*
     Read-only envs disallow:
     - creating bindings in their scope
     - creating or modifying objects when they are current running context
    */

  }, {
    key: "setReadOnly",
    value: function setReadOnly(value) {
      var oldReadOnly = this.isReadOnly;
      if (this.variableEnvironment) this.variableEnvironment.environmentRecord.isReadOnly = value;
      if (this.lexicalEnvironment) this.lexicalEnvironment.environmentRecord.isReadOnly = value;
      this.isReadOnly = value;
      return oldReadOnly;
    }
  }, {
    key: "suspend",
    value: function suspend() {
      // TODO: suspend
    }
  }, {
    key: "resume",
    value: function resume() {
      // TODO: resume
      return this.realm.intrinsics.undefined;
    }
  }]);

  return ExecutionContext;
}();

function construct_empty_effects(realm) {
  return [realm.intrinsics.empty, new _generator.Generator(realm), new Map(), new Map(), new Set()];
}

var Realm = exports.Realm = function () {
  function Realm(opts) {
    _classCallCheck(this, Realm);

    this.contextStack = [];
    this.MOBILE_JSC_VERSION = "jsc-600-1-4-17";

    this.isReadOnly = false;
    this.isPartial = !!opts.partial;
    if (opts.mathRandomSeed !== undefined) {
      this.mathRandomGenerator = (0, _seedrandom2.default)(opts.mathRandomSeed);
    }
    this.strictlyMonotonicDateNow = !!opts.strictlyMonotonicDateNow;

    this.timeout = opts.timeout;
    if (this.timeout) {
      // We'll call Date.now for every this.timeoutCounterThreshold'th AST node.
      // The threshold is there to reduce the cost of the surprisingly expensive Date.now call.
      this.timeoutCounter = this.timeoutCounterThreshold = 1024;
    }

    this.start = Date.now();
    this.compatibility = opts.compatibility || "browser";

    this.$TemplateMap = [];

    if (this.isPartial) {
      this.preludeGenerator = new _generator.PreludeGenerator(opts.debugNames, opts.uniqueSuffix);
      _index.ObjectValue.setupTrackedPropertyAccessors();
    }

    this.tracers = [];

    // These get initialized in construct_realm to avoid the dependency
    this.intrinsics = {};
    this.$GlobalObject = {};
    this.evaluators = Object.create(null);
    this.$GlobalEnv = undefined;
  }

  _createClass(Realm, [{
    key: "isCompatibleWith",


    // to force flow to type the annotations
    value: function isCompatibleWith(compatibility) {
      return compatibility === this.compatibility;
    }

    // Checks if there is a let binding at global scope with the given name
    // returning it if so

  }, {
    key: "getGlobalLetBinding",
    value: function getGlobalLetBinding(key) {
      var globrec = this.$GlobalEnv.environmentRecord;
      // GlobalEnv should have a GlobalEnvironmentRecord
      (0, _invariant2.default)(globrec instanceof _environment.GlobalEnvironmentRecord);
      var dclrec = globrec.$DeclarativeRecord;

      return dclrec.HasBinding(key) ? dclrec.GetBindingValue(key, false) : undefined;
    }

    /*
     Read only realms disallow:
     - using console.log
     - creating bindings in any existing scopes
     - modifying object properties in any existing scopes
     Setting a realm read-only sets all contained environments to read-only, but
     all new environments (e.g. new ExecutionContexts) will be writeable.
     */

  }, {
    key: "setReadOnly",
    value: function setReadOnly(readOnlyValue) {
      this.isReadOnly = readOnlyValue;
      this.$GlobalEnv.environmentRecord.isReadOnly = readOnlyValue;
      this.contextStack.forEach(function (ctx) {
        ctx.setReadOnly(readOnlyValue);
      });
    }
  }, {
    key: "testTimeout",
    value: function testTimeout() {
      var timeout = this.timeout;
      if (timeout && ! --this.timeoutCounter) {
        this.timeoutCounter = this.timeoutCounterThreshold;
        var total = Date.now() - this.start;
        if (total > timeout) {
          throw new Error("Timed out");
        }
      }
    }
  }, {
    key: "getRunningContext",
    value: function getRunningContext() {
      var context = this.contextStack[this.contextStack.length - 1];
      (0, _invariant2.default)(context, "There's no running execution context");
      return context;
    }
  }, {
    key: "pushContext",
    value: function pushContext(context) {
      this.contextStack.push(context);
    }
  }, {
    key: "popContext",
    value: function popContext(context) {
      var c = this.contextStack.pop();
      (0, _invariant2.default)(c === context);
    }

    // Evaluate the given ast in a sandbox and return the evaluation results
    // in the form a completion, a code generator, a map of changed variable
    // bindings and a map of changed property bindings.

  }, {
    key: "partially_evaluate_node",
    value: function partially_evaluate_node(ast, strictCode, env) {
      return this.partially_evaluate(function () {
        return env.evaluateCompletion(ast, strictCode);
      });
    }
  }, {
    key: "partially_evaluate",
    value: function partially_evaluate(f) {
      // Save old state and set up empty state for ast
      var _getAndResetModifiedM = this.getAndResetModifiedMaps(),
          _getAndResetModifiedM2 = _slicedToArray(_getAndResetModifiedM, 2),
          savedBindings = _getAndResetModifiedM2[0],
          savedProperties = _getAndResetModifiedM2[1];

      var saved_generator = this.generator;
      var saved_createdObjects = this.createdObjects;
      this.generator = new _generator.Generator(this);
      this.createdObjects = new Set();

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.tracers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var t1 = _step.value;
          t1.beginPartialEvaluation();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var c = void 0;
      var result = void 0;
      try {
        c = f();
        if (c instanceof _environment.Reference) c = (0, _index3.GetValue)(this, c);

        (0, _invariant2.default)(this.generator !== undefined);
        (0, _invariant2.default)(this.modifiedBindings !== undefined);
        (0, _invariant2.default)(this.modifiedProperties !== undefined);
        (0, _invariant2.default)(this.createdObjects !== undefined);
        var astGenerator = this.generator;
        var astBindings = this.modifiedBindings;
        var astProperties = this.modifiedProperties;
        var astCreatedObjects = this.createdObjects;

        // Return the captured state changes and evaluation result
        result = [c, astGenerator, astBindings, astProperties, astCreatedObjects];
        return result;
      } finally {
        // Roll back the state changes
        this.restoreBindings(this.modifiedBindings);
        this.restoreProperties(this.modifiedProperties);
        this.generator = saved_generator;
        this.modifiedBindings = savedBindings;
        this.modifiedProperties = savedProperties;
        this.createdObjects = saved_createdObjects;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.tracers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var t2 = _step2.value;
            t2.endPartialEvaluation(result);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  }, {
    key: "capture_effects",
    value: function capture_effects() {
      var context = this.getRunningContext();
      if (context.savedEffects !== undefined) {
        // Already called capture_effects in this context, just carry on
        return;
      }
      context.savedEffects = [this.intrinsics.undefined, this.generator, this.modifiedBindings, this.modifiedProperties, this.createdObjects];
      this.generator = new _generator.Generator(this);
      this.modifiedBindings = new Map();
      this.modifiedProperties = new Map();
      this.createdObjects = new Set();
    }
  }, {
    key: "get_captured_effects",
    value: function get_captured_effects(v) {
      var context = this.getRunningContext();
      if (context.savedEffects === undefined) return undefined;
      if (v === undefined) v = this.intrinsics.undefined;
      (0, _invariant2.default)(this.generator !== undefined);
      (0, _invariant2.default)(this.modifiedBindings !== undefined);
      (0, _invariant2.default)(this.modifiedProperties !== undefined);
      (0, _invariant2.default)(this.createdObjects !== undefined);
      return [v, this.generator, this.modifiedBindings, this.modifiedProperties, this.createdObjects];
    }
  }, {
    key: "stop_effect_capture",
    value: function stop_effect_capture() {
      var context = this.getRunningContext();
      if (context.savedEffects !== undefined) {
        var _context$savedEffects = _slicedToArray(context.savedEffects, 5),
            c = _context$savedEffects[0],
            g = _context$savedEffects[1],
            b = _context$savedEffects[2],
            p = _context$savedEffects[3],
            o = _context$savedEffects[4];

        c;
        context.savedEffects = undefined;
        this.generator = g;
        this.modifiedBindings = b;
        this.modifiedProperties = p;
        this.createdObjects = o;
      }
    }

    // Apply the given effects to the global state

  }, {
    key: "apply_effects",
    value: function apply_effects(effects) {
      var leadingComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

      var _effects = _slicedToArray(effects, 5),
          completion = _effects[0],
          generator = _effects[1],
          bindings = _effects[2],
          properties = _effects[3],
          createdObjects = _effects[4];

      // ignore completion


      completion;

      // Add generated code for property modifications
      this.appendGenerator(generator, leadingComment);

      // Restore bindings
      this.restoreBindings(bindings);
      this.restoreProperties(properties);

      // track bindings
      var realmModifiedBindings = this.modifiedBindings;
      if (realmModifiedBindings !== undefined) {
        bindings.forEach(function (val, key, m) {
          (0, _invariant2.default)(realmModifiedBindings !== undefined);
          if (!realmModifiedBindings.has(key)) {
            realmModifiedBindings.set(key, val);
          }
        });
      }
      var realmModifiedProperties = this.modifiedProperties;
      if (realmModifiedProperties !== undefined) {
        properties.forEach(function (desc, propertyBinding, m) {
          (0, _invariant2.default)(realmModifiedProperties !== undefined);
          if (!realmModifiedProperties.has(propertyBinding)) {
            realmModifiedProperties.set(propertyBinding, desc);
          }
        });
      }

      // add created objects
      if (createdObjects.size > 0) {
        var realmCreatedObjects = this.createdObjects;
        if (realmCreatedObjects === undefined) this.createdObjects = new Set(createdObjects);else {
          createdObjects.forEach(function (ob, a) {
            (0, _invariant2.default)(realmCreatedObjects !== undefined);
            realmCreatedObjects.add(ob);
          });
        }
      }
    }
  }, {
    key: "createReadOnlyError",
    value: function createReadOnlyError(msg) {
      var completion = this.createIntrospectionErrorThrowCompletion(msg);
      completion.reason = "readonly";
      return completion;
    }
  }, {
    key: "outputToConsole",
    value: function outputToConsole(method, args) {
      if (this.isReadOnly) throw this.createReadOnlyError("Trying to create console output in read-only realm");
      if (this.isPartial) {
        (0, _invariant2.default)(this.generator !== undefined);
        this.generator.emitConsoleLog(method, args);
      } else {
        console[method](getString(this, args));
      }

      function getString(realm, values) {
        var res = "";
        while (values.length) {
          var next = values.shift();
          var nextString = (0, _to.ToString)(realm, next);
          res += nextString;
        }
        return res;
      }
    }

    // Record the current value of binding in this.modifiedBindings unless
    // there is already an entry for binding.

  }, {
    key: "recordModifiedBinding",
    value: function recordModifiedBinding(binding, env) {
      if (env.isReadOnly) throw this.createReadOnlyError("Trying to modify a binding in read-only realm");
      if (this.modifiedBindings !== undefined && !this.modifiedBindings.has(binding)) this.modifiedBindings.set(binding, binding.value);
      return binding;
    }

    // Record the current value of binding in this.modifiedProperties unless
    // there is already an entry for binding.

  }, {
    key: "recordModifiedProperty",
    value: function recordModifiedProperty(binding) {
      if (this.isReadOnly && (this.getRunningContext().isReadOnly || !this.isNewObject(binding.object))) {
        throw this.createReadOnlyError("Trying to modify a property in read-only realm");
      }
      if (this.modifiedProperties !== undefined && !this.modifiedProperties.has(binding)) {
        this.modifiedProperties.set(binding, (0, _index3.cloneDescriptor)(binding.descriptor));
      }
    }
  }, {
    key: "isNewObject",
    value: function isNewObject(object) {
      if (object instanceof _index.AbstractObjectValue) {
        var _realm = this;
        return object.values.getElements().some(function (element) {
          return _realm.isNewObject(element);
        });
      }
      return this.createdObjects === undefined || this.createdObjects.has(object);
    }
  }, {
    key: "recordNewObject",
    value: function recordNewObject(object) {
      if (this.createdObjects !== undefined) {
        this.createdObjects.add(object);
      }
    }

    // Returns the current values of modifiedBindings and modifiedProperties
    // and then assigns new empty maps to them.

  }, {
    key: "getAndResetModifiedMaps",
    value: function getAndResetModifiedMaps() {
      var result = [this.modifiedBindings, this.modifiedProperties];
      this.modifiedBindings = new Map();
      this.modifiedProperties = new Map();
      return result;
    }

    // Restores each Binding in the given map to the value it
    // had when it was entered into the map and updates the map to record
    // the value the Binding had just before the call to this method.

  }, {
    key: "restoreBindings",
    value: function restoreBindings(modifiedBindings) {
      if (modifiedBindings === undefined) return;
      modifiedBindings.forEach(function (val, key, m) {
        var v = key.value;
        key.value = val;
        m.set(key, v);
      });
    }

    // Restores each PropertyBinding in the given map to the value it
    // had when it was entered into the map and updates the map to record
    // the value the Binding had just before the call to this method.

  }, {
    key: "restoreProperties",
    value: function restoreProperties(modifiedProperties) {
      if (modifiedProperties === undefined) return;
      modifiedProperties.forEach(function (desc, propertyBinding, m) {
        var d = propertyBinding.descriptor;
        propertyBinding.descriptor = desc;
        m.set(propertyBinding, d);
      });
    }

    // Provide the realm with maps in which to track modifications.
    // A map can be set to undefined if no tracking is required.

  }, {
    key: "setModifiedMaps",
    value: function setModifiedMaps(modifiedBindings, modifiedProperties) {
      this.modifiedBindings = modifiedBindings;
      this.modifiedProperties = modifiedProperties;
    }

    // Create a state-less abstract value.
    // NOTE: `buildNode` MUST NOT create an AST which may mutate or access mutable state! Use `deriveAbstract` for that purpose.

  }, {
    key: "createAbstract",
    value: function createAbstract(types, values, args, buildNode, kind, intrinsicName) {
      (0, _invariant2.default)(this.isPartial);
      var Constructor = types.getType() === _index.ObjectValue ? _index.AbstractObjectValue : _index.AbstractValue;
      return new Constructor(this, types, values, args, buildNode, kind, intrinsicName);
    }
  }, {
    key: "rebuildObjectProperty",
    value: function rebuildObjectProperty(object, key, propertyValue, path) {
      if (!(propertyValue instanceof _index.AbstractValue)) return;
      if (!propertyValue.isIntrinsic()) {
        propertyValue.intrinsicName = path + "." + key;
        propertyValue.args = [object];
        propertyValue._buildNode = function (_ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              node = _ref2[0];

          return t.memberExpression(node, t.identifier(key));
        };
        this.rebuildNestedProperties(propertyValue, propertyValue.intrinsicName);
      }
    }
  }, {
    key: "rebuildNestedProperties",
    value: function rebuildNestedProperties(abstractValue, path) {
      if (!(abstractValue instanceof _index.AbstractObjectValue)) return;
      var template = abstractValue.getTemplate();
      (0, _invariant2.default)(!template.intrinsicName || template.intrinsicName === path);
      template.intrinsicName = path;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = template.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              _key = _step3$value[0],
              binding = _step3$value[1];

          if (binding === undefined || binding.descriptor === undefined) continue; // deleted
          (0, _invariant2.default)(binding.descriptor !== undefined);
          var value = binding.descriptor.value;
          (0, _index3.ThrowIfMightHaveBeenDeleted)(value);
          if (value === undefined) throw _index.AbstractValue.createIntrospectionErrorThrowCompletion(abstractValue, _key);
          this.rebuildObjectProperty(abstractValue, _key, value, path);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    // Create a an abstract value in a way that may observe or mutate state.
    // NOTE: If the state that is observed or mutated by the AST generated by `buildNode` is also represented in some form in the interpreter,
    // i.e. not just external state, then the caller must make sure that all relevant interpreter state is updated correspondingly.

  }, {
    key: "deriveAbstract",
    value: function deriveAbstract(types, values, args, buildNode, kind) {
      (0, _invariant2.default)(this.isPartial);
      var generator = this.generator;
      (0, _invariant2.default)(generator);
      return generator.derive(types, values, args, buildNode, kind);
    }
  }, {
    key: "createExecutionContext",
    value: function createExecutionContext() {
      var context = new ExecutionContext();

      var loc = this.nextContextLocation;
      if (loc) {
        context.setLocation(loc);
        this.nextContextLocation = null;
      }

      return context;
    }
  }, {
    key: "setNextExecutionContextLocation",
    value: function setNextExecutionContextLocation(loc) {
      if (!loc) return;

      //if (this.nextContextLocation) {
      //  throw new ThrowCompletion(
      //    Construct(this, this.intrinsics.TypeError, [new StringValue(this, "Already have a context location that we haven't used yet")])
      //  );
      //} else {
      this.nextContextLocation = loc;
      //}
    }
  }, {
    key: "createIntrospectionErrorThrowCompletion",
    value: function createIntrospectionErrorThrowCompletion(message) {
      if (message === undefined) message = "TODO";
      if (typeof message === "string") message = new _index.StringValue(this, message);
      (0, _invariant2.default)(message instanceof _index.StringValue);
      this.nextContextLocation = this.currentLocation;
      return new _completions.IntrospectionThrowCompletion((0, _index3.Construct)(this, this.intrinsics.__IntrospectionError, [message]));
    }
  }, {
    key: "createErrorThrowCompletion",
    value: function createErrorThrowCompletion(type, message) {
      (0, _invariant2.default)(type !== this.intrinsics.__IntrospectionError);
      if (message === undefined) message = "TODO";
      if (typeof message === "string") message = new _index.StringValue(this, message);
      (0, _invariant2.default)(message instanceof _index.StringValue);
      this.nextContextLocation = this.currentLocation;
      return new _completions.ThrowCompletion((0, _index3.Construct)(this, type, [message]));
    }
  }, {
    key: "appendGenerator",
    value: function appendGenerator(generator) {
      var leadingComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

      var realmGenerator = this.generator;
      (0, _invariant2.default)(realmGenerator);
      var realmGeneratorBody = realmGenerator.body;
      var generatorBody = generator.body;
      var i = 0;
      if (generatorBody.length > 0 && leadingComment.length > 0) {
        var firstEntry = generatorBody[i++];
        var buildNode = function buildNode(nodes, f) {
          var n = firstEntry.buildNode(nodes, f);
          n.leadingComments = [{ type: "BlockComment", value: leadingComment }];
          return n;
        };
        realmGeneratorBody.push({ declaresDerivedId: firstEntry.declaresDerivedId, args: firstEntry.args, buildNode: buildNode });
      }
      for (; i < generatorBody.length; i++) {
        realmGeneratorBody.push(generatorBody[i]);
      }
    }
  }]);

  return Realm;
}();
//# sourceMappingURL=realm.js.map