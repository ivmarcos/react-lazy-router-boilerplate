{"version":3,"sources":["../../../src/intrinsics/ecma262/TypedArrayPrototype.js"],"names":["realm","obj","defineNativeGetter","context","O","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","$ViewedArrayBuffer","buffer","zero","size","$ByteLength","offset","$ByteOffset","defineNativeMethod","target","start","end","len","$ArrayLength","relativeTarget","to","Math","max","min","relativeStart","from","relativeEnd","final","count","direction","fromKey","toKey","fromPresent","fromVal","callbackfn","thisArg","T","undefined","k","Pk","kPresent","kValue","testResult","false","true","value","kept","captured","selected","push","A","n","e","predicate","searchElement","fromIndex","elementK","Object","is","same","separator","sep","emptyString","element0","R","S","element","next","length","mappedValue","initialValue","accumulator","middle","floor","lower","upper","upperP","lowerP","lowerExists","lowerValue","upperExists","upperValue","overloaded","$TypedArrayName","array","targetOffset","RangeError","targetBuffer","targetLength","targetName","targetElementSize","targetType","targetByteOffset","src","srcLength","targetByteIndex","limit","kNumber","typedArray","srcBuffer","srcName","srcType","srcElementSize","srcByteOffset","srcByteIndex","ArrayBuffer","elementSize","comparefn","SortCompare","x","y","mightBeUndefined","v","isNaN","comparefn_","result_","numb","arr","j","val","sort","begin","relativeBegin","beginIndex","endIndex","newLength","constructorName","beginByteOffset","argumentsList","firstElement","nextElement","defineNativeProperty","ArrayProto_toString","TypedArrayProto_values","SymbolIterator","SymbolToStringTag","name","build","type","$Prototype","TypedArrayPrototype","defineNativeConstant"],"mappings":"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","file":"TypedArrayPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport type { ElementType } from \"../../types.js\";\nimport { ElementSize } from \"../../types.js\";\nimport { ObjectValue, StringValue, NumberValue, UndefinedValue, NullValue } from \"../../values/index.js\";\nimport { ToInteger, ToString, ToStringPartial, ToBooleanPartial, ToObject, ToObjectPartial, ToLength, ToNumber } from \"../../methods/to.js\";\nimport { Call, Invoke } from \"../../methods/call.js\";\nimport { Get } from \"../../methods/get.js\";\nimport { Set, DeletePropertyOrThrow } from \"../../methods/properties.js\";\nimport { HasProperty, HasSomeCompatibleType } from \"../../methods/has.js\";\nimport { IsDetachedBuffer, IsCallable } from \"../../methods/is.js\";\nimport { ArrayElementSize, ArrayElementType, ValidateTypedArray, TypedArraySpeciesCreate, IntegerIndexedElementSet, IntegerIndexedElementGet }\n from \"../../methods/typedarray.js\";\nimport { CreateArrayIterator } from \"../../methods/create.js\";\nimport { SetValueInBuffer, GetValueFromBuffer, CloneArrayBuffer } from \"../../methods/arraybuffer.js\";\nimport { SameValue, SameValueZeroPartial, StrictEqualityComparisonPartial } from \"../../methods/abstract.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function (realm: Realm, obj: ObjectValue): void {\n  // ECMA262 22.2.3.1\n  obj.defineNativeGetter(\"buffer\", (context) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, return undefined.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!('$TypedArrayName' in O)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"O does not have a [[TypedArrayName]] internal slot\");\n    }\n\n    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]]\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n\n    // 6. Return buffer.\n    return buffer;\n  });\n\n  // ECMA262 22.2.3.2\n  obj.defineNativeGetter(\"byteLength\", (context) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!('$TypedArrayName' in O)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"O does not have a [[TypedArrayName]] internal slot\");\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer; invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let size be O.[[ByteLength]].\n    let size = O.$ByteLength; invariant(typeof size === \"number\");\n\n    // 8. Return size.\n    return new NumberValue(realm, size);\n  });\n\n\n  // ECMA262 22.2.3.3\n  obj.defineNativeGetter(\"byteOffset\", (context) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!('$TypedArrayName' in O)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"O does not have a [[TypedArrayName]] internal slot\");\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer; invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let offset be O.[[ByteOffset]].\n    let offset = O.$ByteOffset; invariant(typeof offset === \"number\");\n\n    // 8. Return offset.\n    return new NumberValue(realm, offset);\n  });\n\n  // ECMA262 22.2.3.5\n  obj.defineNativeMethod(\"copyWithin\", 2, (context, [target, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. Let relativeTarget be ? ToInteger(target).\n    let relativeTarget = ToInteger(realm, target);\n\n    // 5. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).\n    let to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len);\n\n    // 6. Let relativeStart be ? ToInteger(start).\n    let relativeStart = ToInteger(realm, start);\n\n    // 7. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).\n    let from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = (!end || end instanceof UndefinedValue) ? len : ToInteger(realm, end.throwIfNotConcrete());\n\n    // 9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 10. Let count be min(final-from, len-to).\n    let count = Math.min(final - from, len - to);\n\n    let direction;\n    // 11. If from<to and to<from+count, then\n    if (from < to && to < from + count) {\n      // a. Let direction be -1.\n      direction = -1;\n\n      // b. Let from be from + count - 1.\n      from = from + count - 1;\n\n      // c. Let to be to + count - 1.\n      to = to + count - 1;\n    } else { // 12. Else,\n      // a. Let direction be 1.\n      direction = 1;\n    }\n\n    // 13. Repeat, while count > 0\n    while (count > 0) {\n      // a. Let fromKey be ! ToString(from).\n      let fromKey = ToString(realm, new NumberValue(realm, from));\n\n      // b. Let toKey be ! ToString(to).\n      let toKey = ToString(realm, new NumberValue(realm, to));\n\n      // c. Let fromPresent be ? HasProperty(O, fromKey).\n      let fromPresent = HasProperty(realm, O, fromKey);\n\n      // d. If fromPresent is true, then\n      if (fromPresent === true) {\n        // i. Let fromVal be ? Get(O, fromKey).\n        let fromVal = Get(realm, O, fromKey);\n        // ii. Perform ? Set(O, toKey, fromVal, true).\n        Set(realm, O, toKey, fromVal, true);\n      } else { // e. Else fromPresent is false,\n        // i. Perform ? DeletePropertyOrThrow(O, toKey).\n        DeletePropertyOrThrow(realm, O, toKey);\n      }\n\n      // f. Let from be from + direction.\n      from = from + direction;\n\n      // g. Let to be to + direction.\n      to = to + direction;\n\n      // h. Let count be count - 1.\n      count = count - 1;\n    }\n\n    // 14. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.6\n  obj.defineNativeMethod(\"entries\", 0, (context) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Return CreateArrayIterator(O, \"key+value\").\n    return CreateArrayIterator(realm, O, \"key+value\");\n  });\n\n  // ECMA262 22.2.3.7\n  obj.defineNativeMethod(\"every\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let testResult = ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is false, return false.\n        if (!testResult) return realm.intrinsics.false;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return true.\n    return realm.intrinsics.true;\n  });\n\n  // ECMA262 22.2.3.8\n  obj.defineNativeMethod(\"fill\", 1, (context, [value, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. Let relativeStart be ? ToInteger(start).\n    let relativeStart = ToInteger(realm, start || realm.intrinsics.undefined);\n\n    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = (!end || end instanceof UndefinedValue) ? len : ToInteger(realm, end.throwIfNotConcrete());\n\n    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 8. Repeat, while k < final\n    while (k < final) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Perform ? Set(O, Pk, value, true).\n      Set(realm, O, Pk, value, true);\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.9\n  obj.defineNativeMethod(\"filter\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (IsCallable(realm, callbackfn) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(callbackfn) is false\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let kept be a new empty List.\n    let kept = [];\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Let captured be 0.\n    let captured = 0;\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n      let selected = ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If selected is true, then\n      if (selected === true) {\n        // i. Append kValue to the end of kept.\n        kept.push(kValue);\n\n        // ii. Increase captured by 1.\n        captured += 1;\n      }\n\n      // e. Increase k by 1.\n      k += 1;\n    }\n\n    // 10. Let A be ? TypedArraySpeciesCreate(O, « captured »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, captured)]);\n\n    // 11. Let n be 0.\n    let n = 0;\n\n    // 12. For each element e of kept\n    for (let e of kept) {\n      // a. Perform ! Set(A, ! ToString(n), e, true).\n      Set(realm, A, new StringValue(realm, ToString(realm, new NumberValue(realm, n))), e, true);\n\n      // b. Increment n by 1.\n      n = n + 1;\n    }\n\n    // 13. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.10\n  obj.defineNativeMethod(\"find\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (!IsCallable(realm, predicate)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      let testResult = ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return kValue.\n      if (testResult) return kValue;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.2.3.11\n  obj.defineNativeMethod(\"findIndex\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (IsCallable(realm, predicate) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, new StringValue(realm, Pk));\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      let testResult = ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return k.\n      if (testResult === true) return new NumberValue(realm, k);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 8. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.12\n  obj.defineNativeMethod(\"forEach\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Perform ? Call(callbackfn, T, « kValue, k, O »).\n        Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.2.3.14\n  obj.defineNativeMethod(\"includes\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return false.\n    if (len === 0) return realm.intrinsics.false;\n\n    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = ToInteger(realm, fromIndex || realm.intrinsics.undefined);\n\n    let k;\n    // 6. If n ≥ 0, then\n    if (n >= 0) {\n      // a. Let k be n.\n      k = n;\n    } else { // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let elementK be the result of ? Get(O, ! ToString(k)).\n      let elementK = Get(realm, O, ToString(realm, new NumberValue(realm, k)));\n\n      // b. If SameValueZero(searchElement, elementK) is true, return true.\n      if (SameValueZeroPartial(realm, searchElement, elementK) === true) return realm.intrinsics.true;\n\n      // c. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 9. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.2.3.14\n  obj.defineNativeMethod(\"indexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = fromIndex ? ToInteger(realm, fromIndex) : 0;\n\n    // 6. If n ≥ len, return -1.\n    if (n >= len) return new NumberValue(realm, -1);\n\n    // 7. If n ≥ 0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be n.\n      k = Object.is(n, -0) ? +0 : n;\n    } else { // 8. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, k + \"\");\n\n      // b. If kPresent is true, then\n      if (kPresent === true) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, k + \"\");\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.15\n  obj.defineNativeMethod(\"join\", 1, (context, [separator]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If separator is undefined, let separator be the single-element String \",\".\n    if (!separator || separator instanceof UndefinedValue) separator = new StringValue(realm, \",\");\n\n    // 5. Let sep be ? ToString(separator).\n    let sep = ToStringPartial(realm, separator);\n\n    // 6. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 7. Let element0 be Get(O, \"0\").\n    let element0 = Get(realm, O, \"0\");\n\n    // 8. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).\n    let R: ?string;\n    if (HasSomeCompatibleType(realm, element0, UndefinedValue, NullValue)) {\n      R = \"\";\n    } else {\n      R = ToStringPartial(realm, element0);\n    }\n\n    // 9. Let k be 1.\n    let k = 1;\n\n    // 10. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be the String value produced by concatenating R and sep.\n      let S: string = R + sep;\n\n      // b. Let element be ? Get(O, ! ToString(k)).\n      let element = Get(realm, O, new StringValue(realm, k + \"\"));\n\n      // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).\n      let next: ?string;\n      if (HasSomeCompatibleType(realm, element, UndefinedValue, NullValue)) {\n        next = \"\";\n      } else {\n        next = ToStringPartial(realm, element);\n      }\n\n      // d. Let R be a String value produced by concatenating S and next.\n      R = S + next;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 11. Return R.\n    return new StringValue(realm, R + \"\");\n  });\n\n  // ECMA262 22.2.3.16\n  obj.defineNativeMethod(\"keys\", 0, (context) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Return CreateArrayIterator(O, \"key\").\n    return CreateArrayIterator(realm, O, \"key\");\n  });\n\n  // ECMA262 22.2.3.17\n  obj.defineNativeMethod(\"lastIndexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 5. If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.\n    let n = fromIndex ? ToInteger(realm, fromIndex) : len - 1;\n\n    // 6. If n ≥ 0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be min(n, len - 1).\n      k = Object.is(n, -0) ? +0 : Math.min(n, len - 1);\n    } else { // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n    }\n\n    // 8. Repeat, while k ≥ 0\n    while (k >= 0) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, new StringValue(realm, k + \"\"));\n\n      // b. If kPresent is true, then\n      if (kPresent) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, new StringValue(realm, k + \"\"));\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Decrease k by 1.\n      k--;\n    }\n\n    // 9. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.18\n  obj.defineNativeGetter(\"length\", (context) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!('$TypedArrayName' in O)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"O does not have a [[TypedArrayName]] internal slot\");\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer; invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let length be O.[[ArrayLength]].\n    let length = O.$ArrayLength; invariant(typeof length === \"number\");\n\n    // 8. Return length.\n    return new NumberValue(realm, length);\n  });\n\n  // ECMA262 22.2.3.19\n  obj.defineNativeMethod(\"map\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (IsCallable(realm, callbackfn) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(callbackfn) is false\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let A be ? TypedArraySpeciesCreate(O, « len »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, len)]);\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).\n      let mappedValue = Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n\n      // d. Perform ? Set(A, Pk, mappedValue, true).\n      Set(realm, A, Pk, mappedValue, true);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 9. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.20\n  obj.defineNativeMethod(\"reduce\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // a. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else { // 8. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k < len\n      while (kPresent === false && k < len) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iv. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // v. Increase k by 1.\n        k++;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"kPresent is false\");\n      }\n\n      invariant(accumulator);\n    }\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [accumulator, kValue, new NumberValue(realm, k), O]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.2.3.21\n  obj.defineNativeMethod(\"reduceRight\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Let k be len-1.\n    let k = len - 1;\n\n    // 7. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // 1. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else { // 8. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k ≥ 0\n      while (!kPresent && k >= 0) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iii. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // iv. Decrease k by 1.\n        k--;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent || !accumulator) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n      }\n    }\n\n    // 9. Repeat, while k ≥ 0\n    while (k >= 0) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [accumulator, kValue, new NumberValue(realm, k), O]);\n      }\n\n      // d. Decrease k by 1.\n      k--;\n    }\n\n    // 10. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.2.3.21\n  obj.defineNativeMethod(\"reverse\", 0, (context) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. Let middle be floor(len/2).\n    let middle = Math.floor(len / 2);\n\n    // 5. Let lower be 0.\n    let lower = 0;\n\n    // 6. Repeat, while lower ≠ middle\n    while (lower !== middle) {\n      // a. Let upper be len - lower - 1.\n      let upper = len - lower - 1;\n\n      // b. Let upperP be ! ToString(upper).\n      let upperP = new StringValue(realm, upper + \"\");\n\n      // c. Let lowerP be ! ToString(lower).\n      let lowerP = new StringValue(realm, lower + \"\");\n\n      // d. Let lowerExists be ? HasProperty(O, lowerP).\n      let lowerExists = HasProperty(realm, O, lowerP);\n\n      // e. If lowerExists is true, then\n      let lowerValue;\n      if (lowerExists) {\n        // i. Let lowerValue be ? Get(O, lowerP).\n        lowerValue = Get(realm, O, lowerP);\n      }\n\n      // f. Let upperExists be ? HasProperty(O, upperP).\n      let upperExists = HasProperty(realm, O, upperP);\n\n      // g. If upperExists is true, then\n      let upperValue;\n      if (upperExists) {\n        // i. Let upperValue be ? Get(O, upperP).\n        upperValue = Get(realm, O, upperP);\n      }\n\n      // h. If lowerExists is true and upperExists is true, then\n      if (lowerExists && upperExists) {\n        invariant(lowerValue, \"expected lower value to exist\");\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Set(realm, O, upperP, lowerValue, true);\n      } else if (!lowerExists && upperExists) { // i. Else if lowerExists is false and upperExists is true, then\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? DeletePropertyOrThrow(O, upperP).\n        DeletePropertyOrThrow(realm, O, upperP);\n      } else if (lowerExists && !upperExists) { // j. Else if lowerExists is true and upperExists is false, then\n        invariant(lowerValue, \"expected lower value to exist\");\n\n        // i. Perform ? DeletePropertyOrThrow(O, lowerP).\n        DeletePropertyOrThrow(realm, O, lowerP);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Set(realm, O, upperP, lowerValue, true);\n      } else { // k. Else both lowerExists and upperExists are false,\n        // i. No action is required.\n      }\n\n      // l. Increase lower by 1.\n      lower++;\n    }\n\n    // 7. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.23\n  obj.defineNativeMethod(\"set\", 1, (context, [overloaded, offset]) => {\n    if (!overloaded.$TypedArrayName) {\n      let array = overloaded;\n\n      // 1. Assert: array is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in 22.2.3.23.2 applies.\n      invariant(!(overloaded instanceof ObjectValue && overloaded.$TypedArrayName));\n\n      // 2. Let target be the this value.\n      let target = context.throwIfNotConcrete();\n\n      // 3. If Type(target) is not Object, throw a TypeError exception.\n      if (!(target instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(target) is not Object\");\n      }\n\n      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n      if (typeof target.$TypedArrayName !== \"string\") {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"target does not have a [[TypedArrayName]] internal slot\");\n      }\n\n      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.\n      invariant(target.$ViewedArrayBuffer, \"target has a [[ViewedArrayBuffer]] internal slot\");\n\n      // 6. Let targetOffset be ? ToInteger(offset).\n      let targetOffset = ToInteger(realm, offset || realm.intrinsics.undefined);\n\n      // 7. If targetOffset < 0, throw a RangeError exception.\n      if (targetOffset < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"targetOffset < 0\");\n      }\n\n      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].\n      let targetBuffer = target.$ViewedArrayBuffer; invariant(targetBuffer instanceof ObjectValue);\n\n      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, targetBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n      }\n\n      // 10. Let targetLength be target.[[ArrayLength]].\n      let targetLength = target.$ArrayLength; invariant(typeof targetLength === \"number\");\n\n      // 11. Let targetName be the String value of target.[[TypedArrayName]].\n      let targetName = target.$TypedArrayName; invariant(typeof targetName === \"string\");\n\n      // 12. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.\n      let targetElementSize = ArrayElementSize[targetName];\n\n      // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n      let targetType = ArrayElementType[targetName];\n\n      // 14. Let targetByteOffset be target.[[ByteOffset]].\n      let targetByteOffset = target.$ByteOffset; invariant(typeof targetByteOffset === \"number\");\n\n      // 15. Let src be ? ToObject(array).\n      let src = ToObjectPartial(realm, array);\n\n      // 16. Let srcLength be ? ToLength(? Get(src, \"length\")).\n      let srcLength = ToLength(realm, Get(realm, src, \"length\"));\n\n      // 17. If srcLength + targetOffset > targetLength, throw a RangeError exception.\n      if (srcLength + targetOffset > targetLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"srcLength + targetOffset > targetLength\");\n      }\n\n      // 18. Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.\n      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;\n\n      // 19. Let k be 0.\n      let k = 0;\n\n      // 20. Let limit be targetByteIndex + targetElementSize × srcLength.\n      let limit = targetByteIndex + targetElementSize * srcLength;\n\n      // 21. Repeat, while targetByteIndex < limit\n      while (targetByteIndex < limit) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = ToString(realm, new NumberValue(realm, k));\n\n        // b. Let kNumber be ? ToNumber(? Get(src, Pk)).\n        let kNumber = ToNumber(realm, Get(realm, src, Pk));\n\n        // c. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, targetBuffer) === true) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n        }\n\n        // d. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, kNumber).\n        SetValueInBuffer(realm, targetBuffer, targetByteIndex, targetType, kNumber);\n\n        // e. Set k to k + 1.\n        k = k + 1;\n\n        // f. Set targetByteIndex to targetByteIndex + targetElementSize.\n        targetByteIndex = targetByteIndex + targetElementSize;\n      }\n\n      // 22. Return undefined.\n      return realm.intrinsics.undefined;\n    } else {\n      let typedArray = overloaded;\n\n      // 1. Assert: typedArray has a [[TypedArrayName]] internal slot. If it does not, the definition in 22.2.3.23.1 applies.\n      invariant(typedArray instanceof ObjectValue && typedArray.$TypedArrayName);\n\n      // 2. Let target be the this value.\n      let target = context.throwIfNotConcrete();\n\n      // 3. If Type(target) is not Object, throw a TypeError exception.\n      if (!(target instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(target) is not Object\");\n      }\n\n      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n      if (typeof target.$TypedArrayName !== \"string\") {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"target does not have a [[TypedArrayName]] internal slot\");\n      }\n\n      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.\n      invariant(target.$ViewedArrayBuffer);\n\n      // 6. Let targetOffset be ? ToInteger(offset).\n      let targetOffset = ToInteger(realm, offset || realm.intrinsics.undefined);\n\n      // 7. If targetOffset < 0, throw a RangeError exception.\n      if (targetOffset < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"targetOffset < 0\");\n      }\n\n      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].\n      let targetBuffer = target.$ViewedArrayBuffer; invariant(targetBuffer instanceof ObjectValue);\n\n      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, targetBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n      }\n\n      // 10. Let targetLength be target.[[ArrayLength]].\n      let targetLength = target.$ArrayLength; invariant(typeof targetLength === \"number\");\n\n      // 11. Let srcBuffer be typedArray.[[ViewedArrayBuffer]].\n      let srcBuffer = typedArray.$ViewedArrayBuffer; invariant(srcBuffer);\n\n      // 12. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcBuffer) is true\");\n      }\n\n      // 13. Let targetName be the String value of target.[[TypedArrayName]].\n      let targetName = target.$TypedArrayName;\n      invariant(typeof targetName === \"string\");\n\n      // 14. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n      let targetType = ArrayElementType[targetName];\n\n      // 15. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.\n      let targetElementSize = ArrayElementSize[targetName];\n\n      // 16. Let targetByteOffset be target.[[ByteOffset]].\n      let targetByteOffset = target.$ByteOffset; invariant(typeof targetByteOffset === \"number\");\n\n      // 17. Let srcName be the String value of typedArray.[[TypedArrayName]].\n      let srcName = typedArray.$TypedArrayName;\n      invariant(typeof srcName === \"string\");\n\n      // 18. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n      let srcType = ArrayElementType[srcName];\n\n      // 19. Let srcElementSize be the Number value of the Element Size value specified in Table 50 for srcName.\n      let srcElementSize = ArrayElementSize[srcName];\n\n      // 20. Let srcLength be typedArray.[[ArrayLength]].\n      let srcLength = typedArray.$ArrayLength; invariant(typeof srcLength === \"number\");\n\n      // 21. Let srcByteOffset be typedArray.[[ByteOffset]].\n      let srcByteOffset = typedArray.$ByteOffset; invariant(typeof srcByteOffset === \"number\");\n\n      // 22. If srcLength + targetOffset > targetLength, throw a RangeError exception.\n      if (srcLength + targetOffset > targetLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"srcLength + targetOffset > targetLength\");\n      }\n\n      let srcByteIndex;\n      // 23. If SameValue(srcBuffer, targetBuffer) is true, then\n      if (SameValue(realm, srcBuffer, targetBuffer) === true) {\n        // a. Let srcBuffer be ? CloneArrayBuffer(targetBuffer, srcByteOffset, %ArrayBuffer%).\n        srcBuffer = CloneArrayBuffer(realm, targetBuffer, srcByteOffset, realm.intrinsics.ArrayBuffer);\n\n        // b. NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.\n\n        // c. Let srcByteIndex be 0.\n        srcByteIndex = 0;\n      } else { // 24. Else, let srcByteIndex be srcByteOffset.\n        srcByteIndex = srcByteOffset;\n      }\n\n      // 25. Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.\n      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;\n\n      // 26. Let limit be targetByteIndex + targetElementSize × srcLength.\n      let limit = targetByteIndex + targetElementSize * srcLength;\n\n      // 27. If SameValue(srcType, targetType) is true, then\n      if (srcType === targetType) {\n        // a. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n        // b. Repeat, while targetByteIndex < limit\n        while (targetByteIndex < limit) {\n          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\").\n          let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, \"Uint8\");\n\n          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value).\n          SetValueInBuffer(realm, targetBuffer, targetByteIndex, \"Uint8\", value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + 1.\n          srcByteIndex += 1;\n\n          // iv. Set targetByteIndex to targetByteIndex + 1.\n          targetByteIndex += 1;\n        }\n      } else { // 28. Else,\n        // a. Repeat, while targetByteIndex < limit\n        while (targetByteIndex < limit) {\n          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, srcType).\n          let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, srcType);\n\n          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value).\n          SetValueInBuffer(realm, targetBuffer, targetByteIndex, targetType, value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + srcElementSize.\n          srcByteIndex = srcByteIndex + srcElementSize;\n\n          // iv. Set targetByteIndex to targetByteIndex + targetElementSize.\n          targetByteIndex = targetByteIndex + targetElementSize;\n        }\n      }\n\n      // 29. Return undefined.\n      return realm.intrinsics.undefined;\n    }\n  });\n\n  // ECMA262 22.2.3.24\n  obj.defineNativeMethod(\"slice\", 2, (context, [start, end]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. Let relativeStart be ? ToInteger(start).\n    let relativeStart = ToInteger(realm, start);\n\n    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : ToInteger(realm, end.throwIfNotConcrete());\n\n    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 8. Let count be max(final - k, 0).\n    let count = Math.max(final - k, 0);\n\n    // 9. Let A be ? TypedArraySpeciesCreate(O, « count »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, count)]);\n\n    // 10. Let srcName be the String value of O.[[TypedArrayName]].\n    let srcName = O.$TypedArrayName; invariant(typeof srcName === \"string\");\n\n    // 11. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n    let srcType = ArrayElementType[srcName];\n\n    // 12. Let targetName be the String value of A.[[TypedArrayName]].\n    let targetName = A.$TypedArrayName; invariant(typeof targetName === \"string\");\n\n    // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n    let targetType = ArrayElementType[targetName];\n\n    // 14. If SameValue(srcType, targetType) is false, then\n    if (srcType !== targetType) {\n      // a. Let n be 0.\n      let n = 0;\n\n      // b. Repeat, while k < final\n      while (k < final) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = ToString(realm, new NumberValue(realm, k));\n\n        // ii. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // iii. Perform ! Set(A, ! ToString(n), kValue).\n        Set(realm, A, ToString(realm, new NumberValue(realm, n)), kValue, true);\n\n        // iv. Increase k by 1.\n        k += 1;\n\n        // v. Increase n by 1.\n        n += 1;\n      }\n    } else if (count > 0) { // 15. Else if count > 0, then\n      // a. Let srcBuffer be O.[[ViewedArrayBuffer]].\n      let srcBuffer = O.$ViewedArrayBuffer; invariant(srcBuffer);\n\n      // b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcBuffer) is true\");\n      }\n\n      // c. Let targetBuffer be A.[[ViewedArrayBuffer]].\n      let targetBuffer = A.$ViewedArrayBuffer; invariant(targetBuffer instanceof ObjectValue);\n\n      // d. Let elementSize be the Number value of the Element Size value specified in Table 50 for srcType.\n      let elementSize = ElementSize[srcType];\n\n      // e. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n      // f. Let srcByteOffset be O.[[ByteOffset]].\n      let srcByteOffset = O.$ByteOffset; invariant(typeof srcByteOffset === \"number\");\n\n      // g. Let targetByteIndex be A.[[ByteOffset]].\n      let targetByteIndex = A.$ByteOffset; invariant(typeof targetByteIndex === \"number\");\n\n      // h. Let srcByteIndex be (k × elementSize) + srcByteOffset.\n      let srcByteIndex = k * elementSize + srcByteOffset;\n\n      // i. Let limit be targetByteIndex + count × elementSize.\n      let limit = targetByteIndex + count * elementSize;\n\n      // j. Repeat, while targetByteIndex < limit\n      while (targetByteIndex < limit) {\n        // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\").\n        let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, \"Uint8\");\n\n        // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value).\n        SetValueInBuffer(realm, targetBuffer, targetByteIndex, \"Uint8\", value.value);\n\n        // iii. Increase srcByteIndex by 1.\n        srcByteIndex += 1;\n\n        // iv. Increase targetByteIndex by 1.\n        targetByteIndex += 1;\n      }\n    }\n\n    // 16. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.25\n  obj.defineNativeMethod(\"some\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"callback passed to Array.prototype.some isn't callable\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let testResult = ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is true, return true.\n        if (testResult) return realm.intrinsics.true;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.2.3.26\n  obj.defineNativeMethod(\"sort\", 1, (context, [comparefn]) => {\n    // 1. Let obj be the this value.\n    let O = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Let buffer be ? ValidateTypedArray(obj).\n    let buffer = ValidateTypedArray(realm, O);\n\n    // 3. Let len be the value of obj's [[ArrayLength]] internal slot.\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 22.2.3.26 Runtime Semantics: SortCompare( x, y )#\n    let SortCompare = (x, y) => {\n      // 1. Assert: Both Type(x) and Type(y) is Number.\n      invariant(x instanceof NumberValue);\n      invariant(y instanceof NumberValue);\n\n      // 2. If the argument comparefn is not undefined, then\n      if (!comparefn.mightBeUndefined()) {\n        // a. Let v be ? Call(comparefn, undefined, « x, y »).\n        let v = Call(realm, comparefn, realm.intrinsics.undefined, [x, y]);\n\n        // b. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, buffer) === true)\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"array buffer has been detached\");\n\n        // c. If v is NaN, return +0.\n        if (v instanceof NumberValue && isNaN(v.value)) return realm.intrinsics.zero;\n\n        // d. Return v.\n        return v;\n      }\n      comparefn.throwIfNotConcrete();\n\n      // If x and y are both NaN, return +0.\n      // If x is NaN, return 1.\n       if (isNaN(x.value)) {\n         if (isNaN(y.value)) return realm.intrinsics.zero;\n         return new NumberValue(realm, 1);\n       }\n\n      // If y is NaN, return -1.\n      if (isNaN(y.value)) return new NumberValue(realm, -1);\n\n      // If x < y, return -1.\n      if (x.value < y.value) return new NumberValue(realm, -1);\n\n      // If x > y, return 1.\n      if (x.value > y.value) return new NumberValue(realm, +1);\n\n      // If x is -0 and y is +0, return -1.\n      if (Object.is(x.value, -0) && Object.is(y.value, +0))\n        return new NumberValue(realm, -1);\n\n      // If x is +0 and y is -0, return 1.\n      if (Object.is(x.value, +0) && Object.is(y.value, -0))\n        return new NumberValue(realm, 1);\n\n      // Return +0.\n      return realm.intrinsics.zero;\n    };\n\n    //1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:\n    //   The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.\n\n    // We leverage the underlying implementation sort by copying the element in a temp. array, sorting it, and\n    // transfering back the value inside the our array.\n\n    // We need to adapt the comparefn function to match the expected types\n    let comparefn_ = (x, y) => {\n      invariant(x instanceof NumberValue, \"Unexpected type\");\n      invariant(y instanceof NumberValue, \"Unexpected type\");\n\n      let result_ = SortCompare(x, y);\n      let numb = ToNumber(realm, result_);\n      return numb;\n    };\n\n    let arr = [];\n    for (let j = 0; j < len; j++) {\n      let val = IntegerIndexedElementGet(realm, O, j);\n      arr[j] = val;\n    }\n\n    arr.sort(comparefn_);\n\n    //Apply the permutation back to the original array.\n    for (let j = 0; j < len; j++){\n      IntegerIndexedElementSet(realm, O, j, arr[j]);\n    }\n\n    // 2. Return obj;\n    return context;\n  });\n\n  // ECMA262 22.2.3.27\n  obj.defineNativeMethod(\"subarray\", 2, (context, [begin, end]) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!('$TypedArrayName' in O)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"O does not have a [[TypedArrayName]] internal slot\");\n    }\n\n    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer; invariant(buffer);\n\n    // 6. Let srcLength be O.[[ArrayLength]].\n    let srcLength = O.$ArrayLength; invariant(typeof srcLength === \"number\");\n\n    // 7. Let relativeBegin be ? ToInteger(begin).\n    let relativeBegin = ToInteger(realm, begin);\n\n    // 8. If relativeBegin < 0, let beginIndex be max((srcLength + relativeBegin), 0); else let beginIndex be min(relativeBegin, srcLength).\n    let beginIndex = relativeBegin < 0 ? Math.max(srcLength + relativeBegin, 0) : Math.min(relativeBegin, srcLength);\n\n    // 9. If end is undefined, let relativeEnd be srcLength; else, let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? srcLength : ToInteger(realm, end.throwIfNotConcrete());\n\n    // 10. If relativeEnd < 0, let endIndex be max((srcLength + relativeEnd), 0); else let endIndex be min(relativeEnd, srcLength).\n    let endIndex = relativeEnd < 0 ? Math.max(srcLength + relativeEnd, 0) : Math.min(relativeEnd, srcLength);\n\n    // 11. Let newLength be max(endIndex - beginIndex, 0).\n    let newLength = Math.max(endIndex - beginIndex, 0);\n\n    // 12. Let constructorName be the String value of O.[[TypedArrayName]].\n    let constructorName = O.$TypedArrayName; invariant(typeof constructorName === \"string\");\n\n    // 13. Let elementSize be the Number value of the Element Size value specified in Table 50 for constructorName.\n    let elementSize = ArrayElementSize[constructorName];\n\n    // 14. Let srcByteOffset be O.[[ByteOffset]].\n    let srcByteOffset = O.$ByteOffset; invariant(typeof srcByteOffset === \"number\");\n\n    // 15. Let beginByteOffset be srcByteOffset + beginIndex × elementSize.\n    let beginByteOffset = srcByteOffset + beginIndex * elementSize;\n\n    // 16. Let argumentsList be « buffer, beginByteOffset, newLength ».\n    let argumentsList = [buffer, new NumberValue(realm, beginByteOffset), new NumberValue(realm, newLength)];\n\n    // 17. Return ? TypedArraySpeciesCreate(O, argumentsList).\n    return TypedArraySpeciesCreate(realm, O, argumentsList);\n  });\n\n  // ECMA262 22.2.3.28\n  obj.defineNativeMethod(\"toLocaleString\", 0, (context) => {\n    // 1. Let array be ? ToObject(this value).\n    let array = ToObject(realm, context.throwIfNotConcrete());\n\n    // 2. Perform ? ValidateTypedArray(array).\n    ValidateTypedArray(realm, array);\n\n    // 3. Let len be array.[[ArrayLength]].\n    let len = array.$ArrayLength; invariant(typeof len === \"number\");\n\n    // 4. Let separator be the String value for the list-separator String appropriate for the host environment's current locale (this is derived in an implementation-defined way).\n    let separator = \",\";\n\n    // 5. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 6. Let firstElement be ? Get(array, \"0\").\n    let firstElement = Get(realm, array, \"0\");\n\n    // 7. If firstElement is undefined or null, then\n    let R: ?string;\n    if (HasSomeCompatibleType(realm, firstElement, UndefinedValue, NullValue)) {\n      // a. Let R be the empty String.\n      R = \"\";\n    } else { // 8. Else,\n      // a. Let R be ? ToString(? Invoke(firstElement, \"toLocaleString\")).\n      R = ToStringPartial(realm, Invoke(realm, firstElement, \"toLocaleString\"));\n    }\n\n    // 9. Let k be 1.\n    let k = 1;\n\n    // 10. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be a String value produced by concatenating R and separator.\n      let S: string = R + separator;\n\n      // b. Let nextElement be ? Get(array, ! ToString(k)).\n      let nextElement = Get(realm, array, new StringValue(realm, k + \"\"));\n\n      // c. If nextElement is undefined or null, then\n      if (HasSomeCompatibleType(realm, nextElement, UndefinedValue, NullValue)) {\n        // i. Let R be the empty String.\n        R = \"\";\n      } else { // d. Else,\n        // i. Let R be ? ToString(? Invoke(nextElement, \"toLocaleString\")).\n        R = ToStringPartial(realm, Invoke(realm, nextElement, \"toLocaleString\"));\n      }\n\n      // e. Let R be a String value produced by concatenating S and R.\n      R = S + R;\n\n      // f. Increase k by 1.\n      k++;\n    }\n\n    // 11. Return R.\n    return new StringValue(realm, R);\n  });\n\n  // ECMA262 22.2.3.29\n  obj.defineNativeProperty(\"toString\", realm.intrinsics.ArrayProto_toString);\n\n  // ECMA262 22.2.3.30\n  obj.defineNativeProperty(\"values\", realm.intrinsics.TypedArrayProto_values);\n\n  // ECMA262 22.2.3.31\n  obj.defineNativeProperty(realm.intrinsics.SymbolIterator, realm.intrinsics.TypedArrayProto_values);\n\n  // ECMA262 22.2.3.32\n  obj.defineNativeGetter(realm.intrinsics.SymbolToStringTag, (context) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, return undefined.\n    if (!(O instanceof ObjectValue)) return realm.intrinsics.undefined;\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, return undefined.\n    if (!('$TypedArrayName' in O)) return realm.intrinsics.undefined;\n\n    // 4. Let name be O.[[TypedArrayName]].\n    let name = O.$TypedArrayName;\n\n    // 5. Assert: name is a String value.\n    invariant(typeof name === \"string\", \"name is a String value\");\n\n    // 6. Return name.\n    return new StringValue(realm, name);\n  });\n}\n\nexport function build(realm: Realm, obj: ObjectValue, type: ElementType): void {\n  // ECMA262 22.2.6\n  obj.$Prototype = realm.intrinsics.TypedArrayPrototype;\n\n  // ECMA262 22.2.6.1\n  obj.defineNativeConstant(\"BYTES_PER_ELEMENT\", new NumberValue(realm, ElementSize[type]));\n}\n"]}