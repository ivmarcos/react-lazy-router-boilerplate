{"version":3,"sources":["../../../src/intrinsics/ecma262/NumberPrototype.js"],"names":["realm","obj","$NumberData","intrinsics","zero","defineNativeMethod","context","fractionDigits","x","value","throwIfNotConcrete","f","isNaN","s","Infinity","createErrorThrowCompletion","RangeError","positiveResultString","toExponential","undefined","toFixed","isPartial","deriveAbstract","topVal","n","buildToLocaleString","VALUE","toLocaleString","precision","num","p","toPrecision","radix","radixNumber","TypeError","toString"],"mappings":"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","file":"NumberPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { ObjectValue, StringValue, UndefinedValue } from \"../../values/index.js\";\nimport { ToInteger, ToString, thisNumberValue } from \"../../methods/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../../domains/index.js\";\nimport invariant from \"../../invariant.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\n\nlet buildToLocaleString = buildExpressionTemplate(\"(VALUE).toLocaleString()\");\n\nexport default function (realm: Realm, obj: ObjectValue): void {\n  // ECMA262 20.1.3\n  obj.$NumberData = realm.intrinsics.zero;\n\n  // ECMA262 20.1.3.2\n  obj.defineNativeMethod(\"toExponential\", 1, (context, [fractionDigits]) => {\n    // 1. Let x be ? thisNumberValue(this value).\n    let x = thisNumberValue(realm, context).value;\n\n    // 2. Let f be ? ToInteger(fractionDigits).\n    fractionDigits = fractionDigits.throwIfNotConcrete();\n    let f = ToInteger(realm, fractionDigits);\n\n    // 3. Assert: f is 0, when fractionDigits is undefined.\n    invariant(f === 0 || !(fractionDigits instanceof UndefinedValue));\n\n    // 4. If x is NaN, return the String \"NaN\".\n    if (isNaN(x)) return new StringValue(realm, \"NaN\");\n\n    // 5. Let s be the empty String.\n    let s = \"\";\n\n    // 6. If x < 0, then\n    if (x < 0) {\n      // 6a. Let s be \"-\".\n      s = \"-\";\n\n      // 6b. Let x be -x.\n      x = -x;\n    }\n\n    // 7. If x = +∞, then\n    if (x === +Infinity) {\n      // 7a. Return the concatenation of the Strings s and \"Infinity\".\n      return new StringValue(realm, s + \"Infinity\");\n    }\n\n    // 8. If f < 0 or f > 20, throw a RangeError exception. However, an implementation is permitted to extend the behaviour of toExponential for values of f less than 0 or greater than 20. In this case toExponential would not necessarily throw RangeError for such values.\n    if (f < 0 || f > 20) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"f < 0 || f > 20\");\n    }\n\n    let positiveResultString = x.toExponential(fractionDigits instanceof UndefinedValue ? undefined : f);\n    return new StringValue(realm, s + positiveResultString);\n  });\n\n  // ECMA262 20.1.3.3\n  obj.defineNativeMethod(\"toFixed\", 1, (context, [fractionDigits]) => {\n    // 1. Let f be ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0).\n    let f = ToInteger(realm, fractionDigits);\n\n    // 2. If f < 0 or f > 20, throw a RangeError exception.\n    if (f < 0 || f > 20) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"f < 0 || f > 20\");\n    }\n\n    // 3. Let x be this Number value.\n    let x = thisNumberValue(realm, context).value;\n\n    // 4. If x is NaN, return the String \"NaN\".\n    if (isNaN(x)) return new StringValue(realm, \"NaN\");\n\n    return new StringValue(realm, x.toFixed(f));\n  });\n\n  // ECMA262 20.1.3.4\n  obj.defineNativeMethod(\"toLocaleString\", 0, (context) => {\n    let x = thisNumberValue(realm, context);\n    if (realm.isPartial) {\n      // The locale is environment-dependent\n      return realm.deriveAbstract(new TypesDomain(StringValue), ValuesDomain.topVal, [x], ([n]) => buildToLocaleString({\n        VALUE: n\n      }));\n    } else {\n      return new StringValue(realm, x.toLocaleString());\n    }\n  });\n\n  // ECMA262 20.1.3.5\n  obj.defineNativeMethod(\"toPrecision\", 1, (context, [precision]) => {\n    // 1. Let x be ? thisNumberValue(this value).\n    let num = thisNumberValue(realm, context);\n    // 2. If precision is undefined, return ! ToString(x).\n    if (precision instanceof UndefinedValue) {\n      return new StringValue(realm, ToString(realm, num));\n    }\n    // 3. Let p be ? ToInteger(precision).\n    let p = ToInteger(realm, precision.throwIfNotConcrete());\n    // 4. If x is NaN, return the String \"NaN\".\n    let x = num.value;\n    if (isNaN(x)) {\n      return new StringValue(realm, \"NaN\");\n    }\n    // 5. Let s be the empty String.\n    let s = \"\";\n    // 6. If x < 0, then\n    if (x < 0) {\n      // a. Let s be code unit 0x002D (HYPHEN-MINUS).\n      s = \"-\";\n      // b. Let x be -x.\n      x = -x;\n    }\n    // 7. If x = +∞, then\n    if (x === +Infinity) {\n      // a. Return the String that is the concatenation of s and \"Infinity\".\n      return new StringValue(realm, s + \"Infinity\");\n    }\n    // 8. If p < 1 or p > 21, throw a RangeError exception.\n    // However, an implementation is permitted to extend the behaviour of\n    // toPrecision for values of p less than 1 or greater than 21.\n    // In this case toPrecision would not necessarily throw RangeError for such\n    // values.\n    if (p < 1 || p > 21) {\n      // for simplicity, throw the error\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"p should be in between 1 and 21 inclusive\");\n    }\n    return new StringValue(realm, s + x.toPrecision(p));\n  });\n\n  // ECMA262 20.1.3.6\n  obj.defineNativeMethod(\"toString\", 1, (context, [radix]) => {\n    // 1. Let x be ? thisNumberValue(this value).\n    let x = thisNumberValue(realm, context);\n\n    // 2. If radix is not present, let radixNumber be 10.\n    // 3. Else if radix is undefined, let radixNumber be 10.\n    let radixNumber;\n    if (!radix || radix instanceof UndefinedValue) {\n      radixNumber = 10;\n    } else { // 4. Else let radixNumber be ? ToInteger(radix).\n      radixNumber = ToInteger(realm, radix.throwIfNotConcrete());\n    }\n\n    // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.\n    if (radixNumber < 2 || radixNumber > 36) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. If radixNumber = 10, return ! ToString(x).\n    if (radixNumber === 10) return new StringValue(realm, ToString(realm, x));\n\n    // 7. Return the String representation of this Number value using the radix specified by radixNumber.\n    //    Letters a-z are used for digits with values 10 through 35. The precise algorithm is\n    //    implementation-dependent, however the algorithm should be a generalization of that specified in\n    //    7.1.12.1.\n    return new StringValue(realm, x.value.toString(radixNumber));\n  });\n\n  // ECMA262 20.1.3.7\n  obj.defineNativeMethod(\"valueOf\", 0, (context) => {\n    // 1. Return ? thisNumberValue(this value).\n    return thisNumberValue(realm, context);\n  });\n}\n"]}