{"version":3,"sources":["../../../src/intrinsics/ecma262/RegExpPrototype.js"],"names":["realm","obj","defineNativeMethod","context","string","R","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","$RegExpMatcher","undefined","S","defineNativeGetter","result","global","ignoreCase","multiline","unicode","sticky","InternalHasFlag","SymbolMatch","rx","fullUnicode","zero","A","n","null","matchStr","status","thisIndex","nextIndex","SymbolReplace","replaceValue","lengthS","length","functionalReplace","results","done","push","accumulatedResult","nextSourcePosition","nCaptures","Math","max","matched","matchLength","position","min","captures","capN","mightBeUndefined","replacement","replacerArgs","capture","concat","replValue","value","substr","SymbolSearch","previousLastIndex","$OriginalSource","RegExpPrototype","$OriginalFlags","src","flags","SymbolSplit","limit","C","RegExp","unicodeMatching","indexOf","newFlags","splitter","lengthA","lim","pow","size","p","z","q","e","T","numberOfCaptures","i","nextCapture","match","pattern","flag","true","false"],"mappings":"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","file":"RegExpPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport invariant from \"../../invariant.js\";\nimport { BooleanValue, StringValue, ObjectValue, NullValue, NumberValue, UndefinedValue, Value } from \"../../values/index.js\";\nimport { ArrayCreate, CreateDataProperty } from \"../../methods/create.js\";\nimport { SameValue } from \"../../methods/abstract.js\";\nimport { Call } from \"../../methods/call.js\";\nimport { Construct, SpeciesConstructor } from \"../../methods/construct.js\";\nimport { Get, GetSubstitution } from \"../../methods/get.js\";\nimport { Set } from \"../../methods/properties.js\";\nimport { IsCallable } from \"../../methods/is.js\";\nimport { ToString, ToStringPartial, ToBooleanPartial, ToLength, ToInteger, ToUint32 } from \"../../methods/to.js\";\nimport { RegExpBuiltinExec, RegExpExec, EscapeRegExpPattern, AdvanceStringIndex } from \"../../methods/regexp.js\";\n\nfunction InternalHasFlag(realm: Realm, context: Value, flag: string): Value {\n  // 1. Let R be the this value.\n  let R = context.throwIfNotConcrete();\n\n  // 2. If Type(R) is not Object, throw a TypeError exception.\n  if (!(R instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n  }\n\n  // 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception.\n  if (typeof R.$OriginalFlags !== \"string\") {\n    // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.\n    if (SameValue(realm, R, realm.intrinsics.RegExpPrototype)) {\n      return realm.intrinsics.undefined;\n    } else { // b. Otherwise, throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"R does not have an [[OriginalFlags]] internal slot\");\n    }\n  }\n\n  // 4. Let flags be the value of R's [[OriginalFlags]] internal slot.\n  let flags = R.$OriginalFlags;\n\n  // 5. If flags contains the code unit \"g\", return true.\n  if (flags.indexOf(flag) >= 0) {\n    return realm.intrinsics.true;\n  }\n\n  // 6. Return false.\n  return realm.intrinsics.false;\n}\n\nexport default function (realm: Realm, obj: ObjectValue): void {\n  // ECMA262 21.2.5.2\n  obj.defineNativeMethod(\"exec\", 1, (context, [string]) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.\n    if (R.$RegExpMatcher === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"R does not have a [[RegExpMatcher]] internal slot\");\n    }\n\n    // 4. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 5. Return ? RegExpBuiltinExec(R, S).\n    return RegExpBuiltinExec(realm, R, S);\n  });\n\n  // ECMA262 21.2.5.3\n  obj.defineNativeGetter(\"flags\", (context) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let result be the empty String.\n    let result = \"\";\n\n    // 4. Let global be ToBoolean(? Get(R, \"global\")).\n    let global = ToBooleanPartial(realm, Get(realm, R, \"global\"));\n\n    // 5. If global is true, append \"g\" as the last code unit of result.\n    if (global) result += \"g\";\n\n    // 6. Let ignoreCase be ToBoolean(? Get(R, \"ignoreCase\")).\n    let ignoreCase = ToBooleanPartial(realm, Get(realm, R, \"ignoreCase\"));\n\n    // 7. If ignoreCase is true, append \"i\" as the last code unit of result.\n    if (ignoreCase) result += \"i\";\n\n    // 8. Let multiline be ToBoolean(? Get(R, \"multiline\")).\n    let multiline = ToBooleanPartial(realm, Get(realm, R, \"multiline\"));\n\n    // 9. If multiline is true, append \"m\" as the last code unit of result.\n    if (multiline) result += \"m\";\n\n    // 10. Let unicode be ToBoolean(? Get(R, \"unicode\")).\n    let unicode = ToBooleanPartial(realm, Get(realm, R, \"unicode\"));\n\n    // 11. If unicode is true, append \"u\" as the last code unit of result.\n    if (unicode) result += \"u\";\n\n    // 12. Let sticky be ToBoolean(? Get(R, \"sticky\")).\n    let sticky = ToBooleanPartial(realm, Get(realm, R, \"sticky\"));\n\n    // 13. If sticky is true, append \"y\" as the last code unit of result.\n    if (sticky) result += \"y\";\n\n    // 14. Return result.\n    return new StringValue(realm, result);\n  });\n\n  // ECMA262 21.2.5.4\n  obj.defineNativeGetter(\"global\", (context) => {\n    return InternalHasFlag(realm, context, \"g\");\n  });\n\n  // ECMA262 21.2.5.5\n  obj.defineNativeGetter(\"ignoreCase\", (context) => {\n    return InternalHasFlag(realm, context, \"i\");\n  });\n\n  // ECMA262 21.2.5.6\n  obj.defineNativeMethod(realm.intrinsics.SymbolMatch, 1, (context, [string]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 4. Let global be ToBoolean(? Get(rx, \"global\")).\n    let global = ToBooleanPartial(realm, Get(realm, rx, \"global\"));\n\n    // 5. If global is false, then\n    if (global === false) {\n      // a. Return ? RegExpExec(rx, S).\n      return RegExpExec(realm, rx, S);\n    } else { // 6. Else global is true,\n      // a. Let fullUnicode be ToBoolean(? Get(rx, \"unicode\")).\n      let fullUnicode = ToBooleanPartial(realm, Get(realm, rx, \"unicode\"));\n\n      // b. Perform ? Set(rx, \"lastIndex\", 0, true).\n      Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n\n      // c. Let A be ArrayCreate(0).\n      let A = ArrayCreate(realm, 0);\n\n      // d. Let n be 0.\n      let n = 0;\n\n      // e. Repeat,\n      while (true) {\n        // i. Let result be ? RegExpExec(rx, S).\n        let result = RegExpExec(realm, rx, S);\n\n        // ii. If result is null, then\n        if (result instanceof NullValue) {\n          // 1. If n=0, return null.\n          if (n === 0) {\n            return realm.intrinsics.null;\n          } else { // 2. Else, return A.\n            return A;\n          }\n        } else { // iii. Else result is not null,\n          // 1. Let matchStr be ? ToString(? Get(result, \"0\")).\n          let matchStr = ToStringPartial(realm, Get(realm, result, \"0\"));\n\n          // 2. Let status be CreateDataProperty(A, ! ToString(n), matchStr).\n          let status = CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, n)), new StringValue(realm, matchStr));\n\n          // 3. Assert: status is true.\n          invariant(status === true, \"status is true\");\n\n          // 4. If matchStr is the empty String, then\n          if (matchStr === \"\") {\n            // a. Let thisIndex be ? ToLength(? Get(rx, \"lastIndex\")).\n            let thisIndex = ToLength(realm, Get(realm, rx, \"lastIndex\"));\n\n            // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).\n            let nextIndex = AdvanceStringIndex(realm, S, thisIndex, fullUnicode);\n\n            // c .Perform ? Set(rx, \"lastIndex\", nextIndex, true).\n            Set(realm, rx, \"lastIndex\", new NumberValue(realm, nextIndex), true);\n          }\n\n          // 5. Increment n.\n          n += 1;\n        }\n      }\n\n      invariant(false);\n    }\n  });\n\n  // ECMA262 21.2.5.7\n  obj.defineNativeGetter(\"multiline\", (context) => {\n    return InternalHasFlag(realm, context, \"m\");\n  });\n\n  // ECMA262 21.2.5.8\n  obj.defineNativeMethod(realm.intrinsics.SymbolReplace, 2, (context, [string, replaceValue]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 4. Let lengthS be the number of code unit elements in S.\n    let lengthS = S.length;\n\n    // 5. Let functionalReplace be IsCallable(replaceValue).\n    let functionalReplace = IsCallable(realm, replaceValue);\n\n    // 6. If functionalReplace is false, then\n    if (functionalReplace === false) {\n      // a. Let replaceValue be ? ToString(replaceValue).\n      replaceValue = new StringValue(realm, ToStringPartial(realm, replaceValue));\n    }\n\n    // 7. Let global be ToBoolean(? Get(rx, \"global\")).\n    let global = ToBooleanPartial(realm, Get(realm, rx, \"global\"));\n\n    let fullUnicode;\n    // 8. If global is true, then\n    if (global === true) {\n      // a. Let fullUnicode be ToBoolean(? Get(rx, \"unicode\")).\n      fullUnicode = ToBooleanPartial(realm, Get(realm, rx, \"unicode\"));\n\n      // b. Perform ? Set(rx, \"lastIndex\", 0, true).\n      Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n    }\n\n    // 9. Let results be a new empty List.\n    let results = [];\n\n    // 10. Let done be false.\n    let done = false;\n\n    // 11. Repeat, while done is false\n    while (done === false) {\n      // a. Let result be ? RegExpExec(rx, S).\n      let result = RegExpExec(realm, rx, S);\n\n      // b. If result is null, set done to true.\n      if (result instanceof NullValue) {\n        done = true;\n      } else { // c. Else result is not null,\n        // i. Append result to the end of results.\n        results.push(result);\n\n        // ii. If global is false, set done to true.\n        if (global === false) {\n          done = true;\n        } else { // iii. Else,\n          invariant(fullUnicode !== undefined);\n\n          // 1. Let matchStr be ? ToString(? Get(result, \"0\")).\n          let matchStr = ToStringPartial(realm, Get(realm, result, \"0\"));\n\n          // 2. If matchStr is the empty String, then\n          if (matchStr === \"\") {\n            // a. Let thisIndex be ? ToLength(? Get(rx, \"lastIndex\")).\n            let thisIndex = ToLength(realm, Get(realm, rx, \"lastIndex\"));\n\n            // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).\n            let nextIndex = AdvanceStringIndex(realm, S, thisIndex, fullUnicode);\n\n            // c. Perform ? Set(rx, \"lastIndex\", nextIndex, true).\n            Set(realm, rx, \"lastIndex\", new NumberValue(realm, nextIndex), true);\n          }\n        }\n      }\n    }\n\n    // 12. Let accumulatedResult be the empty String value.\n    let accumulatedResult = \"\";\n\n    // 13. Let nextSourcePosition be 0.\n    let nextSourcePosition = 0;\n\n    // 14. Repeat, for each result in results,\n    for (let result of results) {\n      // a. Let nCaptures be ? ToLength(? Get(result, \"length\")).\n      let nCaptures = ToLength(realm, Get(realm, result, \"length\"));\n\n      // b. Let nCaptures be max(nCaptures - 1, 0).\n      nCaptures = Math.max(nCaptures - 1, 0);\n\n      // c. Let matched be ? ToString(? Get(result, \"0\")).\n      let matched = ToStringPartial(realm, Get(realm, result, \"0\"));\n\n      // d. Let matchLength be the number of code units in matched.\n      let matchLength = matched.length;\n\n      // e. Let position be ? ToInteger(? Get(result, \"index\")).\n      let position = ToInteger(realm, Get(realm, result, \"index\"));\n\n      // f. Let position be max(min(position, lengthS), 0).\n      position = Math.max(Math.min(position, lengthS), 0);\n\n      // g. Let n be 1.\n      let n = 1;\n\n      // h. Let captures be a new empty List.\n      let captures = [];\n\n      // i. Repeat while n ≤ nCaptures\n      while (n <= nCaptures) {\n        // i. Let capN be ? Get(result, ! ToString(n)).\n        let capN = Get(realm, result, ToString(realm, new NumberValue(realm, n)));\n\n        // ii. If capN is not undefined, then\n        if (!capN.mightBeUndefined()) {\n          // 1. Let capN be ? ToString(capN).\n          capN = ToStringPartial(realm, capN);\n        } else {\n          capN.throwIfNotConcrete();\n          capN = undefined;\n        }\n\n        // iii. Append capN as the last element of captures.\n        captures.push(capN);\n\n        // iv. Let n be n+1.\n        n = n + 1;\n      }\n\n      let replacement;\n      // j. If functionalReplace is true, then\n      if (functionalReplace) {\n        // i. Let replacerArgs be « matched ».\n        let replacerArgs = [new StringValue(realm, matched)];\n\n        // ii. Append in list order the elements of captures to the end of the List replacerArgs.\n        for (let capture of captures) {\n          replacerArgs.push(capture === undefined ? realm.intrinsics.undefined : new StringValue(realm, capture));\n        }\n\n        // iii. Append position and S as the last two elements of replacerArgs.\n        replacerArgs = replacerArgs.concat([new NumberValue(realm, position), new StringValue(realm, S)]);\n\n        // iv. Let replValue be ? Call(replaceValue, undefined, replacerArgs).\n        let replValue = Call(realm, replaceValue, realm.intrinsics.undefined, replacerArgs);\n\n        // v. Let replacement be ? ToString(replValue).\n        replacement = ToStringPartial(realm, replValue);\n      } else { // k. Else,\n        invariant(replaceValue instanceof StringValue);\n        // i. Let replacement be GetSubstitution(matched, S, position, captures, replaceValue).\n        replacement = GetSubstitution(realm, matched, S, position, captures, replaceValue.value);\n      }\n\n      // l. If position ≥ nextSourcePosition, then\n      if (position >= nextSourcePosition) {\n        // i. NOTE position should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of rx. In such cases, the corresponding substitution is ignored.\n        // ii. Let accumulatedResult be the String formed by concatenating the code units of the current value of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up to position (exclusive) and with the code units of replacement.\n        accumulatedResult = accumulatedResult + S.substr(nextSourcePosition, position - nextSourcePosition) + replacement;\n\n        // iii. Let nextSourcePosition be position + matchLength.\n        nextSourcePosition = position + matchLength;\n      }\n    }\n    // 15. If nextSourcePosition ≥ lengthS, return accumulatedResult.\n    if (nextSourcePosition >= lengthS) return new StringValue(realm, accumulatedResult);\n\n    // 16. Return the String formed by concatenating the code units of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up through the final code unit of S (inclusive).\n    return new StringValue(realm, accumulatedResult + S.substr(nextSourcePosition));\n  });\n\n  // ECMA262 21.2.5.9\n  obj.defineNativeMethod(realm.intrinsics.SymbolSearch, 1, (context, [string]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 4. Let previousLastIndex be ? Get(rx, \"lastIndex\").\n    let previousLastIndex = Get(realm, rx, \"lastIndex\");\n\n    // 5. Perform ? Set(rx, \"lastIndex\", 0, true).\n    Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n\n    // 6. Let result be ? RegExpExec(rx, S).\n    let result = RegExpExec(realm, rx, S);\n\n    // 7. Perform ? Set(rx, \"lastIndex\", previousLastIndex, true).\n    Set(realm, rx, \"lastIndex\", previousLastIndex, true);\n\n    // 8. If result is null, return -1.\n    if (result instanceof NullValue) return new NumberValue(realm, -1);\n\n    // 9. Return ? Get(result, \"index\").\n    return Get(realm, result, \"index\");\n  });\n\n  // ECMA262 21.2.5.10\n  obj.defineNativeGetter(\"source\", (context) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. If R does not have an [[OriginalSource]] internal slot, throw a TypeError exception.\n    if (typeof R.$OriginalSource !== \"string\") {\n      // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.\n      if (SameValue(realm, R, realm.intrinsics.RegExpPrototype)) {\n        return new StringValue(realm, \"(?:)\");\n      } else { // b. Otherwise, throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError,\n          \"R does not have an [[OriginalSource]] internal slot\");\n      }\n    }\n\n    // 4. Assert: R has an [[OriginalFlags]] internal slot.\n    invariant(R.$OriginalFlags !== undefined, \"R has an [[OriginalFlags]] internal slot\");\n\n    // 5. Let src be R.[[OriginalSource]].\n    let src = R.$OriginalSource;\n    invariant(typeof src === \"string\");\n\n    // 6. Let flags be R.[[OriginalFlags]].\n    let flags = R.$OriginalFlags;\n    invariant(typeof flags === \"string\");\n\n    // 7. Return EscapeRegExpPattern(src, flags).\n    return new StringValue(realm, EscapeRegExpPattern(realm, src, flags));\n  });\n\n  // ECMA262 21.2.5.11\n  obj.defineNativeMethod(realm.intrinsics.SymbolSplit, 2, (context, [string, limit]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(rx) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = ToStringPartial(realm, string);\n\n    // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).\n    let C = SpeciesConstructor(realm, rx, realm.intrinsics.RegExp);\n\n    // 5. Let flags be ? ToString(? Get(rx, \"flags\")).\n    let flags = ToStringPartial(realm, Get(realm, rx, \"flags\"));\n\n    let unicodeMatching;\n    // 6. If flags contains \"u\", let unicodeMatching be true.\n    if (flags.indexOf(\"u\") >= 0) {\n      unicodeMatching = true;\n    } else { // 7. Else, let unicodeMatching be false.\n      unicodeMatching = false;\n    }\n\n    let newFlags;\n    // 8. If flags contains \"y\", let newFlags be flags.\n    if (flags.indexOf(\"y\") >= 0) {\n      newFlags = flags;\n    } else { // 9. Else, let newFlags be the string that is the concatenation of flags and \"y\".\n      newFlags = flags + \"y\";\n    }\n\n    // 10. Let splitter be ? Construct(C, « rx, newFlags »).\n    let splitter = Construct(realm, C, [rx, new StringValue(realm, newFlags)]);\n\n    // 11. Let A be ArrayCreate(0).\n    let A = ArrayCreate(realm, 0);\n\n    // 12. Let lengthA be 0.\n    let lengthA = 0;\n\n    // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).\n    let lim = limit instanceof UndefinedValue ? (Math.pow(2, 32) - 1) : ToUint32(realm, limit.throwIfNotConcrete());\n\n    // 14. Let size be the number of elements in S.\n    let size = S.length;\n\n    // 15. Let p be 0.\n    let p = 0;\n\n    // 16. If lim = 0, return A.\n    if (lim === 0) return A;\n\n    // 17. If size = 0, then\n    if (size === 0) {\n      // a. Let z be ? RegExpExec(splitter, S).\n      let z = RegExpExec(realm, splitter, S);\n\n      // b. If z is not null, return A.\n      if (!(z instanceof NullValue)) return A;\n\n      // c. Perform ! CreateDataProperty(A, \"0\", S).\n      CreateDataProperty(realm, A, \"0\", new StringValue(realm, S));\n\n      // d Return A.\n      return A;\n    }\n\n    // 18. Let q be p.\n    let q = p;\n\n    // 19. Repeat, while q < size\n    while (q < size) {\n      // a. Perform ? Set(splitter, \"lastIndex\", q, true).\n      Set(realm, splitter, \"lastIndex\", new NumberValue(realm, q), true);\n\n      // b. Let z be ? RegExpExec(splitter, S).\n      let z = RegExpExec(realm, splitter, S);\n\n      // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).\n      if (z instanceof NullValue) {\n        q = AdvanceStringIndex(realm, S, q, unicodeMatching);\n      } else { // d. Else z is not null,\n        // i. Let e be ? ToLength(? Get(splitter, \"lastIndex\")).\n        let e = ToLength(realm, Get(realm, splitter, \"lastIndex\"));\n\n        // ii. Let e be min(e, size).\n        e = Math.min(e, size);\n\n        // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).\n        if (e === p) {\n          q = AdvanceStringIndex(realm, S, q, unicodeMatching);\n        } else { // iv. Else e ≠ p,\n          // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).\n          let T = S.substr(p, q - p);\n\n          // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).\n          CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, lengthA)), new StringValue(realm, T));\n\n          // 3. Let lengthA be lengthA + 1.\n          lengthA = lengthA + 1;\n\n          // 4. If lengthA = lim, return A.\n          if (lengthA === lim) return A;\n\n          // 5. Let p be e.\n          p = e;\n\n          // 6. Let numberOfCaptures be ? ToLength(? Get(z, \"length\")).\n          let numberOfCaptures = ToLength(realm, Get(realm, z, \"length\"));\n\n          // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).\n          numberOfCaptures = Math.max(numberOfCaptures - 1, 0);\n\n          // 8. Let i be 1.\n          let i = 1;\n\n          // 9. Repeat, while i ≤ numberOfCaptures,\n          while (i <= numberOfCaptures) {\n            // a. Let nextCapture be ? Get(z, ! ToString(i)).\n            let nextCapture = Get(realm, z, ToString(realm, new NumberValue(realm, i)));\n\n            // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).\n            CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, lengthA)), nextCapture);\n\n            // c. Let i be i + 1.\n            i = i + 1;\n\n            // d. Let lengthA be lengthA + 1.\n            lengthA = lengthA + 1;\n\n            // e. If lengthA = lim, return A.\n            if (lengthA === lim) return A;\n          }\n\n          // 10. Let q be p.\n          q = p;\n        }\n      }\n    }\n\n    // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).\n    let T = S.substr(p, size - p);\n\n    // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).\n    CreateDataProperty(realm, A, ToString(realm, new NumberValue(realm, lengthA)), new StringValue(realm, T));\n\n    // 22. Return A.\n    return A;\n  });\n\n  // ECMA262 21.2.5.12\n  obj.defineNativeGetter(\"sticky\", (context) => {\n    return InternalHasFlag(realm, context, \"y\");\n  });\n\n  // ECMA262 21.2.5.13\n  obj.defineNativeMethod(\"test\", 1, (context, [S]) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let string be ? ToString(S).\n    let string = ToStringPartial(realm, S);\n\n    // 4. Let match be ? RegExpExec(R, string).\n    let match = RegExpExec(realm, R, string);\n\n    // 5. If match is not null, return true; else return false.\n    return new BooleanValue(realm, !(match instanceof NullValue) ? true : false);\n  });\n\n  // ECMA262 21.2.5.14\n  obj.defineNativeMethod(\"toString\", 0, (context) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let pattern be ? ToString(? Get(R, \"source\")).\n    let pattern = ToStringPartial(realm, Get(realm, R, \"source\"));\n\n    // 4. Let flags be ? ToString(? Get(R, \"flags\")).\n    let flags = ToStringPartial(realm, Get(realm, R, \"flags\"));\n\n    // 5. Let result be the String value formed by concatenating \"/\", pattern, \"/\", and flags.\n    let result = \"/\" + pattern + \"/\" + flags;\n\n    // 6. Return result.\n    return new StringValue(realm, result);\n  });\n\n  // ECMA262 21.2.5.15\n  obj.defineNativeGetter(\"unicode\", (context) => {\n    return InternalHasFlag(realm, context, \"u\");\n  });\n}\n"]}