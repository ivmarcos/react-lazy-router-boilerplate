{"version":3,"sources":["../../../src/intrinsics/ecma262/TypedArray.js"],"names":["realm","func","context","createErrorThrowCompletion","intrinsics","TypeError","defineNativeMethod","source","mapfn","thisArg","C","mapping","undefined","mightBeUndefined","throwIfNotConcrete","T","usingIterator","SymbolIterator","values","len","length","targetObj","k","Pk","kValue","shift","mappedValue","arrayLike","items","argCount","newObj","defineNativeGetter","SymbolSpecies","build","getConstructorName","type","args","NewTarget","constructorName","elementLength","typedArray","$TypedArrayName","O","srcArray","srcData","$ViewedArrayBuffer","elementType","$ArrayLength","srcName","srcType","srcElementSize","srcByteOffset","$ByteOffset","elementSize","byteLength","data","bufferConstructor","ArrayBuffer","srcByteIndex","targetByteIndex","count","value","$ByteLength","object","$ArrayBufferData","buffer","byteOffset","offset","RangeError","bufferByteLength","$ArrayBufferByteLength","newByteLength","newLength","$Prototype","TypedArray","defineNativeConstant"],"mappings":"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","file":"TypedArray.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport type { ElementType, TypedArrayKind } from \"../../types.js\";\nimport { ElementSize } from \"../../types.js\";\nimport { NumberValue, NativeFunctionValue, ObjectValue, StringValue, UndefinedValue } from \"../../values/index.js\";\nimport { ArrayElementSize, ArrayElementType, AllocateTypedArray, AllocateTypedArrayBuffer, TypedArrayCreate } from \"../../methods/typedarray.js\";\nimport { SpeciesConstructor } from \"../../methods/construct.js\";\nimport { ToIndexPartial, ToLength, ToString, ToObjectPartial } from \"../../methods/to.js\";\nimport { Get, GetMethod } from \"../../methods/get.js\";\nimport { Set } from \"../../methods/properties.js\";\nimport { IterableToList } from \"../../methods/iterator.js\";\nimport { IsDetachedBuffer, IsConstructor, IsCallable } from \"../../methods/is.js\";\nimport { Call } from \"../../methods/call.js\";\nimport { CloneArrayBuffer, AllocateArrayBuffer, GetValueFromBuffer, SetValueInBuffer } from \"../../methods/arraybuffer.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function (realm: Realm): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, 'TypedArray', 'TypedArray', 0, (context) => {\n    // 1. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"TypedArray\");\n  });\n\n  // ECMA262 22.2.2.1\n  func.defineNativeMethod(\"from\", 1, (context, [source, mapfn, thisArg]) => {\n    // 1. Let C be the this value.\n    let C = context;\n\n    // 2. If IsConstructor(C) is false, throw a TypeError exception.\n    if (IsConstructor(realm, C) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n    }\n    invariant(C instanceof ObjectValue);\n\n    let mapping;\n    // 3. If mapfn was supplied and mapfn is not undefined, then\n    if (mapfn !== undefined && !mapfn.mightBeUndefined()) {\n      // a. If IsCallable(mapfn) is false, throw a TypeError exception.\n      if (IsCallable(realm, mapfn) === false) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n      }\n\n      // b. Let mapping be true.\n      mapping = true;\n    } else { // 4. Else, let mapping be false.\n      mapfn === undefined || mapfn.throwIfNotConcrete();\n      mapping = false;\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg !== undefined ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let usingIterator be ? GetMethod(source, @@iterator).\n    let usingIterator = GetMethod(realm, source, realm.intrinsics.SymbolIterator);\n\n    // 7. If usingIterator is not undefined, then\n    if (!(usingIterator instanceof UndefinedValue)) {\n      // a. Let values be ? IterableToList(source, usingIterator).\n      let values = IterableToList(realm, source, usingIterator);\n\n      // b. Let len be the number of elements in values.\n      let len = values.length;\n\n      // c. Let targetObj be ? TypedArrayCreate(C, «len»).\n      let targetObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n      // d. Let k be 0.\n      let k = 0;\n\n      // e. Repeat, while k < len\n      while (k < len) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = ToString(realm, new NumberValue(realm, k));\n\n        // ii. Let kValue be the first element of values and remove that element from values.\n        let kValue = values.shift();\n\n        let mappedValue;\n        // iii. If mapping is true, then\n        if (mapping === true) {\n          // 1. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\n          mappedValue = Call(realm, mapfn, T, [kValue, new NumberValue(realm, k)]);\n        } else { // iv. Else, let mappedValue be kValue.\n          mappedValue = kValue;\n        }\n\n        // v. Perform ? Set(targetObj, Pk, mappedValue, true).\n        Set(realm, targetObj, Pk, mappedValue, true);\n\n        // vi. Increase k by 1.\n        k = k + 1;\n      }\n\n      // f. Assert: values is now an empty List.\n      invariant(values.length === 0, \"values is not an empty List\");\n\n      // g. Return targetObj.\n      return targetObj;\n    }\n\n    // 8. NOTE: source is not an Iterable so assume it is already an array-like object.\n\n    // 9. Let arrayLike be ! ToObject(source).\n    let arrayLike = ToObjectPartial(realm, source);\n\n    // 10. Let len be ? ToLength(? Get(arrayLike, \"length\")).\n    let len = ToLength(realm, Get(realm, arrayLike, \"length\"));\n\n    // 11. Let targetObj be ? TypedArrayCreate(C, « len »).\n    let targetObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n    // 12. Let k be 0.\n    let k = 0;\n\n    // 13. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(arrayLike, Pk).\n      let kValue = Get(realm, arrayLike, Pk);\n\n      let mappedValue;\n      // c. If mapping is true, then\n      if (mapping === true) {\n        // i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\n        mappedValue = Call(realm, mapfn, T, [kValue, new NumberValue(realm, k)]);\n      } else { // d. Else, let mappedValue be kValue.\n        mappedValue = kValue;\n      }\n\n      // e. Perform ? Set(targetObj, Pk, mappedValue, true).\n      Set(realm, targetObj, Pk, mappedValue, true);\n\n      // f. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 14. Return targetObj.\n    return targetObj;\n  });\n\n  // ECMA262 22.2.2.2\n  func.defineNativeMethod(\"of\", 0, (context, items, argCount) => {\n    // 1. Let len be the actual number of arguments passed to this function.\n    let len = argCount;\n\n    // 2. Let items be the List of arguments passed to this function.\n    items;\n\n    // 3. Let C be the this value.\n    let C = context;\n\n    // 4. If IsConstructor(C) is false, throw a TypeError exception.\n    if (IsConstructor(realm, C) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n    }\n    invariant(C instanceof ObjectValue);\n\n    // 5. Let newObj be ? TypedArrayCreate(C, « len »).\n    let newObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let kValue be items[k].\n      let kValue = items[k];\n\n      // b. Let Pk be ! ToString(k).\n      let Pk = ToString(realm, new NumberValue(realm, k));\n\n      // c. Perform ? Set(newObj, Pk, kValue, true).\n      Set(realm, newObj, Pk, kValue, true);\n\n      // d. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 8. Return newObj.\n    return newObj;\n  });\n\n  // ECMA262 22.2.2.4\n  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, (context) => {\n    // 1. Return the this value\n    return context;\n  });\n\n  return func;\n}\n\n// ECMA262 22.2 Table 50\nfunction getConstructorName(type: ElementType): TypedArrayKind {\n  switch (type) {\n    case \"Float32\": return \"Float32Array\";\n    case \"Float64\": return \"Float64Array\";\n    case \"Int8\": return \"Int8Array\";\n    case \"Int16\": return \"Int16Array\";\n    case \"Int32\": return \"Int32Array\";\n    case \"Uint8\": return \"Uint8Array\";\n    case \"Uint16\": return \"Uint16Array\";\n    case \"Uint32\": return \"Uint32Array\";\n    case \"Uint8Clamped\": return \"Uint8ClampedArray\";\n    default: invariant(false);\n  }\n}\n\nexport function build(realm: Realm, type: ElementType): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, `${type}Array`, `${type}Array`, 3, (context, args, argCount, NewTarget) => {\n    if (argCount === 0) {\n      // ECMA262 22.2.4.1\n\n      // 1. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 2. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 3. Return ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\", 0).\n      return AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`, 0);\n    } else if (!(args[0] instanceof ObjectValue)) {\n      // ECMA262 22.2.4.2\n      let length = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(length) is not Object.\n      invariant(!(length instanceof ObjectValue), \"Type(length) is not Object\");\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let elementLength be ? ToIndex(length).\n      let elementLength = ToIndexPartial(realm, length);\n\n      // 4. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 5. Return ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\", elementLength).\n      return AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`, elementLength);\n    } else if ('$TypedArrayName' in args[0]) {\n      // ECMA262 22.2.4.3\n      let typedArray = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(typedArray) is Object and typedArray has a [[TypedArrayName]] internal slot.\n      invariant(typedArray instanceof ObjectValue && typeof typedArray.$TypedArrayName === \"string\");\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let srcArray be typedArray.\n      let srcArray = typedArray;\n\n      // 6. Let srcData be srcArray.[[ViewedArrayBuffer]].\n      let srcData = srcArray.$ViewedArrayBuffer; invariant(srcData);\n\n      // 7. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcData) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcData) is true\");\n      }\n\n      // 8. Let constructorName be the String value of O.[[TypedArrayName]].\n      constructorName = O.$TypedArrayName; invariant(typeof constructorName === \"string\");\n\n      // 9. Let elementType be the String value of the Element Type value in Table 50 for constructorName.\n      let elementType = ArrayElementType[constructorName];\n\n      // 10. Let elementLength be srcArray.[[ArrayLength]].\n      let elementLength = srcArray.$ArrayLength; invariant(typeof elementLength === \"number\");\n\n      // 11. Let srcName be the String value of srcArray.[[TypedArrayName]].\n      let srcName = srcArray.$TypedArrayName; invariant(typeof srcName === \"string\");\n\n      // 12. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n      let srcType = ArrayElementType[srcName];\n\n      // 13. Let srcElementSize be the Element Size value in Table 50 for srcName.\n      let srcElementSize = ArrayElementSize[srcName];\n\n      // 14. Let srcByteOffset be srcArray.[[ByteOffset]].\n      let srcByteOffset = srcArray.$ByteOffset; invariant(typeof srcByteOffset === \"number\");\n\n      // 15. Let elementSize be the Element Size value in Table 50 for constructorName.\n      let elementSize = ArrayElementSize[constructorName];\n\n      // 16. Let byteLength be elementSize × elementLength.\n      let byteLength = elementSize * elementLength;\n\n      let data;\n      // 17. If SameValue(elementType, srcType) is true, then\n      if (elementType === srcType) {\n        // a. Let data be ? CloneArrayBuffer(srcData, srcByteOffset).\n        data = CloneArrayBuffer(realm, srcData, srcByteOffset);\n      } else { // 18. Else,\n        // a. Let bufferConstructor be ? SpeciesConstructor(srcData, %ArrayBuffer%).\n        let bufferConstructor = SpeciesConstructor(realm, srcData, realm.intrinsics.ArrayBuffer);\n\n        // b. Let data be ? AllocateArrayBuffer(bufferConstructor, byteLength).\n        data = AllocateArrayBuffer(realm, bufferConstructor, byteLength);\n\n        // c. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, srcData) === true) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcData) is true\");\n        }\n\n        // d. Let srcByteIndex be srcByteOffset.\n        let srcByteIndex = srcByteOffset;\n\n        // e. Let targetByteIndex be 0.\n        let targetByteIndex = 0;\n\n        // f. Let count be elementLength.\n        let count = elementLength;\n\n        // g. Repeat, while count > 0\n        while (count > 0) {\n          // i. Let value be GetValueFromBuffer(srcData, srcByteIndex, srcType).\n          let value = GetValueFromBuffer(realm, srcData, srcByteIndex, srcType);\n\n          // ii. Perform SetValueInBuffer(data, targetByteIndex, elementType, value).\n          SetValueInBuffer(realm, data, targetByteIndex, elementType, value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + srcElementSize.\n          srcByteIndex = srcByteIndex + srcElementSize;\n\n          // iv. Set targetByteIndex to targetByteIndex + elementSize.\n          targetByteIndex = targetByteIndex + elementSize;\n\n          // v. Decrement count by 1.\n          count -= 1;\n        }\n      }\n\n      // 19. Set O.[[ViewedArrayBuffer]] to data.\n      O.$ViewedArrayBuffer = data;\n\n      // 20. Set O.[[ByteLength]] to byteLength.\n      O.$ByteLength = byteLength;\n\n      // 21. Set O.[[ByteOffset]] to 0.\n      O.$ByteOffset = 0;\n\n      // 22. Set O.[[ArrayLength]] to elementLength.\n      O.$ArrayLength = elementLength;\n\n      // 23. Return O.\n      return O;\n    } else if (!('$ArrayBufferData' in args[0]) && !('$TypedArrayName' in args[0])) {\n      // ECMA262 22.2.4.4\n      let object = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(object) is Object and object does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.\n      invariant(object instanceof ObjectValue && typeof object.$TypedArrayName && !object.$ArrayBufferData);\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let usingIterator be ? GetMethod(object, @@iterator).\n      let usingIterator = GetMethod(realm, object, realm.intrinsics.SymbolIterator);\n\n      // 6. If usingIterator is not undefined, then\n      if (!(usingIterator instanceof UndefinedValue)) {\n        // a. Let values be ? IterableToList(object, usingIterator).\n        let values = IterableToList(realm, object, usingIterator);\n\n        // b. Let len be the number of elements in values.\n        let len = values.length;\n\n        // c. Perform ? AllocateTypedArrayBuffer(O, len).\n        AllocateTypedArrayBuffer(realm, O, len);\n\n        // d. Let k be 0.\n        let k = 0;\n\n        // e. Repeat, while k < len\n        while (k < len) {\n          // i. Let Pk be ! ToString(k).\n          let Pk = new StringValue(realm, ToString(realm, new NumberValue(realm, k)));\n\n          // ii. Let kValue be the first element of values and remove that element from values.\n          let kValue = values.shift();\n\n          // iii. Perform ? Set(O, Pk, kValue, true).\n          Set(realm, O, Pk, kValue, true);\n\n          // iv. Increase k by 1.\n          k = k + 1;\n        }\n\n        // f. Assert: values is now an empty List.\n        invariant(values.length === 0);\n\n        // g. Return O.\n        return O;\n      }\n\n      // 7. NOTE: object is not an Iterable so assume it is already an array-like object.\n\n      // 8. Let arrayLike be object.\n      let arrayLike = object;\n\n      // 9. Let len be ? ToLength(? Get(arrayLike, \"length\")).\n      let len = ToLength(realm, Get(realm, arrayLike, \"length\"));\n\n      // 10. Perform ? AllocateTypedArrayBuffer(O, len).\n      AllocateTypedArrayBuffer(realm, O, len);\n\n      // 11. Let k be 0.\n      let k = 0;\n\n      // 12. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, ToString(realm, new NumberValue(realm, k)));\n\n        // b. Let kValue be ? Get(arrayLike, Pk).\n        let kValue = Get(realm, arrayLike, Pk);\n\n        // c. Perform ? Set(O, Pk, kValue, true).\n        Set(realm, O, Pk, kValue, true);\n\n        // d. Increase k by 1.\n        k += 1;\n      }\n\n      // 13. Return O.\n      return O;\n    } else {\n      // ECMA262 22.2.4.5\n      let buffer = args[0].throwIfNotConcrete(), byteOffset = args[1], length = args[2];\n\n      // 1. Assert: Type(buffer) is Object and buffer has an [[ArrayBufferData]] internal slot.\n      invariant(buffer instanceof ObjectValue && '$ArrayBufferData' in buffer);\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let constructorName be the String value of O.[[TypedArrayName]].\n      constructorName = O.$TypedArrayName; invariant(constructorName);\n\n      // 6. Let elementSize be the Number value of the Element Size value in Table 50 for constructorName.\n      let elementSize = ArrayElementSize[constructorName];\n\n      // 7. Let offset be ? ToIndex(byteOffset).\n      let offset = ToIndexPartial(realm, byteOffset);\n\n      // 8. If offset modulo elementSize ≠ 0, throw a RangeError exception.\n      if (offset % elementSize !== 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"offset modulo elementSize ≠ 0\");\n      }\n\n      // 9. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, buffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(buffer) is true\");\n      }\n\n      // 10. Let bufferByteLength be buffer.[[ArrayBufferByteLength]].\n      let bufferByteLength = buffer.$ArrayBufferByteLength; invariant(typeof bufferByteLength === \"number\");\n\n      let newByteLength;\n      // 11. If length is either not present or undefined, then\n      if (!length || length instanceof UndefinedValue) {\n        // a. If bufferByteLength modulo elementSize ≠ 0, throw a RangeError exception.\n        if (bufferByteLength % elementSize !== 0) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"bufferByteLength modulo elementSize ≠ 0\");\n        }\n        // b. Let newByteLength be bufferByteLength - offset.\n        newByteLength = bufferByteLength - offset;\n\n        // c. If newByteLength < 0, throw a RangeError exception.\n        if (newByteLength < 0) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"newByteLength < 0\");\n        }\n      } else { // 12. Else,\n        // a. Let newLength be ? ToIndex(length).\n        let newLength = ToIndexPartial(realm, length);\n\n        // b. Let newByteLength be newLength × elementSize.\n        newByteLength = newLength * elementSize;\n\n        // c. If offset+newByteLength > bufferByteLength, throw a RangeError exception.\n        if (offset + newByteLength > bufferByteLength) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"offset+newByteLength > bufferByteLength\");\n        }\n      }\n\n      // 13. Set O.[[ViewedArrayBuffer]] to buffer.\n      O.$ViewedArrayBuffer = buffer;\n\n      // 14. Set O.[[ByteLength]] to newByteLength.\n      O.$ByteLength = newByteLength;\n\n      // 15. Set O.[[ByteOffset]] to offset.\n      O.$ByteOffset = offset;\n\n      // 16. Set O.[[ArrayLength]] to newByteLength / elementSize.\n      O.$ArrayLength = newByteLength / elementSize;\n\n      // 17. Return O.\n      return O;\n    }\n  });\n\n  // ECMA262 22.2.5\n  func.$Prototype = realm.intrinsics.TypedArray;\n\n  // ECMA262 22.2.5.1\n  func.defineNativeConstant(\"BYTES_PER_ELEMENT\", new NumberValue(realm, ElementSize[type]));\n\n  return func;\n}\n"]}