{"version":3,"sources":["../../../src/intrinsics/prepack/global.js"],"names":["realm","global","$GlobalObject","$DefineOwnProperty","value","context","args","console","log","map","arg","serialize","writable","enumerable","configurable","parseTypeNameOrTemplate","typeNameOrTemplate","undefined","type","template","typeNameString","getTypeFromName","createErrorThrowCompletion","intrinsics","TypeError","isTypeCompatibleWith","ObjectPrototype","name","isPartial","nameString","buildNode","locString","contextStack","slice","reverse","executionContext","caller","function","lexicalEnvironment","loc","buildThrowErrorAbstractValue","LOCATION","t","stringLiteral","types","values","Set","topVal","result","createAbstract","makePartial","rebuildNestedProperties","f","constructor","isResidual","deriveAbstract","concat","callExpression","nodes","object","$Realm","makeSimple","propertyName","key","generator","emitInvariant","objectNode","valueNode","binaryExpression","memberExpression","identifier","objnode","$Set","intrinsicName","rebuildObjectProperty","__IntrospectionError"],"mappings":"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","file":"global.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { Value, StringValue, BooleanValue, ObjectValue, FunctionValue, NativeFunctionValue, AbstractValue, AbstractObjectValue, UndefinedValue } from \"../../values/index.js\";\nimport { ToStringPartial } from \"../../methods/index.js\";\nimport { ObjectCreate } from \"../../methods/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../../domains/index.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeExpression, BabelNodeSpreadElement, BabelNodeIdentifier } from \"babel-types\";\nimport invariant from \"../../invariant.js\";\nimport { describeLocation } from \"../ecma262/Error.js\";\n\nlet buildThrowErrorAbstractValue = buildExpressionTemplate(\"(function(){throw new Error('abstract value defined at ' + LOCATION);})()\");\n\nexport default function (realm: Realm): void {\n  let global = realm.$GlobalObject;\n\n  global.$DefineOwnProperty(\"dump\", {\n    value: new NativeFunctionValue(realm, \"global.dump\", \"dump\", 0, (context, args) => {\n      console.log(\"dump\", args.map((arg) => arg.serialize()));\n      return context;\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n\n  function parseTypeNameOrTemplate(typeNameOrTemplate): { type: typeof Value, template: void | ObjectValue } {\n    if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof UndefinedValue) {\n      return { type: Value, template: undefined };\n    } else if (typeNameOrTemplate instanceof StringValue) {\n      let typeNameString = ToStringPartial(realm, typeNameOrTemplate);\n      let type = Value.getTypeFromName(typeNameString);\n      if (type === undefined) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n      }\n      return { type, template: Value.isTypeCompatibleWith(type, ObjectValue) ? ObjectCreate(realm, realm.intrinsics.ObjectPrototype) : undefined };\n    } else if (typeNameOrTemplate instanceof ObjectValue) {\n      return { type: ObjectValue, template: typeNameOrTemplate };\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"typeNameOrTemplate has unsupported type\");\n    }\n  }\n\n  // Helper function to model values that are obtained from the environment,\n  // and whose concrete values are not known at Prepack-time.\n  // __abstract(typeNameOrTemplate, name, options) creates a new abstract value\n  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.\n  // If the abstract value gets somehow embedded in the final heap,\n  // it will be referred to by the supplied name in the generated code.\n  global.$DefineOwnProperty(\"__abstract\", {\n    value: new NativeFunctionValue(realm, \"global.__abstract\", \"__abstract\", 0, (context, [typeNameOrTemplate, name]) => {\n      if (!realm.isPartial) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n      }\n\n      let { type, template } = parseTypeNameOrTemplate(typeNameOrTemplate);\n\n      let nameString = name ? ToStringPartial(realm, name) : \"\";\n      let buildNode;\n      if (nameString === \"\") {\n        let locString;\n        for (let executionContext of realm.contextStack.slice().reverse()) {\n          let caller = executionContext.caller;\n          locString = describeLocation(realm, caller ? caller.function : undefined, caller ? caller.lexicalEnvironment : undefined, executionContext.loc);\n          if (locString !== undefined) break;\n        }\n\n        buildNode = () => buildThrowErrorAbstractValue({ LOCATION: t.stringLiteral(locString || \"(unknown location)\") });\n      } else {\n        buildNode = buildExpressionTemplate(nameString);\n      }\n\n      let types = new TypesDomain(type);\n      let values = template ? new ValuesDomain(new Set([template])) : ValuesDomain.topVal;\n      let result = realm.createAbstract(types, values, [], buildNode, undefined, nameString);\n      if (template) {\n        template.makePartial();\n        if (nameString) realm.rebuildNestedProperties(result, nameString);\n      }\n      return result;\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n\n  // Helper function that identifies a computation that must remain part of the residual program and cannot be partially evaluated,\n  // e.g. because it contains a loop over abstract values.\n  // __residual(typeNameOrTemplate, function, arg0, arg1, ...) creates a new abstract value\n  // that is computed by invoking function(arg0, arg1, ...) in the residual program and\n  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.\n  // The function must not have side effects, and it must not access any state (besides the supplied arguments).\n  // TODO: In some distant future, Prepack should be able to figure out automatically what computations need to remain part of the residual program.\n  global.$DefineOwnProperty(\"__residual\", {\n    value: new NativeFunctionValue(realm, \"global.__residual\", \"__residual\", 2, (context, [typeNameOrTemplate, f, ...args]) => {\n      if (!realm.isPartial) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n      }\n\n      let { type, template } = parseTypeNameOrTemplate(typeNameOrTemplate);\n\n      if (f.constructor !== FunctionValue) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"cannot determine residual function\");\n      }\n      invariant(f instanceof FunctionValue);\n      f.isResidual = true;\n\n      let types = new TypesDomain(type);\n      let values = template ? new ValuesDomain(new Set([template])) : ValuesDomain.topVal;\n      let result = realm.deriveAbstract(types, values, [f].concat(args), nodes => t.callExpression(nodes[0], ((nodes.slice(1): any): Array<BabelNodeExpression | BabelNodeSpreadElement>)));\n      if (template) {\n        template.makePartial();\n        realm.rebuildNestedProperties(result, ((result.buildNode: any): BabelNodeIdentifier).name);\n      }\n      return result;\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n\n  // TODO: Remove this property. It's just here as some existing internal test cases assume that the __annotate property is exists and is readable.\n  global.$DefineOwnProperty(\"__annotate\", {\n    value: realm.intrinsics.undefined,\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n\n  // Internal helper function for tests.\n  // __isAbstract(value) checks if a given value is abstract.\n  global.$DefineOwnProperty(\"__isAbstract\", {\n    value: new NativeFunctionValue(realm, \"global.__isAbstract\", \"__isAbstract\", 1, (context, [value]) => {\n      return new BooleanValue(realm, value instanceof AbstractValue);\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n\n  // __makePartial(object) marks an (abstract) object as partial.\n  global.$DefineOwnProperty(\"__makePartial\", {\n    value: new NativeFunctionValue(realm, \"global.__makePartial\", \"__isPartial\", 1, (context, [object]) => {\n      // casting to any to avoid Flow bug\n      if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n        (object: any).makePartial();\n        return context.$Realm.intrinsics.undefined;\n      }\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n\n  // __makeSimple(object) marks an (abstract) object as one that has no getters or setters.\n  global.$DefineOwnProperty(\"__makeSimple\", {\n    value: new NativeFunctionValue(realm, \"global.__makeSimple\", \"__makeSimple\", 1, (context, [object]) => {\n      // casting to any to avoid Flow bug\n      if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n        (object: any).makeSimple();\n        return context.$Realm.intrinsics.undefined;\n      }\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n\n  // Helper function that emits a check whether a given object property has a particular value.\n  global.$DefineOwnProperty(\"__assumeDataProperty\", {\n    value: new NativeFunctionValue(realm, \"global.__assumeDataProperty\", \"__assumeDataProperty\", 3, (context, [object, propertyName, value]) => {\n      if (!realm.isPartial) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n      }\n\n      let key = ToStringPartial(realm, propertyName);\n\n      // casting to any to avoid Flow bug \"*** Recursion limit exceeded ***\"\n      if ((object: any) instanceof AbstractObjectValue || (object: any) instanceof ObjectValue) {\n        let generator = realm.generator;\n        if (generator)\n          generator.emitInvariant([object, value, object], ([objectNode, valueNode]) =>\n            t.binaryExpression(\"!==\", t.memberExpression(objectNode, t.identifier(key)), valueNode),\n          (objnode) => t.memberExpression(objnode, t.identifier(key)));\n        realm.generator = undefined; // don't emit code during the following $Set call\n        // casting to due to Flow workaround above\n        (object: any).$Set(key, value, object);\n        realm.generator = generator;\n        if (object.intrinsicName)\n          realm.rebuildObjectProperty(object, key, value, object.intrinsicName);\n        return context.$Realm.intrinsics.undefined;\n      }\n\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an (abstract) object\");\n    }),\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n\n  global.$DefineOwnProperty(\"__IntrospectionError\", {\n    value: realm.intrinsics.__IntrospectionError,\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n}\n"]}