"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (realm) {
  var global = realm.$GlobalObject;

  global.$DefineOwnProperty("dump", {
    value: new _index.NativeFunctionValue(realm, "global.dump", "dump", 0, function (context, args) {
      console.log("dump", args.map(function (arg) {
        return arg.serialize();
      }));
      return context;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  function parseTypeNameOrTemplate(typeNameOrTemplate) {
    if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof _index.UndefinedValue) {
      return { type: _index.Value, template: undefined };
    } else if (typeNameOrTemplate instanceof _index.StringValue) {
      var typeNameString = (0, _index2.ToStringPartial)(realm, typeNameOrTemplate);
      var _type = _index.Value.getTypeFromName(typeNameString);
      if (_type === undefined) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "unknown typeNameOrTemplate");
      }
      return { type: _type, template: _index.Value.isTypeCompatibleWith(_type, _index.ObjectValue) ? (0, _index2.ObjectCreate)(realm, realm.intrinsics.ObjectPrototype) : undefined };
    } else if (typeNameOrTemplate instanceof _index.ObjectValue) {
      return { type: _index.ObjectValue, template: typeNameOrTemplate };
    } else {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "typeNameOrTemplate has unsupported type");
    }
  }

  // Helper function to model values that are obtained from the environment,
  // and whose concrete values are not known at Prepack-time.
  // __abstract(typeNameOrTemplate, name, options) creates a new abstract value
  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.
  // If the abstract value gets somehow embedded in the final heap,
  // it will be referred to by the supplied name in the generated code.
  global.$DefineOwnProperty("__abstract", {
    value: new _index.NativeFunctionValue(realm, "global.__abstract", "__abstract", 0, function (context, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          typeNameOrTemplate = _ref2[0],
          name = _ref2[1];

      if (!realm.isPartial) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
      }

      var _parseTypeNameOrTempl = parseTypeNameOrTemplate(typeNameOrTemplate),
          type = _parseTypeNameOrTempl.type,
          template = _parseTypeNameOrTempl.template;

      var nameString = name ? (0, _index2.ToStringPartial)(realm, name) : "";
      var buildNode = void 0;
      if (nameString === "") {
        var locString = void 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = realm.contextStack.slice().reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var executionContext = _step.value;

            var caller = executionContext.caller;
            locString = (0, _Error.describeLocation)(realm, caller ? caller.function : undefined, caller ? caller.lexicalEnvironment : undefined, executionContext.loc);
            if (locString !== undefined) break;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        buildNode = function buildNode() {
          return buildThrowErrorAbstractValue({ LOCATION: t.stringLiteral(locString || "(unknown location)") });
        };
      } else {
        buildNode = (0, _builder2.default)(nameString);
      }

      var types = new _index3.TypesDomain(type);
      var values = template ? new _index3.ValuesDomain(new Set([template])) : _index3.ValuesDomain.topVal;
      var result = realm.createAbstract(types, values, [], buildNode, undefined, nameString);
      if (template) {
        template.makePartial();
        if (nameString) realm.rebuildNestedProperties(result, nameString);
      }
      return result;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // Helper function that identifies a computation that must remain part of the residual program and cannot be partially evaluated,
  // e.g. because it contains a loop over abstract values.
  // __residual(typeNameOrTemplate, function, arg0, arg1, ...) creates a new abstract value
  // that is computed by invoking function(arg0, arg1, ...) in the residual program and
  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.
  // The function must not have side effects, and it must not access any state (besides the supplied arguments).
  // TODO: In some distant future, Prepack should be able to figure out automatically what computations need to remain part of the residual program.
  global.$DefineOwnProperty("__residual", {
    value: new _index.NativeFunctionValue(realm, "global.__residual", "__residual", 2, function (context, _ref3) {
      var _ref4 = _toArray(_ref3),
          typeNameOrTemplate = _ref4[0],
          f = _ref4[1],
          args = _ref4.slice(2);

      if (!realm.isPartial) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
      }

      var _parseTypeNameOrTempl2 = parseTypeNameOrTemplate(typeNameOrTemplate),
          type = _parseTypeNameOrTempl2.type,
          template = _parseTypeNameOrTempl2.template;

      if (f.constructor !== _index.FunctionValue) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "cannot determine residual function");
      }
      (0, _invariant2.default)(f instanceof _index.FunctionValue);
      f.isResidual = true;

      var types = new _index3.TypesDomain(type);
      var values = template ? new _index3.ValuesDomain(new Set([template])) : _index3.ValuesDomain.topVal;
      var result = realm.deriveAbstract(types, values, [f].concat(args), function (nodes) {
        return t.callExpression(nodes[0], nodes.slice(1));
      });
      if (template) {
        template.makePartial();
        realm.rebuildNestedProperties(result, result.buildNode.name);
      }
      return result;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // TODO: Remove this property. It's just here as some existing internal test cases assume that the __annotate property is exists and is readable.
  global.$DefineOwnProperty("__annotate", {
    value: realm.intrinsics.undefined,
    writable: true,
    enumerable: false,
    configurable: true
  });

  // Internal helper function for tests.
  // __isAbstract(value) checks if a given value is abstract.
  global.$DefineOwnProperty("__isAbstract", {
    value: new _index.NativeFunctionValue(realm, "global.__isAbstract", "__isAbstract", 1, function (context, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
          value = _ref6[0];

      return new _index.BooleanValue(realm, value instanceof _index.AbstractValue);
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // __makePartial(object) marks an (abstract) object as partial.
  global.$DefineOwnProperty("__makePartial", {
    value: new _index.NativeFunctionValue(realm, "global.__makePartial", "__isPartial", 1, function (context, _ref7) {
      var _ref8 = _slicedToArray(_ref7, 1),
          object = _ref8[0];

      // casting to any to avoid Flow bug
      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        object.makePartial();
        return context.$Realm.intrinsics.undefined;
      }
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // __makeSimple(object) marks an (abstract) object as one that has no getters or setters.
  global.$DefineOwnProperty("__makeSimple", {
    value: new _index.NativeFunctionValue(realm, "global.__makeSimple", "__makeSimple", 1, function (context, _ref9) {
      var _ref10 = _slicedToArray(_ref9, 1),
          object = _ref10[0];

      // casting to any to avoid Flow bug
      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        object.makeSimple();
        return context.$Realm.intrinsics.undefined;
      }
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  // Helper function that emits a check whether a given object property has a particular value.
  global.$DefineOwnProperty("__assumeDataProperty", {
    value: new _index.NativeFunctionValue(realm, "global.__assumeDataProperty", "__assumeDataProperty", 3, function (context, _ref11) {
      var _ref12 = _slicedToArray(_ref11, 3),
          object = _ref12[0],
          propertyName = _ref12[1],
          value = _ref12[2];

      if (!realm.isPartial) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
      }

      var key = (0, _index2.ToStringPartial)(realm, propertyName);

      // casting to any to avoid Flow bug "*** Recursion limit exceeded ***"
      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        var generator = realm.generator;
        if (generator) generator.emitInvariant([object, value, object], function (_ref13) {
          var _ref14 = _slicedToArray(_ref13, 2),
              objectNode = _ref14[0],
              valueNode = _ref14[1];

          return t.binaryExpression("!==", t.memberExpression(objectNode, t.identifier(key)), valueNode);
        }, function (objnode) {
          return t.memberExpression(objnode, t.identifier(key));
        });
        realm.generator = undefined; // don't emit code during the following $Set call
        // casting to due to Flow workaround above
        object.$Set(key, value, object);
        realm.generator = generator;
        if (object.intrinsicName) realm.rebuildObjectProperty(object, key, value, object.intrinsicName);
        return context.$Realm.intrinsics.undefined;
      }

      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  });

  global.$DefineOwnProperty("__IntrospectionError", {
    value: realm.intrinsics.__IntrospectionError,
    writable: true,
    enumerable: false,
    configurable: true
  });
};

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _index3 = require("../../domains/index.js");

var _builder = require("../../utils/builder.js");

var _builder2 = _interopRequireDefault(_builder);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _Error = require("../ecma262/Error.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var buildThrowErrorAbstractValue = (0, _builder2.default)("(function(){throw new Error('abstract value defined at ' + LOCATION);})()");
//# sourceMappingURL=global.js.map