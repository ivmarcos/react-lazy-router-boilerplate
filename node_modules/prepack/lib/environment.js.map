{"version":3,"sources":["../src/environment.js"],"names":["sourceMap","require","EnvironmentRecord","realm","isReadOnly","DeclarativeEnvironmentRecord","bindings","Object","create","N","envRec","D","recordModifiedBinding","initialized","mutable","deletable","intrinsics","undefined","S","strict","V","binding","value","empty","createErrorThrowCompletion","ReferenceError","CreateMutableBinding","InitializeBinding","TypeError","ObjectEnvironmentRecord","obj","object","foundBinding","withEnvironment","unscopables","SymbolUnscopables","blocked","configValue","writable","enumerable","configurable","Error","SetMutableBinding","$Delete","FunctionEnvironmentRecord","$ThisBindingStatus","$ThisValue","$HomeObject","home","$GetPrototypeOf","GlobalEnvironmentRecord","DclRec","$DeclarativeRecord","HasBinding","ObjRec","$ObjectRecord","CreateImmutableBinding","GetBindingValue","DeleteBinding","globalObject","existingProp","status","varNames","$VarNames","indexOf","splice","$GlobalThisValue","varDeclaredNames","$GetOwnProperty","hasProperty","extensible","push","desc","ModuleEnvironmentRecord","LexicalEnvironment","ast","strictCode","metadata","evaluate","err","createIntrospectionErrorThrowCompletion","joinCondition","evaluateAbstract","code","filename","map","sourceType","onParse","context","lexicalEnvironment","variableEnvironment","pushContext","res","e","evaluateCompletion","length","fixup_source_locations","popContext","smc","SourceMapConsumer","node","loc","start","new_pos","old_pos","originalPositionFor","line","column","source","Reference","type","currentLocation","timeout","testTimeout","evaluator","evaluators","base","refName","thisValue","referencedName","mightNotBeString"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNode, BabelNodeFile } from \"babel-types\";\nimport type { NormalCompletion } from \"./completions.js\";\nimport type { Realm } from \"./realm.js\";\nimport type { SourceType } from \"./types.js\";\n\nimport { AbruptCompletion, Completion, ComposedAbruptCompletion, JoinedAbruptCompletions, PossiblyNormalCompletion, ThrowCompletion } from \"./completions.js\";\nimport { ExecutionContext } from \"./realm.js\";\nimport { Value } from \"./values/index.js\";\nimport { AbstractValue, NullValue, SymbolValue, BooleanValue, FunctionValue, ObjectValue, AbstractObjectValue, UndefinedValue } from \"./values/index.js\";\nimport parse from \"./utils/parse.js\";\nimport invariant from \"./invariant.js\";\nimport traverse from \"./traverse.js\";\nimport {\n  ToBooleanPartial,\n  HasProperty,\n  Get,\n  GetValue,\n  DefinePropertyOrThrow,\n  Set,\n  IsExtensible,\n  HasOwnProperty,\n  IsDataDescriptor,\n  ThrowIfMightHaveBeenDeleted,\n} from \"./methods/index.js\";\n\nconst sourceMap = require('source-map');\n\n// ECMA262 8.1.1\nexport class EnvironmentRecord {\n  realm: Realm;\n  isReadOnly: boolean;\n  $NewTarget: void | ObjectValue;\n\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.isReadOnly = false;\n  }\n\n  +HasBinding: (N: string) => boolean;\n  +CreateMutableBinding: (N: string, D: boolean) => Value;\n  +CreateImmutableBinding: (N: string, S: boolean) => Value;\n  +InitializeBinding: (N: string, V: Value) => Value;\n  +SetMutableBinding: (N: string, V: Value, S: boolean) => Value;\n  +GetBindingValue: (N: string, S: boolean) => Value;\n  +DeleteBinding: (N: string) => boolean;\n  +HasThisBinding: () => boolean;\n  +GetThisBinding: () => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n  +HasSuperBinding: () => boolean;\n  +WithBaseObject: () => Value;\n  +BindThisValue: (V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue) => NullValue | ObjectValue | AbstractObjectValue | UndefinedValue;\n}\n\nexport type Binding = {\n  value?: Value;\n  initialized?: boolean;\n  mutable?: boolean;\n  deletable?: boolean;\n}\n\n// ECMA262 8.1.1.1\nexport class DeclarativeEnvironmentRecord extends EnvironmentRecord {\n  constructor(realm: Realm) {\n    super(realm);\n    this.bindings = Object.create(null);\n  }\n\n  bindings: { [name: string]: Binding };\n\n  // ECMA262 8.1.1.1.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec has a binding for the name that is the value of N, return true.\n    if (envRec.bindings[N]) return true;\n\n    // 3. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      mutable: true,\n      deletable: D\n    }, envRec);\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      strict: S,\n      deletable: false\n    }, envRec);\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    invariant(binding && !binding.initialized, `shouldn't have the binding ${N}`);\n\n    // 3. Set the bound value for N in envRec to V.\n    this.realm.recordModifiedBinding(binding, envRec).value = V;\n\n    // 4. Record that the binding for N in envRec has been initialized.\n    binding.initialized = true;\n\n    // 5. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. If envRec does not have a binding for N, then\n    if (!binding) {\n      // a. If S is true, throw a ReferenceError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} not found`);\n      }\n\n      // b. Perform envRec.CreateMutableBinding(N, true).\n      envRec.CreateMutableBinding(N, true);\n\n      // c. Perform envRec.InitializeBinding(N, V).\n      envRec.InitializeBinding(N, V);\n\n      // d. Return NormalCompletion(empty).\n      return this.realm.intrinsics.empty;\n    }\n\n    // 3. If the binding for N in envRec is a strict binding, let S be true.\n    if (binding.strict) S = true;\n\n    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} has not yet been initialized`);\n    } else if (binding.mutable) { // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.\n       realm.recordModifiedBinding(binding, envRec).value = V;\n    } else { // 6. Else,\n      // a. Assert: This is an attempt to change the value of an immutable binding.\n\n      // b. If S is true, throw a TypeError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"attempt to change immutable binding\");\n      }\n    }\n\n    // 7. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec has a binding for N.\n    invariant(binding, \"expected binding\");\n\n    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return the value currently bound to N in envRec.\n    invariant(binding.value);\n    return binding.value;\n  }\n\n  // ECMA262 8.1.1.1.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec has a binding for the name that is the value of N.\n    invariant(envRec.bindings[N], \"expected binding to exist\");\n\n    // 3. If the binding for N in envRec cannot be deleted, return false.\n    if (!envRec.bindings[N].deletable) return false;\n\n    // 4. Remove the binding for N from envRec.\n    this.realm.recordModifiedBinding(envRec.bindings[N], envRec).value = undefined;\n    delete envRec.bindings[N];\n\n    // 5. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.1.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.2\nexport class ObjectEnvironmentRecord extends EnvironmentRecord {\n  object: ObjectValue | AbstractObjectValue;\n  withEnvironment: boolean;\n\n  constructor(realm: Realm, obj: ObjectValue | AbstractObjectValue) {\n    super(realm);\n    this.object = obj;\n  }\n\n  // ECMA262 8.1.1.2.1\n  HasBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = this.object;\n\n    // 3. Let foundBinding be ? HasProperty(bindings, N).\n    let foundBinding = HasProperty(realm, bindings, N);\n\n    // 4. If foundBinding is false, return false.\n    if (!foundBinding) return false;\n\n    // 5. If the withEnvironment flag of envRec is false, return true.\n    if (!envRec.withEnvironment) return true;\n\n    // 6. Let unscopables be ? Get(bindings, @@unscopables).\n    let unscopables = Get(realm, bindings, realm.intrinsics.SymbolUnscopables);\n\n    // 7. If Type(unscopables) is Object, then\n    if (unscopables instanceof ObjectValue || unscopables instanceof AbstractObjectValue) {\n      // a. Let blocked be ToBoolean(? Get(unscopables, N)).\n      let blocked = ToBooleanPartial(realm, Get(realm, unscopables, N));\n\n      // b. If blocked is true, return false.\n      if (blocked) return false;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.2.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. If D is true, let configValue be true; otherwise let configValue be false.\n    let configValue = D ? true : false;\n\n    // 4. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configValue}).\n    return new BooleanValue(realm, DefinePropertyOrThrow(realm, bindings, N, {\n      value: realm.intrinsics.undefined,\n      writable: true,\n      enumerable: true,\n      configurable: configValue\n    }));\n  }\n\n  // ECMA262 8.1.1.2.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.\n    throw new Error(\"unreachable\");\n  }\n\n  // ECMA262 8.1.1.2.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    // 3. Record that the binding for N in envRec has been initialized.\n\n    // 4. Return ? envRec.SetMutableBinding(N, V, false).\n    return envRec.SetMutableBinding(N, V, false);\n  }\n\n  // ECMA262 8.1.1.2.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? Set(bindings, N, V, S).\n    return new BooleanValue(realm, Set(realm, bindings, N, V, S));\n  }\n\n  // ECMA262 8.1.1.2.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Let value be ? HasProperty(bindings, N).\n    let value = HasProperty(realm, bindings, N);\n\n    // 4. If value is false, then\n    if (!value) {\n      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.\n      if (!S) {\n        return realm.intrinsics.undefined;\n      } else {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 5. Return ? Get(bindings, N).\n    return Get(realm, bindings, N);\n  }\n\n  // ECMA262 8.1.1.2.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? bindings.[[Delete]](N).\n    return bindings.$Delete(N);\n  }\n\n  // ECMA262 8.1.1.2.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.10\n  WithBaseObject(): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.\n    if (envRec.withEnvironment) return envRec.object;\n\n    // 3. Otherwise, return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.3\nexport class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  $ThisBindingStatus: \"lexical\" | \"initialized\" | \"uninitialized\";\n  $ThisValue: UndefinedValue | NullValue | ObjectValue | AbstractObjectValue;\n  $HomeObject: void | ObjectValue;\n  $FunctionObject: FunctionValue;\n\n  // ECMA262 8.1.1.3.1\n  BindThisValue(V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"initialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"initialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Set envRec.[[ThisValue]] to V.\n    envRec.$ThisValue = V;\n\n    // 5. Set envRec.[[ThisBindingStatus]] to \"initialized\".\n    envRec.$ThisBindingStatus = \"initialized\";\n\n    // 6. Return V.\n    return V;\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false; otherwise, return true.\n    return envRec.$ThisBindingStatus === \"lexical\" ? false : true;\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false.\n    if (envRec.$ThisBindingStatus === \"lexical\") return false;\n\n    // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.\n    if (envRec.$HomeObject === undefined) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"uninitialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"uninitialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return envRec.[[ThisValue]].\n    return envRec.$ThisValue;\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): ObjectValue | NullValue | UndefinedValue {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let home be the value of envRec.[[HomeObject]].\n    let home = envRec.$HomeObject;\n\n    // 3. If home has the value undefined, return undefined.\n    if (home === undefined) return this.realm.intrinsics.undefined;\n\n    // 4. Assert: Type(home) is Object.\n    invariant(home instanceof ObjectValue, \"expected object value\");\n\n    // 5. Return ? home.[[GetPrototypeOf]]().\n    return home.$GetPrototypeOf();\n  }\n}\n\n// ECMA262 8.1.1.4\nexport class GlobalEnvironmentRecord extends EnvironmentRecord {\n  $DeclarativeRecord: EnvironmentRecord;\n  $ObjectRecord: ObjectEnvironmentRecord;\n  $VarNames: Array<string>;\n  $GlobalThisValue: ObjectValue;\n\n  // ECMA262 8.1.1.4.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, return true.\n    if (DclRec.HasBinding(N)) return true;\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.HasBinding(N).\n    return ObjRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateMutableBinding(N, D).\n    return DclRec.CreateMutableBinding(N, D);\n  }\n\n  // ECMA262 8.1.1.4.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateImmutableBinding(N, S).\n    return DclRec.CreateImmutableBinding(N, S);\n  }\n\n  // ECMA262 8.1.1.4.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.InitializeBinding(N, V).\n      return DclRec.InitializeBinding(N, V);\n    }\n\n    // 4. Assert: If the binding exists, it must be in the object Environment Record.\n\n    // 5. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 6. Return ? ObjRec.InitializeBinding(N, V).\n    return ObjRec.InitializeBinding(N, V);\n  }\n\n  // ECMA262 8.1.1.4.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.SetMutableBinding(N, V, S).\n      return DclRec.SetMutableBinding(N, V, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).\n    return ObjRec.SetMutableBinding(N, V, S);\n  }\n\n  // ECMA262 8.1.1.4.6\n  GetBindingValue(N: string, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.GetBindingValue(N, S).\n      return DclRec.GetBindingValue(N, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.GetBindingValue(N, S).\n    return ObjRec.GetBindingValue(N, S);\n  }\n\n  // ECMA262 8.1.1.4.7\n  DeleteBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.DeleteBinding(N).\n      return DclRec.DeleteBinding(N);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).\n    let existingProp = HasOwnProperty(realm, globalObject, N);\n\n    // 7. If existingProp is true, then\n    if (existingProp) {\n      // a. Let status be ? ObjRec.DeleteBinding(N).\n      let status = ObjRec.DeleteBinding(N);\n\n      // b. If status is true, then\n      if (status) {\n        // i. Let varNames be envRec.[[VarNames]].\n        let varNames = envRec.$VarNames;\n\n        // ii. If N is an element of varNames, remove that element from the varNames.\n        if (varNames.indexOf(N) >= 0) {\n          varNames.splice(varNames.indexOf(N), 1);\n        }\n      }\n\n      // c. Return status.\n      return status;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.8\n  HasThisBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.9\n  HasSuperBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.4.11\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    invariant(envRec.$GlobalThisValue);\n    // 2. Return envRec.[[GlobalThisValue]].\n    return envRec.$GlobalThisValue;\n  }\n\n  // ECMA262 8.1.1.4.12\n  HasVarDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 3. If varDeclaredNames contains the value of N, return true.\n    if (varDeclaredNames.indexOf(N) >= 0) return true;\n\n    // 4. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.13\n  HasLexicalDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. Return DclRec.HasBinding(N).\n    return DclRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.14\n  HasRestrictedGlobalProperty(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return false.\n    if (!existingProp) return false;\n    ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return false.\n    if (existingProp.configurable) return false;\n\n    // 7. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.15\n  CanDeclareGlobalVar(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. If hasProperty is true, return true.\n    if (hasProperty) return true;\n\n    // 6. Return ? IsExtensible(globalObject).\n    return IsExtensible(realm, globalObject);\n  }\n\n  // ECMA262 8.1.1.4.16\n  CanDeclareGlobalFunction(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).\n    if (!existingProp) return IsExtensible(realm, globalObject);\n    ThrowIfMightHaveBeenDeleted(existingProp.value);\n\n    // 6. If existingProp.[[Configurable]] is true, return true.\n    if (existingProp.configurable) return true;\n\n    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.\n    if (IsDataDescriptor(realm, existingProp) && existingProp.writable && existingProp.enumerable) {\n      return true;\n    }\n\n    // 8. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.17\n  CreateGlobalVarBinding(N: string, D: boolean) {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. Let extensible be ? IsExtensible(globalObject).\n    let extensible = IsExtensible(realm, globalObject);\n\n    // 6. If hasProperty is false and extensible is true, then\n    if (!hasProperty && extensible) {\n      // a. Perform ? ObjRec.CreateMutableBinding(N, D).\n      ObjRec.CreateMutableBinding(N, D);\n\n      // b. Perform ? ObjRec.InitializeBinding(N, undefined).\n      ObjRec.InitializeBinding(N, this.realm.intrinsics.undefined);\n    }\n\n    // 7. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 8. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 9. Return NormalCompletion(empty).\n  }\n\n  // ECMA262 8.1.1.4.18\n  CreateGlobalFunctionBinding(N: string, V: Value, D: boolean) {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then\n    let desc;\n    if (!existingProp || existingProp.configurable) {\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.\n      desc = { value: V, writable: true, enumerable: true, configurable: D };\n    } else { // 6. Else,\n      ThrowIfMightHaveBeenDeleted(existingProp.value);\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V }.\n      desc = { value: V };\n    }\n\n    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).\n    DefinePropertyOrThrow(this.realm, globalObject, N, desc);\n\n    // TODO? 8. Record that the binding for N in ObjRec has been initialized.\n\n    // 9. Perform ? Set(globalObject, N, V, false).\n    Set(this.realm, globalObject, N, V, false);\n\n    // 10. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 11. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 12. Return NormalCompletion(empty).\n  }\n}\n\n// ECMA262 8.1.1.5\nexport class ModuleEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  // ECMA262 8.1.1.3.1\n  BindThisValue(V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    throw new Error(\"TODO: implement modules\");\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    throw new Error(\"TODO: implement modules\");\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    throw new Error(\"TODO: implement modules\");\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    throw new Error(\"TODO: implement modules\");\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): NullValue | ObjectValue | UndefinedValue  {\n    throw new Error(\"TODO: implement modules\");\n  }\n}\n\n// ECMA262 8.1\nexport class LexicalEnvironment {\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n  }\n\n  environmentRecord: EnvironmentRecord;\n  parent: null | LexicalEnvironment;\n  realm: Realm;\n\n  evaluateCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value | Reference {\n    try {\n      return this.evaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof ComposedAbruptCompletion)\n        return err.createIntrospectionErrorThrowCompletion();\n      if (err instanceof JoinedAbruptCompletions || err instanceof PossiblyNormalCompletion)\n        return AbstractValue.createIntrospectionErrorThrowCompletion(err.joinCondition);\n      if (err instanceof AbruptCompletion)\n        return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new Error(err);\n    }\n  }\n\n  evaluateAbstractCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): Completion | Value | Reference {\n    try {\n      return this.evaluateAbstract(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof AbruptCompletion)\n        return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new Error(err);\n    }\n  }\n\n  execute(code: string, filename: string, map: string = \"\",\n      sourceType: SourceType = \"script\", onParse: void | ((BabelNodeFile) => void) = undefined): AbruptCompletion | Value {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n\n    this.realm.pushContext(context);\n\n    let ast, res;\n    try {\n      try {\n        ast = parse(this.realm, code, filename, sourceType);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) return e;\n        throw e;\n      }\n      if (onParse) onParse(ast);\n      res = this.evaluateCompletion(ast, false);\n      if (map.length > 0) this.fixup_source_locations(ast, map);\n    } finally {\n      this.realm.popContext(context);\n    }\n    if (res instanceof AbruptCompletion) return res;\n\n    return GetValue(this.realm, res);\n  }\n\n  fixup_source_locations(ast: BabelNode, map: string) {\n    const smc = new sourceMap.SourceMapConsumer(map);\n    traverse(ast, function (node) {\n      let loc = node.loc;\n      if (loc == null || loc.start == null) return false;\n      let new_pos = loc.start;\n      let old_pos = smc.originalPositionFor(\n        { line: new_pos.line, column: new_pos.column });\n      if (old_pos.source == null) return false;\n      new_pos.line = old_pos.line;\n      new_pos.column = old_pos.column;\n      loc.source = old_pos.source;\n      return false;\n    });\n  }\n\n  evaluate(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    let res = this.evaluateAbstract(ast, strictCode, metadata);\n    if (res instanceof PossiblyNormalCompletion)\n      throw AbstractValue.createIntrospectionErrorThrowCompletion(res.joinCondition);\n    invariant(res instanceof Value || res instanceof Reference, ast.type);\n    return res;\n  }\n\n  evaluateAbstract(ast: BabelNode, strictCode: boolean, metadata?: any): NormalCompletion | Value | Reference {\n    this.realm.currentLocation = ast.loc;\n    if (this.realm.timeout) this.realm.testTimeout();\n\n    let evaluator = this.realm.evaluators[(ast.type: string)];\n    if (evaluator) {\n      return evaluator(ast, strictCode, this, this.realm, metadata);\n    }\n\n    let err = new TypeError(`Unsupported node type ${ast.type}`);\n    throw err;\n  }\n}\n\n//\nexport class Reference {\n  base: void | Value | EnvironmentRecord;\n  referencedName: AbstractValue | string | SymbolValue;\n  strict: boolean;\n  thisValue: void | Value;\n\n  constructor(base: void | Value | EnvironmentRecord,\n      refName: AbstractValue | string | SymbolValue,\n      strict: boolean, thisValue?: void | Value) {\n    this.base = base;\n    this.referencedName = refName;\n    invariant(!(refName instanceof AbstractValue) || !refName.mightNotBeString());\n    this.strict = strict;\n    this.thisValue = thisValue;\n    invariant(thisValue === undefined || !(base instanceof EnvironmentRecord));\n  }\n}\n"]}