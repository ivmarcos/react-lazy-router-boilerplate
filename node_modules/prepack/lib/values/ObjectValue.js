"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _index = require("../domains/index.js");

var _index2 = require("./index.js");

var _index3 = require("../methods/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ObjectValue = function (_ConcreteValue) {
  _inherits(ObjectValue, _ConcreteValue);

  function ObjectValue(realm, proto, intrinsicName) {
    _classCallCheck(this, ObjectValue);

    var _this = _possibleConstructorReturn(this, (ObjectValue.__proto__ || Object.getPrototypeOf(ObjectValue)).call(this, realm, intrinsicName));

    realm.recordNewObject(_this);
    if (realm.isPartial) _this.setupBindings();
    _this.$Prototype = proto || realm.intrinsics.null;
    _this.$Extensible = realm.intrinsics.true;
    _this._isPartial = realm.intrinsics.false;
    _this._isSimple = realm.intrinsics.false;
    _this.properties = new Map();
    _this.symbols = new Map();
    return _this;
  }

  _createClass(ObjectValue, [{
    key: "setupBindings",
    value: function setupBindings() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = ObjectValue.trackedProperties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var propName = _step.value;

          var desc = { writeable: true, value: undefined };
          this[propName + "_binding"] = { descriptor: desc, object: this, key: propName };
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "mightNotBeObject",
    value: function mightNotBeObject() {
      return false;
    }
  }, {
    key: "throwIfNotObject",
    value: function throwIfNotObject() {
      return this;
    }
  }, {
    key: "makeNotPartial",
    value: function makeNotPartial() {
      this._isPartial = this.$Realm.intrinsics.false;
    }
  }, {
    key: "makePartial",
    value: function makePartial() {
      this._isPartial = this.$Realm.intrinsics.true;
    }
  }, {
    key: "makeSimple",
    value: function makeSimple() {
      this._isSimple = this.$Realm.intrinsics.true;
    }
  }, {
    key: "isPartial",
    value: function isPartial() {
      return this._isPartial.value;
    }
  }, {
    key: "isSimple",
    value: function isSimple() {
      if (this._isSimple.value) return true;
      if (this.isPartial()) return false;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.properties.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var propertyBinding = _step2.value;

          var desc = propertyBinding.descriptor;
          if (desc === undefined) continue; // deleted
          if (!(0, _index3.IsDataDescriptor)(this.$Realm, desc)) return false;
          if (!desc.writable) return false;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (this.$Prototype instanceof _index2.NullValue) return true;
      if (this.$Prototype === this.$Realm.intrinsics.ObjectPrototype) return true;
      return this.$Prototype.isSimple();
    }
  }, {
    key: "getExtensible",
    value: function getExtensible() {
      return this.$Extensible.value;
    }
  }, {
    key: "setExtensible",
    value: function setExtensible(v) {
      this.$Extensible = v ? this.$Realm.intrinsics.true : this.$Realm.intrinsics.false;
    }
  }, {
    key: "getKind",
    value: function getKind() {
      // we can deduce the natural prototype by checking whether the following internal slots are present
      if (this.$SymbolData !== undefined) return "Symbol";
      if (this.$StringData !== undefined) return "String";
      if (this.$NumberData !== undefined) return "Number";
      if (this.$BooleanData !== undefined) return "Boolean";
      if (this.$DateValue !== undefined) return "Date";
      if (this.$RegExpMatcher !== undefined) return "RegExp";
      if (this.$SetData !== undefined) return "Set";
      if (this.$MapData !== undefined) return "Map";
      if (this.$DataView !== undefined) return "DataView";
      if (this.$ArrayBufferData !== undefined) return "ArrayBuffer";
      if (this.$WeakMapData !== undefined) return "WeakMap";
      if (this.$WeakSetData !== undefined) return "WeakSet";
      if (this.$TypedArrayName !== undefined) return this.$TypedArrayName;
      // TODO #26: Promises. All kinds of iterators. Generators.
      return "Object";
    }
  }, {
    key: "defineNativeMethod",
    value: function defineNativeMethod(name, length, callback) {
      var desc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      var intrinsicName = void 0;
      if (typeof name === "string") {
        if (this.intrinsicName) intrinsicName = this.intrinsicName + "." + name;
      } else if (name instanceof _index2.SymbolValue) {
        if (this.intrinsicName && name.intrinsicName) intrinsicName = this.intrinsicName + "[" + name.intrinsicName + "]";
      } else {
        (0, _invariant2.default)(false);
      }
      this.defineNativeProperty(name, new _index2.NativeFunctionValue(this.$Realm, intrinsicName, name, length, callback, false), desc);
    }
  }, {
    key: "defineNativeProperty",
    value: function defineNativeProperty(name, value) {
      var desc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      this.$DefineOwnProperty(name, _extends({
        value: value,
        writable: true,
        enumerable: false,
        configurable: true
      }, desc));
    }
  }, {
    key: "defineNativeGetter",
    value: function defineNativeGetter(name, callback) {
      var desc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var intrinsicName = void 0,
          funcName = void 0;
      if (typeof name === "string") {
        funcName = "get " + name;
        if (this.intrinsicName) intrinsicName = this.intrinsicName + "." + name;
      } else if (name instanceof _index2.SymbolValue) {
        funcName = "get [" + (name.$Description || "?") + "]";
        if (this.intrinsicName && name.intrinsicName) intrinsicName = this.intrinsicName + "[" + name.intrinsicName + "]";
      } else {
        (0, _invariant2.default)(false);
      }

      var func = new _index2.NativeFunctionValue(this.$Realm, intrinsicName, funcName, 0, callback);
      func.$Construct = undefined;
      func.$ConstructorKind = undefined;
      this.$DefineOwnProperty(name, _extends({
        get: func,
        set: this.$Realm.intrinsics.undefined,
        enumerable: false,
        configurable: true
      }, desc));
    }
  }, {
    key: "defineNativeConstant",
    value: function defineNativeConstant(name, value) {
      var desc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      this.$DefineOwnProperty(name, _extends({
        value: value,
        writable: false,
        enumerable: false,
        configurable: false
      }, desc));
    }
  }, {
    key: "getOwnPropertyKeysArray",
    value: function getOwnPropertyKeysArray() {
      if (this.isPartial() || this.unknownProperty !== undefined) {
        throw _index2.AbstractValue.createIntrospectionErrorThrowCompletion(this);
      }

      var o = this;
      var keyArray = Array.from(o.properties.keys());
      keyArray = keyArray.filter(function (x) {
        var pb = o.properties.get(x);
        if (!pb || pb.descriptor === undefined) return false;
        var pv = pb.descriptor.value;
        if (pv === undefined) return true;
        if (!pv.mightHaveBeenDeleted()) return true;
        // The property may or may not be there at runtime.
        // We can at best return an abstract keys array.
        // For now just terminate.
        (0, _invariant2.default)(pv instanceof _index2.AbstractValue);
        throw _index2.AbstractValue.createIntrospectionErrorThrowCompletion(pv);
      });
      return keyArray;
    }
  }, {
    key: "_serialize",
    value: function _serialize(set, stack) {
      var obj = set({});

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              key = _step3$value[0],
              propertyBinding = _step3$value[1];

          var desc = propertyBinding.descriptor;
          if (desc === undefined) continue; // deleted
          (0, _index3.ThrowIfMightHaveBeenDeleted)(desc.value);
          var serializedDesc = { enumerable: desc.enumerable, configurable: desc.configurable };
          if (desc.value) {
            serializedDesc.writable = desc.writable;
            serializedDesc.value = desc.value.serialize(stack);
          } else {
            (0, _invariant2.default)(desc.get !== undefined);
            serializedDesc.get = desc.get.serialize(stack);
            (0, _invariant2.default)(desc.set !== undefined);
            serializedDesc.set = desc.set.serialize(stack);
          }
          Object.defineProperty(obj, key, serializedDesc);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return obj;
    }

    // ECMA262 9.1.1

  }, {
    key: "$GetPrototypeOf",
    value: function $GetPrototypeOf() {
      return this.$Prototype;
    }

    // ECMA262 9.1.2

  }, {
    key: "$SetPrototypeOf",
    value: function $SetPrototypeOf(V) {
      // 1. Return ! OrdinarySetPrototypeOf(O, V).
      return (0, _index3.OrdinarySetPrototypeOf)(this.$Realm, this, V);
    }

    // ECMA262 9.1.3

  }, {
    key: "$IsExtensible",
    value: function $IsExtensible() {
      // 1. Return ! OrdinaryIsExtensible(O).
      return (0, _index3.OrdinaryIsExtensible)(this.$Realm, this);
    }

    // ECMA262 9.1.4

  }, {
    key: "$PreventExtensions",
    value: function $PreventExtensions() {
      // 1. Return ! OrdinaryPreventExtensions(O).
      return (0, _index3.OrdinaryPreventExtensions)(this.$Realm, this);
    }

    // ECMA262 9.1.5

  }, {
    key: "$GetOwnProperty",
    value: function $GetOwnProperty(P) {
      // 1. Return ! OrdinaryGetOwnProperty(O, P).
      return (0, _index3.OrdinaryGetOwnProperty)(this.$Realm, this, P);
    }

    // ECMA262 9.1.6

  }, {
    key: "$DefineOwnProperty",
    value: function $DefineOwnProperty(P, Desc) {
      // 1. Return ? OrdinaryDefineOwnProperty(O, P, Desc).
      return (0, _index3.OrdinaryDefineOwnProperty)(this.$Realm, this, P, Desc);
    }

    // ECMA262 9.1.7

  }, {
    key: "$HasProperty",
    value: function $HasProperty(P) {
      if (this.unknownProperty !== undefined && this.$GetOwnProperty(P) === undefined) {
        throw _index2.AbstractValue.createIntrospectionErrorThrowCompletion(this, P);
      }

      return (0, _index3.OrdinaryHasProperty)(this.$Realm, this, P);
    }

    // ECMA262 9.1.8

  }, {
    key: "$Get",
    value: function $Get(P, Receiver) {
      var prop = this.unknownProperty;
      if (prop !== undefined && prop.descriptor !== undefined && this.$GetOwnProperty(P) === undefined) {
        var desc = prop.descriptor;(0, _invariant2.default)(desc !== undefined);
        var val = desc.value;(0, _invariant2.default)(val instanceof _index2.AbstractValue);
        var propName = void 0;
        if (P instanceof _index2.StringValue) {
          propName = P;
        } else if (typeof P === "string") {
          propName = new _index2.StringValue(this.$Realm, P);
        } else {
          throw this.$Realm.createIntrospectionErrorThrowCompletion("abstract computed property name");
        }
        return this.specializeJoin(val, propName);
      }

      // 1. Return ? OrdinaryGet(O, P, Receiver).
      return (0, _index3.OrdinaryGet)(this.$Realm, this, P, Receiver);
    }
  }, {
    key: "$GetPartial",
    value: function $GetPartial(P, Receiver) {
      var _this2 = this;

      if (!(P instanceof _index2.AbstractValue)) return this.$Get(P, Receiver);
      // We assume that simple objects have no getter/setter properties.
      if (this !== Receiver || !this.isSimple() || P.mightNotBeString()) throw this.$Realm.createIntrospectionErrorThrowCompletion("TODO");
      // If all else fails, use this expression
      var result = void 0;
      if (this.isPartial()) {
        result = this.$Realm.createAbstract(_index.TypesDomain.topVal, _index.ValuesDomain.topVal, [this, P], function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              o = _ref2[0],
              x = _ref2[1];

          return t.memberExpression(o, x, true);
        }, "sentinel member expression");
      } else {
        result = this.$Realm.intrinsics.undefined;
      }
      // Get a specialization of the join of all values written to the object
      // with abstract property names.
      var prop = this.unknownProperty;
      if (prop !== undefined) {
        var desc = prop.descriptor;(0, _invariant2.default)(desc !== undefined);
        var val = desc.value;(0, _invariant2.default)(val instanceof _index2.AbstractValue);
        result = this.specializeJoin(val, P);
      }
      // Join in all of the other values that were written to the object with
      // concrete property names.
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        var _loop = function _loop() {
          var _step4$value = _slicedToArray(_step4.value, 2),
              key = _step4$value[0],
              propertyBinding = _step4$value[1];

          var desc = propertyBinding.descriptor;
          if (desc === undefined) return "continue"; // deleted
          (0, _invariant2.default)(desc.value !== undefined); // otherwise this is not simple
          var val = desc.value;
          var cond = _this2.$Realm.createAbstract(new _index.TypesDomain(_index2.BooleanValue), _index.ValuesDomain.topVal, [P], function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 1),
                x = _ref4[0];

            return t.binaryExpression("===", x, t.stringLiteral(key));
          }, "check for known property");
          result = (0, _index3.joinValuesAsConditional)(_this2.$Realm, cond, val, result);
        };

        for (var _iterator4 = this.properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _ret = _loop();

          if (_ret === "continue") continue;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return result;
    }
  }, {
    key: "specializeJoin",
    value: function specializeJoin(absVal, propName) {
      (0, _invariant2.default)(absVal.args.length === 3);
      var generic_cond = absVal.args[0];
      (0, _invariant2.default)(generic_cond instanceof _index2.AbstractValue);
      var cond = this.specializeCond(generic_cond, propName);
      var arg1 = absVal.args[1];
      if (arg1 instanceof _index2.AbstractValue && arg1.args.length === 3) arg1 = this.specializeJoin(arg1, propName);
      var arg2 = absVal.args[2];
      if (arg2 instanceof _index2.AbstractValue && arg2.args.length === 3) arg2 = this.specializeJoin(arg2, propName);
      return this.$Realm.createAbstract(absVal.types, absVal.values, [cond, arg1, arg2], absVal._buildNode);
    }
  }, {
    key: "specializeCond",
    value: function specializeCond(absVal, propName) {
      if (absVal.kind === "template for property name condition") return this.$Realm.createAbstract(absVal.types, absVal.values, [absVal.args[0], propName], absVal._buildNode);
      return absVal;
    }

    // ECMA262 9.1.9

  }, {
    key: "$Set",
    value: function $Set(P, V, Receiver) {
      // 1. Return ? OrdinarySet(O, P, V, Receiver).
      return (0, _index3.OrdinarySet)(this.$Realm, this, P, V, Receiver);
    }
  }, {
    key: "$SetPartial",
    value: function $SetPartial(P, V, Receiver) {
      var _this3 = this;

      if (!(P instanceof _index2.AbstractValue)) return this.$Set(P, V, Receiver);
      // We assume that simple objects have no getter/setter properties and
      // that all properties are writable.
      if (this !== Receiver || !this.isSimple() || P.mightNotBeString()) throw this.$Realm.createIntrospectionErrorThrowCompletion("TODO");

      var prop = void 0;
      if (this.unknownProperty === undefined) {
        prop = {
          descriptor: undefined,
          object: this,
          key: ""
        };
        this.unknownProperty = prop;
      } else {
        prop = this.unknownProperty;
      }
      this.$Realm.recordModifiedProperty(prop);
      var desc = prop.descriptor;
      if (desc === undefined) {
        var newVal = V;
        if (!(V instanceof _index2.UndefinedValue)) {
          // join V with undefined, using a property name test as the condition
          var cond = this.$Realm.createAbstract(new _index.TypesDomain(_index2.BooleanValue), _index.ValuesDomain.topVal, [P, new _index2.StringValue(this.$Realm, "")], function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2),
                x = _ref6[0],
                y = _ref6[1];

            return t.binaryExpression("===", x, y);
          }, "template for property name condition");
          newVal = (0, _index3.joinValuesAsConditional)(this.$Realm, cond, V, this.$Realm.intrinsics.undefined);
        }
        prop.descriptor = {
          writable: true,
          enumerable: true,
          configurable: true,
          value: newVal
        };
      } else {
        // join V with current value of this.unknownProperty. I.e. weak update.
        var oldVal = desc.value;
        (0, _invariant2.default)(oldVal !== undefined);
        var _newVal = oldVal;
        if (!(V instanceof _index2.UndefinedValue)) {
          var _cond = this.$Realm.createAbstract(new _index.TypesDomain(_index2.BooleanValue), _index.ValuesDomain.topVal, [P, new _index2.StringValue(this.$Realm, "")], function (_ref7) {
            var _ref8 = _slicedToArray(_ref7, 2),
                x = _ref8[0],
                y = _ref8[1];

            return t.binaryExpression("===", x, y);
          }, "template for property name condition");
          _newVal = (0, _index3.joinValuesAsConditional)(this.$Realm, _cond, V, oldVal);
        }
        desc.value = _newVal;
      }

      // Since we don't know the name of the property we are writing to, we also need
      // to perform weak updates of all of the known properties.
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        var _loop2 = function _loop2() {
          var _step5$value = _slicedToArray(_step5.value, 2),
              key = _step5$value[0],
              propertyBinding = _step5$value[1];

          var oldVal = _this3.$Realm.intrinsics.empty;
          if (propertyBinding.descriptor && propertyBinding.descriptor.value) {
            oldVal = propertyBinding.descriptor.value;
            (0, _invariant2.default)(oldVal !== undefined); // otherwise this is not simple
          }
          var cond = _this3.$Realm.createAbstract(new _index.TypesDomain(_index2.BooleanValue), _index.ValuesDomain.topVal, [P], function (_ref9) {
            var _ref10 = _slicedToArray(_ref9, 1),
                x = _ref10[0];

            return t.binaryExpression("===", x, t.stringLiteral(key));
          });
          var newVal = (0, _index3.joinValuesAsConditional)(_this3.$Realm, cond, V, oldVal);
          (0, _index3.OrdinarySet)(_this3.$Realm, _this3, key, newVal, Receiver);
        };

        for (var _iterator5 = this.properties[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          _loop2();
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return true;
    }

    // ECMA262 9.1.10

  }, {
    key: "$Delete",
    value: function $Delete(P) {
      if (this.unknownProperty !== undefined) {
        // TODO: generate a delete from the object
        throw _index2.AbstractValue.createIntrospectionErrorThrowCompletion(this, P);
      }

      // 1. Return ? OrdinaryDelete(O, P).
      return (0, _index3.OrdinaryDelete)(this.$Realm, this, P);
    }

    // ECMA262 9.1.11

  }, {
    key: "$OwnPropertyKeys",
    value: function $OwnPropertyKeys() {
      return (0, _index3.OrdinaryOwnPropertyKeys)(this.$Realm, this);
    }
  }], [{
    key: "setupTrackedPropertyAccessors",
    value: function setupTrackedPropertyAccessors() {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        var _loop3 = function _loop3() {
          var propName = _step6.value;

          Object.defineProperty(ObjectValue.prototype, propName, { configurable: true,
            get: function get() {
              var binding = this[propName + "_binding"];
              return binding.descriptor.value;
            },
            set: function set(v) {
              var binding = this[propName + "_binding"];
              this.$Realm.recordModifiedProperty(binding);
              binding.descriptor.value = v;
            }
          });
        };

        for (var _iterator6 = ObjectValue.trackedProperties[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          _loop3();
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    } // undefined when the property is "missing"


    // error


    // function


    // promise


    // set


    // map


    // weak map


    // weak set


    // date
    // of type number

    // array


    // regex


    // string


    // data view


    // array buffer


    // generator


    // typed array


    // backpointer to the constructor if this object was created its prototype object


    // partial objects


    // If true, the object has no property getters or setters and it is safe
    // to return AbstractValue for unknown properties.

  }]);

  return ObjectValue;
}(_index2.ConcreteValue);

ObjectValue.trackedProperties = ["$Prototype", "$Extensible", "$SetNextIndex", "$IteratedSet", "$MapNextIndex", "$MapData", "$Map", "$DateValue", "$ArrayIteratorNextIndex", "$IteratedObject", "$StringIteratorNextIndex", "$IteratedString", "_isPartial", "_isSimple"];
exports.default = ObjectValue;
//# sourceMappingURL=ObjectValue.js.map