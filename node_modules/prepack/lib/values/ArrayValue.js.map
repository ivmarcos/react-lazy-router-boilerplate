{"version":3,"sources":["../../src/values/ArrayValue.js"],"names":["ArrayValue","realm","intrinsicName","intrinsics","ArrayPrototype","P","Desc","A","$Realm","value","oldLenDesc","undefined","oldLen","throwIfNotConcrete","index","writable","succeeded"],"mappings":";;;;;;;;AAaA;;AACA;;AAEA;;AACA;;AACA;;;;;;;;;;+eAlBA;;;;;;;;;IAoBqBA,U;;;AACnB,sBAAYC,KAAZ,EAA0BC,aAA1B,EAAkD;AAAA;;AAAA,mHAC1CD,KAD0C,EACnCA,MAAME,UAAN,CAAiBC,cADkB,EACFF,aADE;AAEjD;;;;8BAEqB;AACpB,aAAO,OAAP;AACD;;AAED;;;;uCACmBG,C,EAAqBC,I,EAA2B;AACjE,UAAIC,IAAI,IAAR;;AAEA;AACA,+BAAU,uBAAc,KAAKC,MAAnB,EAA2BH,CAA3B,CAAV,EAAyC,yBAAzC;;AAEA;AACA,UAAIA,MAAM,QAAN,IAAmBA,mCAA4BA,EAAEI,KAAF,KAAY,QAA/D,EAA0E;AACxE;AACA,eAAO,gCAAe,KAAKD,MAApB,EAA4BD,CAA5B,EAA+BD,IAA/B,CAAP;AACD,OAHD,MAGO,IAAI,sBAAa,KAAKE,MAAlB,EAA0BH,CAA1B,CAAJ,EAAkC;AAAE;;AAEzC;AACA,YAAIK,aAAa,wCAAuB,KAAKF,MAA5B,EAAoCD,CAApC,EAAuC,QAAvC,CAAjB;;AAEA;AACA;AACA,iCAAUG,eAAeC,SAAf,IACR,CAAC,8BAAqB,KAAKH,MAA1B,EAAkCE,UAAlC,CADH,EACkD,+CADlD;AAEA,qDAA4BA,WAAWD,KAAvC;;AAEA;AACA,YAAIG,SAASF,WAAWD,KAAxB;AACA,iCAAUG,WAAWD,SAArB;AACAC,iBAASA,OAAOC,kBAAP,EAAT;AACA,iCAAUD,oCAAV,EAAyC,uBAAzC;AACAA,iBAASA,OAAOH,KAAhB;;AAEA;AACA,YAAIK,QAAQ,kBAAS,KAAKN,MAAd,EAAsB,OAAOH,CAAP,KAAa,QAAb,GAAwB,uBAAgB,KAAKG,MAArB,EAA6BH,CAA7B,CAAxB,GAA0DA,CAAhF,CAAZ;;AAEA;AACA,YAAIS,SAASF,MAAT,IAAmBF,WAAWK,QAAX,KAAwB,KAA/C,EAAsD,OAAO,KAAP;;AAEtD;AACA,YAAIC,YAAY,2CAA0B,KAAKR,MAA/B,EAAuCD,CAAvC,EAA0CF,CAA1C,EAA6CC,IAA7C,CAAhB;;AAEA;AACA,YAAIU,cAAc,KAAlB,EAAyB,OAAO,KAAP;;AAEzB;AACA,YAAIF,SAASF,MAAb,EAAqB;AACnB;AACAF,qBAAWD,KAAX,GAAmB,uBAAgB,KAAKD,MAArB,EAA6BM,QAAQ,CAArC,CAAnB;;AAEA;AACAE,sBAAY,2CAA0B,KAAKR,MAA/B,EAAuCD,CAAvC,EAA0C,QAA1C,EAAoDG,UAApD,CAAZ;;AAEA;AACA,mCAAUM,SAAV,EAAqB,uCAArB;AACD;;AAED;AACA,eAAO,IAAP;AACD;;AAED;AACA,aAAO,2CAA0B,KAAKR,MAA/B,EAAuCD,CAAvC,EAA0CF,CAA1C,EAA6CC,IAA7C,CAAP;AACD;;;;;;kBApEkBN,U","file":"ArrayValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor, ObjectKind } from \"../types.js\";\nimport { ObjectValue, StringValue, NumberValue } from \"./index.js\";\nimport { ArraySetLength } from \"../methods/properties.js\";\nimport { OrdinaryGetOwnProperty, OrdinaryDefineOwnProperty, ThrowIfMightHaveBeenDeleted } from \"../methods/properties.js\";\nimport { IsAccessorDescriptor, IsPropertyKey, IsArrayIndex } from \"../methods/is.js\";\nimport { ToUint32 } from \"../methods/to.js\";\nimport invariant from \"../invariant.js\";\n\nexport default class ArrayValue extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ArrayPrototype, intrinsicName);\n  }\n\n  getKind(): ObjectKind {\n    return \"Array\";\n  }\n\n  // ECMA262 9.4.2.1\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let A = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"expected a property key\");\n\n    // 2. If P is \"length\", then\n    if (P === \"length\" || (P instanceof StringValue && P.value === \"length\")) {\n      // a. Return ? ArraySetLength(A, Desc).\n      return ArraySetLength(this.$Realm, A, Desc);\n    } else if (IsArrayIndex(this.$Realm, P)) { // 3. Else if P is an array index, then\n\n      // a. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n      let oldLenDesc = OrdinaryGetOwnProperty(this.$Realm, A, \"length\");\n\n      // b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are\n      //    created with a length data property that cannot be deleted or reconfigured.\n      invariant(oldLenDesc !== undefined &&\n        !IsAccessorDescriptor(this.$Realm, oldLenDesc), \"cannot be undefined or an accessor descriptor\");\n      ThrowIfMightHaveBeenDeleted(oldLenDesc.value);\n\n      // c. Let oldLen be oldLenDesc.[[Value]].\n      let oldLen = oldLenDesc.value;\n      invariant(oldLen !== undefined);\n      oldLen = oldLen.throwIfNotConcrete();\n      invariant(oldLen instanceof NumberValue, \"expected number value\");\n      oldLen = oldLen.value;\n\n      // d. Let index be ! ToUint32(P).\n      let index = ToUint32(this.$Realm, typeof P === \"string\" ? new StringValue(this.$Realm, P) : P);\n\n      // e. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.\n      if (index >= oldLen && oldLenDesc.writable === false) return false;\n\n      // f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).\n      let succeeded = OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n\n      // g. If succeeded is false, return false.\n      if (succeeded === false) return false;\n\n      // h. If index ≥ oldLen, then\n      if (index >= oldLen) {\n        // i. Set oldLenDesc.[[Value]] to index + 1.\n        oldLenDesc.value = new NumberValue(this.$Realm, index + 1);\n\n        // ii. Let succeeded be OrdinaryDefineOwnProperty(A, \"length\", oldLenDesc).\n        succeeded = OrdinaryDefineOwnProperty(this.$Realm, A, \"length\", oldLenDesc);\n\n        // iii. Assert: succeeded is true.\n        invariant(succeeded, \"expected length definition to succeed\");\n      }\n\n      // i. Return true.\n      return true;\n    }\n\n    // 1. Return OrdinaryDefineOwnProperty(A, P, Desc).\n    return OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n  }\n}\n"]}