{"version":3,"sources":["../../src/values/ArgumentsExotic.js"],"names":["ArgumentsExotic","realm","intrinsicName","intrinsics","ObjectPrototype","P","args","desc","$Realm","undefined","value","map","$ParameterMap","isMapped","Desc","newArgDesc","writable","Object","assign","allowed","$Delete","setStatus","Receiver","V","result"],"mappings":"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","file":"ArgumentsExotic.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor } from \"../types.js\";\nimport { ObjectValue, Value } from \"../values/index.js\";\nimport { OrdinaryGetOwnProperty, OrdinaryDefineOwnProperty, OrdinaryDelete, Set, OrdinarySet, ThrowIfMightHaveBeenDeleted } from \"../methods/properties.js\";\nimport { IsDataDescriptor, IsAccessorDescriptor } from \"../methods/is.js\";\nimport { HasOwnProperty } from \"../methods/has.js\";\nimport { SameValuePartial } from \"../methods/abstract.js\";\nimport { Get, OrdinaryGet } from \"../methods/get.js\";\nimport invariant from \"../invariant\";\n\nexport default class ArgumentsExotic extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);\n  }\n\n  $ParameterMap: void | ObjectValue;\n\n  // ECMA262 9.4.4.1\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let desc be OrdinaryGetOwnProperty(args, P).\n    let desc = OrdinaryGetOwnProperty(this.$Realm, args, P);\n\n    // 3. If desc is undefined, return desc.\n    if (desc === undefined) return undefined;\n    ThrowIfMightHaveBeenDeleted(desc.value);\n\n    // 4. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap; invariant(map);\n\n    // 5. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 6. If isMapped is true, then\n    if (isMapped === true) {\n      // a. Set desc.[[Value]] to Get(map, P).\n      desc.value = Get(this.$Realm, map, P);\n    }\n\n    // 7. Return desc.\n    return desc;\n  }\n\n  // ECMA262 9.4.4.2\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor) {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap; invariant(map);\n\n    // 3. Let isMapped be HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. Let newArgDesc be Desc.\n    let newArgDesc = Desc;\n\n    // 5. If isMapped is true and IsDataDescriptor(Desc) is true, then\n    if (isMapped === true && IsDataDescriptor(this.$Realm, Desc) === true) {\n      // a. If Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, then\n      if (Desc.value === undefined && Desc.writable === false) {\n        // i. Let newArgDesc be a copy of Desc.\n        newArgDesc = Object.assign({}, Desc);\n\n        // ii. Set newArgDesc.[[Value]] to Get(map, P).\n        newArgDesc.value = Get(this.$Realm, map, P);\n      }\n    }\n\n    // 6. Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).\n    let allowed = OrdinaryDefineOwnProperty(this.$Realm, args, P, newArgDesc);\n\n    // 7. If allowed is false, return false.\n    if (allowed === false) return false;\n\n    // 8. If isMapped is true, then\n    if (isMapped === true) {\n      // a. If IsAccessorDescriptor(Desc) is true, then\n      if (IsAccessorDescriptor(this.$Realm, Desc) === true) {\n        // i. Call map.[[Delete]](P).\n        map.$Delete(P);\n      } else { // b. Else,\n        // i. If Desc.[[Value]] is present, then\n        if (Desc.value !== undefined) {\n          // 1. Let setStatus be Set(map, P, Desc.[[Value]], false).\n          let setStatus = Set(this.$Realm, map, P, Desc.value, false);\n\n          // 2. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.\n          invariant(setStatus === true);\n        }\n\n        // ii. If Desc.[[Writable]] is present and its value is false, then\n        if (Desc.writable === false) {\n          // 1. Call map.[[Delete]](P).\n          map.$Delete(P);\n        }\n      }\n    }\n\n    // 9. Return true.\n    return true;\n  }\n\n  // ECMA262 9.4.4.3\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap; invariant(map);\n\n    // 3. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. If isMapped is false, then\n    if (isMapped === false) {\n      // a. Return ? OrdinaryGet(args, P, Receiver).\n      return OrdinaryGet(this.$Realm, args, P, Receiver);\n    } else { // 5. Else map contains a formal parameter mapping for P,\n      // b. Return Get(map, P).\n      return Get(this.$Realm, map, P);\n    }\n  }\n\n  // ECMA262 9.4.4.4\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    let isMapped, map;\n    // 2. If SameValue(args, Receiver) is false, then\n    if (SameValuePartial(this.$Realm, args, Receiver) === false) {\n      // a. Let isMapped be false.\n      isMapped = false;\n    } else { // 3. Else,\n      // a. Let map be args.[[ParameterMap]].\n      map = args.$ParameterMap; invariant(map);\n\n      // b. Let isMapped be ! HasOwnProperty(map, P).\n      isMapped = HasOwnProperty(this.$Realm, map, P);\n    }\n\n    // 4. If isMapped is true, then\n    if (isMapped === true) {\n      invariant(map);\n      // a. Let setStatus be Set(map, P, V, false).\n      let setStatus = Set(this.$Realm, map, P, V, false);\n\n      // b. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.\n      invariant(setStatus === true);\n    }\n\n    // 5. Return ? OrdinarySet(args, P, V, Receiver).\n    return OrdinarySet(this.$Realm, args, P, V, Receiver);\n  }\n\n  // ECMA262 9.4.4.5\n  $Delete(P: PropertyKeyValue): boolean {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap; invariant(map);\n\n    // 3. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. Let result be ? OrdinaryDelete(args, P).\n    let result = OrdinaryDelete(this.$Realm, args, P);\n\n    // 5. If result is true and isMapped is true, then\n    if (result === true && isMapped === true) {\n      // a. Call map.[[Delete]](P).\n      map.$Delete(P);\n    }\n\n    // 6. Return result.\n    return result;\n  }\n}\n"]}