{"version":3,"sources":["../../src/values/ProxyValue.js"],"names":["FindPropertyKey","realm","keys","key","i","length","ProxyValue","$Realm","undefined","handler","$ProxyHandler","createErrorThrowCompletion","intrinsics","TypeError","target","$ProxyTarget","trap","$GetPrototypeOf","handlerProto","extensibleTarget","targetProto","V","$SetPrototypeOf","booleanTrapResult","$IsExtensible","targetResult","$PreventExtensions","targetIsExtensible","P","$GetOwnProperty","trapResultObj","targetDesc","value","configurable","resultDesc","valid","Desc","$DefineOwnProperty","descObj","settingConfigFalse","$HasProperty","Receiver","$Get","trapResult","writable","get","$Set","set","$Delete","$OwnPropertyKeys","trapResultArray","targetKeys","targetConfigurableKeys","targetNonconfigurableKeys","desc","push","uncheckedResultKeys","slice","index","splice"],"mappings":"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","file":"ProxyValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { Value, SymbolValue, NullValue, ObjectValue, UndefinedValue, StringValue } from \"./index.js\";\nimport type { Descriptor, PropertyKeyValue } from \"../types.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  ToBooleanPartial,\n  ToPropertyDescriptor\n} from \"../methods/to.js\";\nimport { SameValue, SameValuePartial, SamePropertyKey } from \"../methods/abstract.js\";\nimport { GetMethod } from \"../methods/get.js\";\nimport {\n  CreateListFromArrayLike\n} from \"../methods/create.js\";\nimport {\n  IsExtensible,\n  IsPropertyKey,\n  IsDataDescriptor,\n  IsAccessorDescriptor,\n} from \"../methods/is.js\";\nimport {\n  FromPropertyDescriptor,\n  CompletePropertyDescriptor,\n  IsCompatiblePropertyDescriptor,\n  ThrowIfMightHaveBeenDeleted,\n} from \"../methods/properties.js\";\nimport { Call } from \"../methods/call.js\";\n\nfunction FindPropertyKey(realm: Realm, keys: Array<PropertyKeyValue>, key: PropertyKeyValue): number {\n  for (let i = 0; i < keys.length; ++i) {\n    if (SamePropertyKey(realm, key, keys[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport default class ProxyValue extends ObjectValue {\n  $ProxyTarget: NullValue | ObjectValue;\n  $ProxyHandler: NullValue | ObjectValue;\n\n  realm: Realm;\n\n  constructor(realm: Realm) {\n    super(realm);\n\n    // $FlowFixMe TODO: exotics should not have $Realm\n    this.$Realm = undefined;\n    this.realm = realm;\n  }\n\n  // ECMA262 9.5.1\n  $GetPrototypeOf(): NullValue | ObjectValue {\n    let realm = this.realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected an object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 5. Let trap be ? GetMethod(handler, \"getPrototypeOf\").\n    let trap = GetMethod(realm, handler, \"getPrototypeOf\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[GetPrototypeOf]]().\n      return target.$GetPrototypeOf();\n    }\n\n    // 7. Let handlerProto be ? Call(trap, handler, « target »).\n    let handlerProto = Call(realm, trap, handler, [target]);\n\n    // 8. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.\n    if (!(handlerProto instanceof ObjectValue) && !(handlerProto instanceof NullValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 10. If extensibleTarget is true, return handlerProto.\n    if (extensibleTarget) return handlerProto;\n\n    // 11. Let targetProto be ? target.[[GetPrototypeOf]]().\n    let targetProto = target.$GetPrototypeOf();\n\n    // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.\n    if (!SameValue(realm, handlerProto, targetProto)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 13. Return handlerProto.\n    return handlerProto;\n  }\n\n  // ECMA262 9.5.2\n  $SetPrototypeOf(V: ObjectValue | NullValue): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n    invariant(V instanceof ObjectValue || V instanceof NullValue, \"expected object or null\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"setPrototypeOf\").\n    let trap = GetMethod(realm, handler, \"setPrototypeOf\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[SetPrototypeOf]](V).\n      return target.$SetPrototypeOf(V);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, V »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target, V]));\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 11. If extensibleTarget is true, return true.\n    if (extensibleTarget) return true;\n\n    // 12. Let targetProto be ? target.[[GetPrototypeOf]]().\n    let targetProto = target.$GetPrototypeOf();\n\n    // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.\n    if (!SameValue(realm, V, targetProto)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 14. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.3\n  $IsExtensible(): boolean {\n    let realm = this.realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 5. Let trap be ? GetMethod(handler, \"isExtensible\").\n    let trap = GetMethod(realm, handler, \"isExtensible\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[IsExtensible]]().\n      invariant(target instanceof ObjectValue);\n      return target.$IsExtensible();\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target]));\n\n    // 8. Let targetResult be ? target.[[IsExtensible]]().\n    invariant(target instanceof ObjectValue);\n    let targetResult = target.$IsExtensible();\n\n    // 9. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.\n    if (booleanTrapResult !== targetResult) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.4\n  $PreventExtensions(): boolean {\n    let realm = this.realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 5. Let trap be ? GetMethod(handler, \"preventExtensions\").\n    let trap = GetMethod(realm, handler, \"preventExtensions\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[PreventExtensions]]().\n      invariant(target instanceof ObjectValue);\n      return target.$PreventExtensions();\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target]));\n\n    // 8. If booleanTrapResult is true, then\n    if (booleanTrapResult) {\n      // a. Let targetIsExtensible be ? target.[[IsExtensible]]().\n      invariant(target instanceof ObjectValue);\n      let targetIsExtensible = target.$IsExtensible();\n\n      // b. If targetIsExtensible is true, throw a TypeError exception.\n      if (targetIsExtensible) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 9. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.5\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"getOwnPropertyDescriptor\").\n    let trap = GetMethod(realm, handler, \"getOwnPropertyDescriptor\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[GetOwnProperty]](P).\n      return target.$GetOwnProperty(P);\n    }\n\n    // 8. Let trapResultObj be ? Call(trap, handler, « target, P »).\n    let trapResultObj = Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P]);\n\n    // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.\n    if (!(trapResultObj instanceof ObjectValue) && !(trapResultObj instanceof UndefinedValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If trapResultObj is undefined, then\n    if (trapResultObj instanceof UndefinedValue) {\n      // a. If targetDesc is undefined, return undefined.\n      if (!targetDesc) return undefined;\n      ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n      if (!targetDesc.configurable) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // c. Let extensibleTarget be ? IsExtensible(target).\n      let extensibleTarget = IsExtensible(realm, target);\n\n      // d. Assert: Type(extensibleTarget) is Boolean.\n      invariant(typeof extensibleTarget === \"boolean\", \"expected boolean\");\n\n      // e. If extensibleTarget is false, throw a TypeError exception.\n      if (!extensibleTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // f. Return undefined.\n      return undefined;\n    }\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).\n    let resultDesc = ToPropertyDescriptor(realm, trapResultObj);\n\n    // 14. Call CompletePropertyDescriptor(resultDesc).\n    CompletePropertyDescriptor(realm, resultDesc);\n\n    // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).\n    let valid = IsCompatiblePropertyDescriptor(realm, extensibleTarget, resultDesc, targetDesc);\n\n    // 16. If valid is false, throw a TypeError exception.\n    if (!valid) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 17. If resultDesc.[[Configurable]] is false, then\n    if (!resultDesc.configurable) {\n      // a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then\n      if (!targetDesc || targetDesc.configurable) {\n        // i. Throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 18. Return resultDesc.\n    return resultDesc;\n  }\n\n  // ECMA262 9.5.6\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"defineProperty\").\n    let trap = GetMethod(realm, handler, \"defineProperty\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[DefineOwnProperty]](P, Desc).\n      return target.$DefineOwnProperty(P, Desc);\n    }\n\n    // 8. Let descObj be FromPropertyDescriptor(Desc).\n    let descObj = FromPropertyDescriptor(realm, Desc);\n\n    // 9. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, descObj »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, descObj]));\n\n    // 10. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then\n    let settingConfigFalse;\n    if (\"configurable\" in Desc && !Desc.configurable) {\n      // a. Let settingConfigFalse be true.\n      settingConfigFalse = true;\n    } else { // 14. Else let settingConfigFalse be false.\n      settingConfigFalse = false;\n    }\n\n    // 15. If targetDesc is undefined, then\n    if (!targetDesc) {\n      // a. If extensibleTarget is false, throw a TypeError exception.\n      if (!extensibleTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // b. If settingConfigFalse is true, throw a TypeError exception.\n      if (settingConfigFalse) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    } else { // 16. Else targetDesc is not undefined,\n      ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.\n      if (!IsCompatiblePropertyDescriptor(realm, extensibleTarget, Desc, targetDesc)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.\n      if (settingConfigFalse && targetDesc.configurable) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 17. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.7\n  $HasProperty(P: PropertyKeyValue): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"has\").\n    let trap = GetMethod(realm, handler, \"has\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[HasProperty]](P).\n      return target.$HasProperty(P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P]));\n\n    // 9. If booleanTrapResult is false, then\n    if (!booleanTrapResult) {\n      // a. Let targetDesc be ? target.[[GetOwnProperty]](P).\n      let targetDesc = target.$GetOwnProperty(P);\n\n      // b. If targetDesc is not undefined, then\n      if (targetDesc) {\n        ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n        // i. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n        if (!targetDesc.configurable) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n\n        // ii. Let extensibleTarget be ? IsExtensible(target).\n        let extensibleTarget = IsExtensible(realm, target);\n\n        // iii. If extensibleTarget is false, throw a TypeError exception.\n        if (!extensibleTarget) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.8\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"get\").\n    let trap = GetMethod(realm, handler, \"get\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Get]](P, Receiver).\n      return target.$Get(P, Receiver);\n    }\n\n    // 8. Let trapResult be ? Call(trap, handler, « target, P, Receiver »).\n    let trapResult = Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, Receiver]);\n\n    // 9. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 10. If targetDesc is not undefined, then\n    if (targetDesc) {\n      ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then\n      if (IsDataDescriptor(realm, targetDesc) && targetDesc.configurable === false && targetDesc.writable === false) {\n        // i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        if (!SameValuePartial(realm, trapResult, targetDesc.value || realm.intrinsics.undefined)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n\n      // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Get]] is undefined, then\n      if (IsAccessorDescriptor(realm, targetDesc) && targetDesc.configurable === false && (!targetDesc.get || targetDesc.get instanceof UndefinedValue)) {\n        // i. If trapResult is not undefined, throw a TypeError exception.\n        if (!(trapResult instanceof UndefinedValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 11. Return trapResult.\n    return trapResult;\n  }\n\n  // ECMA262 9.5.9\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 6. Let trap be ? GetMethod(handler, \"set\").\n    let trap = GetMethod(realm, handler, \"set\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Set]](P, V, Receiver).\n      invariant(target instanceof ObjectValue);\n      return target.$Set(P, V, Receiver);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, V, Receiver]));\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    invariant(target instanceof ObjectValue);\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If targetDesc is not undefined, then\n    if (targetDesc) {\n      ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then\n      if (IsDataDescriptor(realm, targetDesc) && !targetDesc.configurable && !targetDesc.writable) {\n        // i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        if (!SameValuePartial(realm, V, targetDesc.value || realm.intrinsics.undefined)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n\n      // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false, then\n      if (IsAccessorDescriptor(realm, targetDesc) && !targetDesc.configurable) {\n        // i. If targetDesc.[[Set]] is undefined, throw a TypeError exception.\n        if (!targetDesc.set || targetDesc.set instanceof UndefinedValue) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 12. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.10\n  $Delete(P: PropertyKeyValue): boolean {\n    let realm = this.realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 6. Let trap be ? GetMethod(handler, \"deleteProperty\").\n    let trap = GetMethod(realm, handler, \"deleteProperty\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Delete]](P).\n      invariant(target instanceof ObjectValue);\n      return target.$Delete(P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    let booleanTrapResult = ToBooleanPartial(realm, Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P]));\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    invariant(target instanceof ObjectValue);\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If targetDesc is undefined, return true.\n    if (!targetDesc) return true;\n    ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n    // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n    if (!targetDesc.configurable) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 13. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.11\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    let realm = this.realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 5. Let trap be ? GetMethod(handler, \"ownKeys\").\n    let trap = GetMethod(realm, handler, \"ownKeys\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[OwnPropertyKeys]]().\n      return target.$OwnPropertyKeys();\n    }\n\n    // 7. Let trapResultArray be ? Call(trap, handler, « target »).\n    let trapResultArray = Call(realm, trap, handler, [target]);\n\n    // 8. Let trapResult be ? CreateListFromArrayLike(trapResultArray, « String, Symbol »).\n    let trapResult : Array<PropertyKeyValue> = ((CreateListFromArrayLike(realm, trapResultArray, [\"String\", \"Symbol\"]): any): Array<PropertyKeyValue>);\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 10. Let targetKeys be ? target.[[OwnPropertyKeys]]().\n    let targetKeys = target.$OwnPropertyKeys();\n\n    // 11. Assert: targetKeys is a List containing only String and Symbol values.\n    for (let key of targetKeys) {\n      invariant(key instanceof SymbolValue || key instanceof StringValue, \"expected string or symbol\");\n    }\n\n    // 12. Let targetConfigurableKeys be a new empty List.\n    let targetConfigurableKeys = [];\n\n    // 13. Let targetNonconfigurableKeys be a new empty List.\n    let targetNonconfigurableKeys = [];\n\n    // 14. Repeat, for each element key of targetKeys,\n    for (let key of targetKeys) {\n      // a. Let desc be ? target.[[GetOwnProperty]](key).\n      let desc = target.$GetOwnProperty(key);\n      if (desc) ThrowIfMightHaveBeenDeleted(desc.value);\n\n      // b. If desc is not undefined and desc.[[Configurable]] is false, then\n      if (desc && desc.configurable === false) {\n        // i. Append key as an element of targetNonconfigurableKeys.\n        targetNonconfigurableKeys.push(key);\n      } else { // c. Else,\n        // i. Append key as an element of targetConfigurableKeys.\n        targetConfigurableKeys.push(key);\n      }\n    }\n\n    // 15. If extensibleTarget is true and targetNonconfigurableKeys is empty, then\n    if (extensibleTarget && !targetNonconfigurableKeys.length) {\n      // a. Return trapResult.\n      return trapResult;\n    }\n\n    // 16. Let uncheckedResultKeys be a new List which is a copy of trapResult.\n    let uncheckedResultKeys = trapResult.slice();\n\n    // 17. Repeat, for each key that is an element of targetNonconfigurableKeys,\n    for (let key of targetNonconfigurableKeys) {\n      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      let index = FindPropertyKey(realm, uncheckedResultKeys, key);\n      if (index < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"key is not an element of uncheckedResultKeys\");\n      }\n\n      // b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(index, 1);\n    }\n\n    // 18. If extensibleTarget is true, return trapResult.\n    if (extensibleTarget) return trapResult;\n\n    // 19. Repeat, for each key that is an element of targetConfigurableKeys,\n    for (let key of targetConfigurableKeys) {\n      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      let index = FindPropertyKey(realm, uncheckedResultKeys, key);\n      if (index < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"key is not an element of uncheckedResultKeys\");\n      }\n\n      // b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(index, 1);\n    }\n\n    // 20. If uncheckedResultKeys is not empty, throw a TypeError exception.\n    if (uncheckedResultKeys.length) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 21. Return trapResult.\n    return trapResult;\n  }\n}\n"]}