{"version":3,"sources":["../../src/values/StringExotic.js"],"names":["StringExotic","realm","intrinsicName","intrinsics","StringPrototype","P","desc","$Realm","undefined","value","index","Infinity","str","$StringData","len","length","resultStr","charAt","writable","enumerable","configurable","keys","i","push","properties","getOwnPropertyKeysArray","filter","x","map","parseInt","sort","y","key","symbols"],"mappings":"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","file":"StringExotic.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor } from \"../types.js\";\nimport { ObjectValue, NumberValue, StringValue } from \"../values/index.js\";\nimport { OrdinaryGetOwnProperty, ThrowIfMightHaveBeenDeleted } from \"../methods/properties.js\";\nimport { CanonicalNumericIndexString } from \"../methods/to.js\";\nimport { IsInteger, IsArrayIndex } from \"../methods/is.js\";\nimport { ToString, ToInteger } from \"../methods/to.js\";\nimport invariant from \"../invariant\";\n\nexport default class StringExotic extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.StringPrototype, intrinsicName);\n  }\n\n  $StringData: void | StringValue;\n\n  // ECMA262 9.4.3.1\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    // 1. Assert: IsPropertyKey(P) is true.\n\n    // 2. Let desc be OrdinaryGetOwnProperty(S, P).\n    let desc = OrdinaryGetOwnProperty(this.$Realm, this, P);\n\n    // 3. If desc is not undefined, return desc.\n    if (desc !== undefined) {\n      ThrowIfMightHaveBeenDeleted(desc.value);\n      return desc;\n    }\n\n    // 4. If Type(P) is not String, return undefined.\n    if (typeof P !== \"string\" && !(P instanceof StringValue)) return undefined;\n\n    // 5. Let index be ! CanonicalNumericIndexString(P).\n    let index = CanonicalNumericIndexString(this.$Realm, typeof P === \"string\" ? new StringValue(this.$Realm, P) : P);\n\n    // 6. If index is undefined, return undefined.\n    if (index === undefined || index === null) return undefined;\n\n    // 7. If IsInteger(index) is false, return undefined.\n    if (IsInteger(this.$Realm, index) === false) return undefined;\n\n    // 8. If index = -0, return undefined.\n    if (1.0 / index === -Infinity) return undefined;\n\n    // 9. Let str be the String value of S.[[StringData]].\n    let str = this.$StringData; invariant(str);\n\n    // 10. Let len be the number of elements in str.\n    let len = str.value.length;\n\n    // 11. If index < 0 or len ≤ index, return undefined.\n    if (index < 0 || len <= index) return undefined;\n\n    // 12. Let resultStr be a String value of length 1, containing one code unit from str, specifically the code unit at index index.\n    let resultStr = new StringValue(this.$Realm, str.value.charAt(index));\n\n    // 13. Return a PropertyDescriptor{[[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}.\n    return {\n      value: resultStr,\n      writable: false,\n      enumerable: true,\n      configurable: false\n    };\n  }\n\n  // ECMA262 9.4.3.2\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    // 1. Let keys be a new empty List.\n    let keys = [];\n\n    // 2. Let str be the String value of O.[[StringData]].\n    let str = this.$StringData; invariant(str);\n\n    // 3. Let len be the number of elements in str.\n    let len = str.value.length;\n\n    // 4. For each integer i starting with 0 such that i < len, in ascending order,\n    for (let i = 0; i < len; ++i) {\n      // a. Add ! ToString(i) as the last element of keys.\n      keys.push(new StringValue(this.$Realm, ToString(this.$Realm, new NumberValue(this.$Realm, i))));\n    }\n\n    // 5. For each own property key P of O such that P is an integer index and ToInteger(P) ≥ len, in ascending numeric index order,\n    let properties = this.getOwnPropertyKeysArray();\n    for (let key of properties.filter((x) => IsArrayIndex(this.$Realm, x)).map((x) => parseInt(x, 10)).filter((x) => ToInteger(this.$Realm, x) >= len).sort((x, y) => x - y)) {\n      // i. Add P as the last element of keys.\n      keys.push(new StringValue(this.$Realm, key + \"\"));\n    }\n\n    // 6. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation,\n    for (let key of properties.filter((x) => !IsArrayIndex(this.$Realm, x))) {\n      // i. Add P as the last element of keys.\n      keys.push(new StringValue(this.$Realm, key));\n    }\n\n    // 7. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation,\n    for (let key of this.symbols.keys()) {\n      // i. Add P as the last element of keys.\n      keys.push(key);\n    }\n\n    // 12. Return keys.\n    return keys;\n  }\n}\n"]}