{"version":3,"sources":["../../src/values/ObjectValue.js"],"names":["t","ObjectValue","realm","proto","intrinsicName","recordNewObject","isPartial","setupBindings","$Prototype","intrinsics","null","$Extensible","true","_isPartial","false","_isSimple","properties","Map","symbols","trackedProperties","propName","desc","writeable","value","undefined","descriptor","object","key","$Realm","values","propertyBinding","writable","ObjectPrototype","isSimple","v","$SymbolData","$StringData","$NumberData","$BooleanData","$DateValue","$RegExpMatcher","$SetData","$MapData","$DataView","$ArrayBufferData","$WeakMapData","$WeakSetData","$TypedArrayName","name","length","callback","defineNativeProperty","$DefineOwnProperty","enumerable","configurable","funcName","$Description","func","$Construct","$ConstructorKind","get","set","unknownProperty","createIntrospectionErrorThrowCompletion","o","keyArray","Array","from","keys","filter","x","pb","pv","mightHaveBeenDeleted","stack","obj","serializedDesc","serialize","Object","defineProperty","V","P","Desc","$GetOwnProperty","Receiver","prop","val","specializeJoin","$Get","mightNotBeString","result","createAbstract","topVal","memberExpression","cond","binaryExpression","stringLiteral","absVal","args","generic_cond","specializeCond","arg1","arg2","types","_buildNode","kind","$Set","recordModifiedProperty","newVal","y","oldVal","empty","prototype","binding"],"mappings":"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","file":"ObjectValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm, ExecutionContext } from \"../realm.js\";\nimport type { IterationKind, PromiseCapability, PromiseReaction, DataBlock, PropertyKeyValue, PropertyBinding, Descriptor, ObjectKind, TypedArrayKind } from \"../types.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { Value, AbstractValue, ConcreteValue, BooleanValue, StringValue, SymbolValue, NumberValue, UndefinedValue, NullValue, FunctionValue, NativeFunctionValue } from \"./index.js\";\nimport type { NativeFunctionCallback } from \"./index.js\";\nimport { joinValuesAsConditional, IsDataDescriptor, OrdinarySetPrototypeOf, OrdinaryDefineOwnProperty, OrdinaryDelete,\n   OrdinaryOwnPropertyKeys, OrdinaryGetOwnProperty, OrdinaryGet, OrdinaryHasProperty, OrdinarySet,\n   OrdinaryIsExtensible, OrdinaryPreventExtensions, ThrowIfMightHaveBeenDeleted } from \"../methods/index.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default class ObjectValue extends ConcreteValue {\n  constructor(realm: Realm, proto?: ObjectValue | NullValue, intrinsicName?: string) {\n    super(realm, intrinsicName);\n    realm.recordNewObject(this);\n    if (realm.isPartial) this.setupBindings();\n    this.$Prototype = proto || realm.intrinsics.null;\n    this.$Extensible = realm.intrinsics.true;\n    this._isPartial = realm.intrinsics.false;\n    this._isSimple = realm.intrinsics.false;\n    this.properties = new Map();\n    this.symbols = new Map();\n  }\n\n  static trackedProperties = [\"$Prototype\", \"$Extensible\", \"$SetNextIndex\", \"$IteratedSet\",\n   \"$MapNextIndex\", \"$MapData\", \"$Map\", \"$DateValue\", \"$ArrayIteratorNextIndex\", \"$IteratedObject\",\n   \"$StringIteratorNextIndex\", \"$IteratedString\", \"_isPartial\", \"_isSimple\"];\n\n  setupBindings() {\n    for (let propName of ObjectValue.trackedProperties) {\n      let desc = { writeable: true, value: undefined };\n      (this: any)[propName + \"_binding\"] = { descriptor: desc, object: this, key: propName };\n    }\n  }\n\n  static setupTrackedPropertyAccessors() {\n    for (let propName of ObjectValue.trackedProperties) {\n      Object.defineProperty(ObjectValue.prototype, propName,\n        { configurable: true,\n          get: function() {\n            let binding = this[propName + \"_binding\"];\n            return binding.descriptor.value;\n          },\n          set: function(v) {\n            let binding = this[propName + \"_binding\"];\n            this.$Realm.recordModifiedProperty(binding);\n            binding.descriptor.value = v;\n          }\n        });\n    }\n  }\n\n  $Prototype: ObjectValue | NullValue;\n  $Extensible: BooleanValue;\n\n  $ParameterMap: void | ObjectValue; // undefined when the property is \"missing\"\n  $SymbolData: void | SymbolValue;\n  $StringData: void | StringValue;\n  $NumberData: void | NumberValue;\n  $BooleanData: void | BooleanValue;\n\n  // error\n  $ErrorData: void | { // undefined when the property is \"missing\"\n    contextStack: Array<ExecutionContext>,\n    locationData: void | {\n      filename: string,\n      sourceCode: string,\n      loc: { line: number, column: number },\n      stackDecorated: boolean\n    }\n  };\n\n  // function\n  $Call: void | ((thisArgument: Value, argumentsList: Array<Value>) => Value);\n  $Construct: void | ((argumentsList: Array<Value>, newTarget: ObjectValue) => ObjectValue);\n\n  // promise\n  $Promise: ?ObjectValue;\n  $AlreadyResolved: void | { value: boolean };\n  $PromiseState: void | \"pending\" | \"fulfilled\" | \"rejected\";\n  $PromiseResult: void | Value;\n  $PromiseFulfillReactions: void | Array<PromiseReaction>;\n  $PromiseRejectReactions: void | Array<PromiseReaction>;\n  $PromiseIsHandled: void | boolean;\n  $Capability: void | PromiseCapability;\n  $AlreadyCalled: void | { value: boolean };\n  $Index: void | number;\n  $Values: void | Array<Value>;\n  $Capabilities: void | PromiseCapability;\n  $RemainingElements: void | { value: number };\n\n  // set\n  $SetIterationKind: void | IterationKind;\n  $SetNextIndex: void | number;\n  $IteratedSet: void | ObjectValue | UndefinedValue;\n  $SetData: void | Array<void | Value>;\n\n  // map\n  $MapIterationKind: void | IterationKind;\n  $MapNextIndex: void | NumberValue;\n  $MapData: void | Array<{$Key: void | Value, $Value: void | Value}>;\n  $Map: void | ObjectValue | UndefinedValue;\n\n  // weak map\n  $WeakMapData: void | Array<{$Key: void | Value, $Value: void | Value}>;\n\n  // weak set\n  $WeakSetData: void | Array<void | Value>;\n\n  // date\n  $DateValue: void | NumberValue | AbstractValue; // of type number\n\n  // array\n  $ArrayIterationKind: void | IterationKind;\n  $ArrayIteratorNextIndex: void | NumberValue;\n  $IteratedObject: void | UndefinedValue | ObjectValue;\n\n  // regex\n  $OriginalSource: void | string;\n  $OriginalFlags: void | string;\n  $RegExpMatcher: void | ((S: string, lastIndex: number) => ?{endIndex: number, captures: Array<any>});\n\n  // string\n  $StringIteratorNextIndex: void | number;\n  $IteratedString: void | StringValue;\n\n  // data view\n  $DataView: void | true;\n  $ViewedArrayBuffer: void | ObjectValue;\n  $ByteLength: void | number;\n  $ByteOffset: void | number;\n\n  // array buffer\n  $ArrayBufferData: void | null | DataBlock;\n  $ArrayBufferByteLength: void | number;\n\n  // generator\n  $GeneratorState: void | \"suspendedStart\" | \"executing\";\n  $GeneratorContext: void | ExecutionContext;\n\n  // typed array\n  $TypedArrayName: void | TypedArrayKind;\n  $ViewedArrayBuffer: void | ObjectValue;\n  $ArrayLength: void | number;\n\n  // backpointer to the constructor if this object was created its prototype object\n  originalConstructor: void | FunctionValue;\n\n  // partial objects\n  _isPartial: BooleanValue;\n\n  // If true, the object has no property getters or setters and it is safe\n  // to return AbstractValue for unknown properties.\n  _isSimple: BooleanValue;\n\n  properties: Map<string, PropertyBinding>;\n  symbols: Map<SymbolValue, PropertyBinding>;\n  unknownProperty: void | PropertyBinding;\n\n  mightNotBeObject(): boolean {\n    return false;\n  }\n\n  throwIfNotObject(): ObjectValue {\n    return this;\n  }\n\n  makeNotPartial(): void {\n    this._isPartial = this.$Realm.intrinsics.false;\n  }\n\n  makePartial(): void {\n    this._isPartial = this.$Realm.intrinsics.true;\n  }\n\n  makeSimple(): void {\n    this._isSimple = this.$Realm.intrinsics.true;\n  }\n\n  isPartial(): boolean {\n    return this._isPartial.value;\n  }\n\n  isSimple(): boolean {\n    if (this._isSimple.value) return true;\n    if (this.isPartial())\n      return false;\n    for (let propertyBinding of this.properties.values()) {\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; // deleted\n      if (!IsDataDescriptor(this.$Realm, desc))\n        return false;\n      if (!desc.writable) return false;\n    }\n    if (this.$Prototype instanceof NullValue) return true;\n    if (this.$Prototype === this.$Realm.intrinsics.ObjectPrototype) return true;\n    return this.$Prototype.isSimple();\n  }\n\n  getExtensible(): boolean {\n    return this.$Extensible.value;\n  }\n\n  setExtensible(v: boolean) {\n    this.$Extensible = v ? this.$Realm.intrinsics.true : this.$Realm.intrinsics.false;\n  }\n\n  getKind(): ObjectKind {\n    // we can deduce the natural prototype by checking whether the following internal slots are present\n    if (this.$SymbolData !== undefined) return \"Symbol\";\n    if (this.$StringData !== undefined) return \"String\";\n    if (this.$NumberData !== undefined) return \"Number\";\n    if (this.$BooleanData !== undefined) return \"Boolean\";\n    if (this.$DateValue !== undefined) return \"Date\";\n    if (this.$RegExpMatcher !== undefined) return \"RegExp\";\n    if (this.$SetData !== undefined) return \"Set\";\n    if (this.$MapData !== undefined) return \"Map\";\n    if (this.$DataView !== undefined) return \"DataView\";\n    if (this.$ArrayBufferData !== undefined) return \"ArrayBuffer\";\n    if (this.$WeakMapData !== undefined) return \"WeakMap\";\n    if (this.$WeakSetData !== undefined) return \"WeakSet\";\n    if (this.$TypedArrayName !== undefined) return this.$TypedArrayName;\n    // TODO #26: Promises. All kinds of iterators. Generators.\n    return \"Object\";\n  }\n\n  defineNativeMethod(name: SymbolValue | string, length: number, callback: NativeFunctionCallback, desc?: Descriptor = {}) {\n    let intrinsicName;\n    if (typeof name === \"string\") {\n      if (this.intrinsicName) intrinsicName = `${this.intrinsicName}.${name}`;\n    } else if (name instanceof SymbolValue) {\n      if (this.intrinsicName && name.intrinsicName) intrinsicName = `${this.intrinsicName}[${name.intrinsicName}]`;\n    } else {\n      invariant(false);\n    }\n    this.defineNativeProperty(\n        name,\n        new NativeFunctionValue(\n            this.$Realm,\n            intrinsicName,\n            name,\n            length,\n            callback,\n            false\n        ),\n        desc\n    );\n  }\n\n  defineNativeProperty(name: SymbolValue | string, value?: Value, desc?: Descriptor = {}) {\n    this.$DefineOwnProperty(name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      ...desc\n    });\n  }\n\n  defineNativeGetter(name: SymbolValue | string, callback: NativeFunctionCallback, desc?: Descriptor = {}) {\n    let intrinsicName, funcName;\n    if (typeof name === \"string\") {\n      funcName = `get ${name}`;\n      if (this.intrinsicName) intrinsicName = `${this.intrinsicName}.${name}`;\n    } else if (name instanceof SymbolValue) {\n      funcName = `get [${name.$Description || \"?\"}]`;\n      if (this.intrinsicName && name.intrinsicName) intrinsicName = `${this.intrinsicName}[${name.intrinsicName}]`;\n    } else {\n      invariant(false);\n    }\n\n    let func = new NativeFunctionValue(this.$Realm, intrinsicName, funcName, 0, callback);\n    func.$Construct = undefined;\n    func.$ConstructorKind = undefined;\n    this.$DefineOwnProperty(name, {\n      get: func,\n      set: this.$Realm.intrinsics.undefined,\n      enumerable: false,\n      configurable: true,\n      ...desc\n    });\n  }\n\n  defineNativeConstant(name: SymbolValue | string, value?: Value, desc?: Descriptor = {}) {\n    this.$DefineOwnProperty(name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n      ...desc\n    });\n  }\n\n  getOwnPropertyKeysArray(): Array<string> {\n    if (this.isPartial() || this.unknownProperty !== undefined) {\n      throw AbstractValue.createIntrospectionErrorThrowCompletion(this);\n    }\n\n    let o = this;\n    let keyArray = Array.from(o.properties.keys());\n    keyArray = keyArray.filter(\n      function (x) {\n         let pb = o.properties.get(x);\n         if (!pb || pb.descriptor === undefined) return false;\n         let pv = pb.descriptor.value;\n         if (pv === undefined) return true;\n         if (!pv.mightHaveBeenDeleted()) return true;\n         // The property may or may not be there at runtime.\n         // We can at best return an abstract keys array.\n         // For now just terminate.\n         invariant(pv instanceof AbstractValue);\n         throw AbstractValue.createIntrospectionErrorThrowCompletion(pv);\n      });\n    return keyArray;\n  }\n\n  _serialize(set: Function, stack: Map<Value, any>): any {\n    let obj = set({});\n\n    for (let [key, propertyBinding] of this.properties) {\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; // deleted\n      ThrowIfMightHaveBeenDeleted(desc.value);\n      let serializedDesc: any = { enumerable: desc.enumerable, configurable: desc.configurable };\n      if (desc.value) {\n        serializedDesc.writable = desc.writable;\n        serializedDesc.value = desc.value.serialize(stack);\n      } else {\n        invariant(desc.get !== undefined);\n        serializedDesc.get = desc.get.serialize(stack);\n        invariant(desc.set !== undefined);\n        serializedDesc.set = desc.set.serialize(stack);\n      }\n      Object.defineProperty(obj, key, serializedDesc);\n    }\n    return obj;\n  }\n\n  // ECMA262 9.1.1\n  $GetPrototypeOf(): ObjectValue | NullValue {\n    return this.$Prototype;\n  }\n\n  // ECMA262 9.1.2\n  $SetPrototypeOf(V: ObjectValue | NullValue): boolean {\n    // 1. Return ! OrdinarySetPrototypeOf(O, V).\n    return OrdinarySetPrototypeOf(this.$Realm, this, V);\n  }\n\n  // ECMA262 9.1.3\n  $IsExtensible(): boolean {\n    // 1. Return ! OrdinaryIsExtensible(O).\n    return OrdinaryIsExtensible(this.$Realm, this);\n  }\n\n  // ECMA262 9.1.4\n  $PreventExtensions(): boolean {\n    // 1. Return ! OrdinaryPreventExtensions(O).\n    return OrdinaryPreventExtensions(this.$Realm, this);\n  }\n\n  // ECMA262 9.1.5\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    // 1. Return ! OrdinaryGetOwnProperty(O, P).\n    return OrdinaryGetOwnProperty(this.$Realm, this, P);\n  }\n\n  // ECMA262 9.1.6\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    // 1. Return ? OrdinaryDefineOwnProperty(O, P, Desc).\n    return OrdinaryDefineOwnProperty(this.$Realm, this, P, Desc);\n  }\n\n  // ECMA262 9.1.7\n  $HasProperty(P: PropertyKeyValue): boolean {\n    if (this.unknownProperty !== undefined && this.$GetOwnProperty(P) === undefined) {\n      throw AbstractValue.createIntrospectionErrorThrowCompletion(this, P);\n    }\n\n    return OrdinaryHasProperty(this.$Realm, this, P);\n  }\n\n  // ECMA262 9.1.8\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    let prop = this.unknownProperty;\n    if (prop !== undefined && prop.descriptor !== undefined && this.$GetOwnProperty(P) === undefined) {\n      let desc = prop.descriptor; invariant(desc !== undefined);\n      let val = desc.value; invariant(val instanceof AbstractValue);\n      let propName;\n      if (P instanceof StringValue) {\n        propName = P;\n      } else if (typeof P === \"string\") {\n        propName = new StringValue(this.$Realm, P);\n      } else {\n        throw this.$Realm.createIntrospectionErrorThrowCompletion(\"abstract computed property name\");\n      }\n      return this.specializeJoin(val, propName);\n    }\n\n    // 1. Return ? OrdinaryGet(O, P, Receiver).\n    return OrdinaryGet(this.$Realm, this, P, Receiver);\n  }\n\n  $GetPartial(P: AbstractValue | PropertyKeyValue, Receiver: Value): Value {\n    if (!(P instanceof AbstractValue)) return this.$Get(P, Receiver);\n    // We assume that simple objects have no getter/setter properties.\n    if (this !== Receiver || !this.isSimple() || P.mightNotBeString())\n      throw this.$Realm.createIntrospectionErrorThrowCompletion(\"TODO\");\n    // If all else fails, use this expression\n    let result;\n    if (this.isPartial()) {\n      result = this.$Realm.createAbstract(TypesDomain.topVal, ValuesDomain.topVal,\n        [this, P],\n        ([o, x]) => t.memberExpression(o, x, true), \"sentinel member expression\");\n    } else {\n      result = this.$Realm.intrinsics.undefined;\n    }\n    // Get a specialization of the join of all values written to the object\n    // with abstract property names.\n    let prop = this.unknownProperty;\n    if (prop !== undefined) {\n      let desc = prop.descriptor; invariant(desc !== undefined);\n      let val = desc.value; invariant(val instanceof AbstractValue);\n      result = this.specializeJoin(val, P);\n    }\n    // Join in all of the other values that were written to the object with\n    // concrete property names.\n    for (let [key, propertyBinding] of this.properties) {\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; // deleted\n      invariant(desc.value !== undefined); // otherwise this is not simple\n      let val = desc.value;\n      let cond = this.$Realm.createAbstract(new TypesDomain(BooleanValue), ValuesDomain.topVal,\n        [P],\n        ([x]) => t.binaryExpression(\"===\", x, t.stringLiteral(key)), \"check for known property\");\n      result = joinValuesAsConditional(this.$Realm, cond, val, result);\n    }\n    return result;\n  }\n\n  specializeJoin(absVal: AbstractValue, propName: Value): AbstractValue {\n    invariant(absVal.args.length === 3);\n    let generic_cond = absVal.args[0];\n    invariant(generic_cond instanceof AbstractValue);\n    let cond = this.specializeCond(generic_cond, propName);\n    let arg1 = absVal.args[1];\n    if (arg1 instanceof AbstractValue && arg1.args.length === 3)\n      arg1 = this.specializeJoin(arg1, propName);\n    let arg2 = absVal.args[2];\n    if (arg2 instanceof AbstractValue && arg2.args.length === 3)\n      arg2 = this.specializeJoin(arg2, propName);\n    return this.$Realm.createAbstract(absVal.types, absVal.values,\n      [cond, arg1, arg2], absVal._buildNode);\n  }\n\n  specializeCond(absVal: AbstractValue, propName: Value): AbstractValue {\n    if (absVal.kind === \"template for property name condition\")\n      return this.$Realm.createAbstract(absVal.types, absVal.values,\n        [absVal.args[0], propName], absVal._buildNode);\n    return absVal;\n  }\n\n  // ECMA262 9.1.9\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    // 1. Return ? OrdinarySet(O, P, V, Receiver).\n    return OrdinarySet(this.$Realm, this, P, V, Receiver);\n  }\n\n  $SetPartial(P: AbstractValue | PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    if (!(P instanceof AbstractValue)) return this.$Set(P, V, Receiver);\n    // We assume that simple objects have no getter/setter properties and\n    // that all properties are writable.\n    if (this !== Receiver || !this.isSimple() || P.mightNotBeString())\n      throw this.$Realm.createIntrospectionErrorThrowCompletion(\"TODO\");\n\n    let prop;\n    if (this.unknownProperty === undefined) {\n      prop = {\n        descriptor: undefined,\n        object: this,\n        key: \"\",\n      };\n      this.unknownProperty = prop;\n    } else {\n      prop = this.unknownProperty;\n    }\n    this.$Realm.recordModifiedProperty(prop);\n    let desc = prop.descriptor;\n    if (desc === undefined) {\n      let newVal = V;\n      if (!(V instanceof UndefinedValue)) {\n        // join V with undefined, using a property name test as the condition\n        let cond = this.$Realm.createAbstract(new TypesDomain(BooleanValue), ValuesDomain.topVal,\n          [P, new StringValue(this.$Realm, \"\")],\n          ([x, y]) => t.binaryExpression(\"===\", x, y), \"template for property name condition\");\n        newVal = joinValuesAsConditional(this.$Realm, cond, V, this.$Realm.intrinsics.undefined);\n      }\n      prop.descriptor = {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: newVal,\n      };\n    } else {\n      // join V with current value of this.unknownProperty. I.e. weak update.\n      let oldVal = desc.value;\n      invariant(oldVal !== undefined);\n      let newVal = oldVal;\n      if (!(V instanceof UndefinedValue)) {\n        let cond = this.$Realm.createAbstract(new TypesDomain(BooleanValue), ValuesDomain.topVal,\n          [P, new StringValue(this.$Realm, \"\")],\n          ([x, y]) => t.binaryExpression(\"===\", x, y), \"template for property name condition\");\n        newVal = joinValuesAsConditional(this.$Realm, cond, V, oldVal);\n      }\n      desc.value = newVal;\n    }\n\n    // Since we don't know the name of the property we are writing to, we also need\n    // to perform weak updates of all of the known properties.\n    for (let [key, propertyBinding] of this.properties) {\n      let oldVal = this.$Realm.intrinsics.empty;\n      if (propertyBinding.descriptor && propertyBinding.descriptor.value) {\n        oldVal = propertyBinding.descriptor.value;\n        invariant(oldVal !== undefined); // otherwise this is not simple\n      }\n      let cond = this.$Realm.createAbstract(new TypesDomain(BooleanValue), ValuesDomain.topVal,\n        [P],\n        ([x]) => t.binaryExpression(\"===\", x, t.stringLiteral(key)));\n      let newVal = joinValuesAsConditional(this.$Realm, cond, V, oldVal);\n      OrdinarySet(this.$Realm, this, key, newVal, Receiver);\n    }\n\n    return true;\n  }\n\n  // ECMA262 9.1.10\n  $Delete(P: PropertyKeyValue): boolean {\n    if (this.unknownProperty !== undefined) {\n      // TODO: generate a delete from the object\n      throw AbstractValue.createIntrospectionErrorThrowCompletion(this, P);\n    }\n\n    // 1. Return ? OrdinaryDelete(O, P).\n    return OrdinaryDelete(this.$Realm, this, P);\n  }\n\n  // ECMA262 9.1.11\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    return OrdinaryOwnPropertyKeys(this.$Realm, this);\n  }\n}\n"]}