{"version":3,"sources":["../../src/values/AbstractValue.js"],"names":["t","AbstractValue","realm","types","values","args","buildNode","kind","intrinsicName","isPartial","getType","mightBeEmpty","_buildNode","result","$Realm","realmGenerator","generator","Function","type","hasIdentifier","locations","loc","push","val","addSourceLocationsTo","names","gen","preludeGenerator","add_instrinsic","name","startsWith","undefined","add_args","derivedIds","get","indexOf","addSourceNamesTo","value","slice","valueType","isTop","includesValueOfType","includesValueNotOfType","isTypeCompatibleWith","clone","promoteEmptyToUndefined","cond","createAbstract","topVal","intrinsics","empty","x","y","binaryExpression","conditionalExpression","createIntrospectionErrorThrowCompletion","propertyName","identity","$GlobalObject","length","join","source_locations","location","$Description","message"],"mappings":"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","file":"AbstractValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeExpression, BabelNodeIdentifier, BabelNodeSourceLocation } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\n\nimport { IntrospectionThrowCompletion } from \"../completions.js\";\nimport { AbstractObjectValue, BooleanValue, ConcreteValue, NullValue, NumberValue, ObjectValue, PrimitiveValue, StringValue, SymbolValue, UndefinedValue, Value } from \"./index.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\n\nimport * as t from \"babel-types\";\n\nexport type AbstractValueBuildNodeFunction = (Array<BabelNodeExpression>) => BabelNodeExpression;\n\nexport default class AbstractValue extends Value {\n  constructor(\n      realm: Realm,\n      types: TypesDomain,\n      values: ValuesDomain,\n      args: Array<Value>,\n      buildNode: AbstractValueBuildNodeFunction | BabelNodeExpression,\n      kind?: string,\n      intrinsicName?: string) {\n    invariant(realm.isPartial);\n    super(realm, intrinsicName);\n    invariant(types.getType() !== ObjectValue || this instanceof AbstractObjectValue);\n    invariant(types.getType() !== NullValue && types.getType() !== UndefinedValue);\n    this.types = types;\n    this.values = values;\n    this.mightBeEmpty = false;\n    this._buildNode = buildNode;\n    this.args = args;\n    this.kind = kind;\n  }\n\n  clone(): AbstractValue {\n    let result = new AbstractValue(\n      this.$Realm, this.types, this.values, this.args, this._buildNode);\n    if (this.mightBeEmpty) result.mightBeEmpty = true;\n    if (this.args) result.args = this.args;\n    if (this.kind) result.kind = this.kind;\n    return result;\n  }\n\n  getType() {\n    return this.types.getType();\n  }\n\n  getGenerator() {\n    let realmGenerator = this.$Realm.generator;\n    invariant(realmGenerator);\n    return realmGenerator;\n  }\n\n  kind: ?string;\n  types: TypesDomain;\n  values: ValuesDomain;\n  mightBeEmpty: boolean;\n  args: Array<Value>;\n  _buildNode: AbstractValueBuildNodeFunction | BabelNodeExpression;\n\n  buildNode(args: Array<BabelNodeExpression>): BabelNodeExpression {\n    return this._buildNode instanceof Function\n      ? ((this._buildNode: any): AbstractValueBuildNodeFunction)(args)\n      : ((this._buildNode: any): BabelNodeExpression);\n  }\n\n  hasIdentifier() {\n    return this._buildNode.type === \"Identifier\";\n  }\n\n  getIdentifier() {\n    invariant(this.hasIdentifier());\n    return ((this._buildNode: any): BabelNodeIdentifier);\n  }\n\n  addSourceLocationsTo(locations: Array<BabelNodeSourceLocation>) {\n    if (!(this._buildNode instanceof Function)) {\n      if (this._buildNode.loc) locations.push(this._buildNode.loc);\n    }\n    for (let val of this.args) {\n      if (val instanceof AbstractValue) val.addSourceLocationsTo(locations);\n    }\n  }\n\n  addSourceNamesTo(names: Array<string>) {\n    let gen = this.$Realm.preludeGenerator;\n    function add_instrinsic(name: string) {\n      if (name.startsWith(\"_$\")) {\n        if (gen === undefined) return;\n        add_args(gen.derivedIds.get(name));\n      } else if (names.indexOf(name) < 0) {\n        names.push(name);\n      }\n    }\n    function add_args(args: void | Array<Value>) {\n      if (args === undefined) return;\n      for (let val of args) {\n        if (val.intrinsicName) {\n          add_instrinsic(val.intrinsicName);\n        } else if (val instanceof AbstractValue) {\n          val.addSourceNamesTo(names);\n        } else if (val instanceof StringValue) {\n          if (val.value.startsWith(\"__\")) {\n            names.push(val.value.slice(2));\n          }\n        }\n      }\n    }\n    if (this.intrinsicName) {\n      add_instrinsic(this.intrinsicName);\n    }\n    add_args(this.args);\n  }\n\n  mightBeNumber(): boolean {\n    let valueType = this.getType();\n    if (valueType === NumberValue) return true;\n    if (valueType !== Value) return false;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueOfType(NumberValue);\n  }\n\n  mightNotBeNumber(): boolean {\n    let valueType = this.getType();\n    if (valueType === NumberValue) return false;\n    if (valueType !== Value) return true;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueNotOfType(NumberValue);\n  }\n\n  mightNotBeObject(): boolean {\n    let valueType = this.getType();\n    if (Value.isTypeCompatibleWith(valueType, PrimitiveValue)) return true;\n    if (Value.isTypeCompatibleWith(valueType, ObjectValue)) return false;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueNotOfType(ObjectValue);\n  }\n\n  mightBeObject(): boolean {\n    let valueType = this.getType();\n    if (Value.isTypeCompatibleWith(valueType, PrimitiveValue)) return false;\n    if (Value.isTypeCompatibleWith(valueType, ObjectValue)) return true;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueOfType(ObjectValue);\n  }\n\n  mightNotBeString(): boolean {\n    let valueType = this.getType();\n    if (valueType === StringValue) return false;\n    if (valueType !== Value) return true;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueNotOfType(StringValue);\n  }\n\n  mightBeUndefined(): boolean {\n    let valueType = this.getType();\n    if (valueType === UndefinedValue) return true;\n    if (valueType !== Value) return false;\n    if (this.values.isTop()) return true;\n    return this.values.includesValueOfType(UndefinedValue);\n  }\n\n  mightHaveBeenDeleted(): boolean {\n    return this.mightBeEmpty;\n  }\n\n  promoteEmptyToUndefined(): Value {\n    if (this.values.isTop()) return this;\n    if (!this.mightBeEmpty) return this;\n    let result = this.clone();\n    result.mightBeEmpty = false;\n    result.values = result.values.promoteEmptyToUndefined();\n    let cond = this.$Realm.createAbstract(new TypesDomain(BooleanValue), ValuesDomain.topVal,\n      [this, this.$Realm.intrinsics.empty],\n      ([x, y]) => t.binaryExpression(\"===\", x, y));\n    result.args = [cond, this.$Realm.intrinsics.undefined, this];\n    result._buildNode = (args) => t.conditionalExpression(args[0], args[1], args[2]);\n    return result;\n  }\n\n  throwIfNotConcrete(): ConcreteValue {\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(this);\n  }\n\n  throwIfNotConcreteNumber(): NumberValue {\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(this);\n  }\n\n  throwIfNotConcreteObject(): ObjectValue {\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(this);\n  }\n\n  throwIfNotObject(): AbstractObjectValue {\n    invariant(!(this instanceof AbstractObjectValue));\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(this);\n  }\n\n  static createIntrospectionErrorThrowCompletion(val: Value, propertyName: void | PropertyKeyValue): IntrospectionThrowCompletion {\n    let realm = val.$Realm;\n\n    let identity;\n    if (val === realm.$GlobalObject)\n      identity = \"global\";\n    else if (val instanceof AbstractValue) {\n      let names = [];\n      val.addSourceNamesTo(names);\n      if (names.length === 0) {\n        val.addSourceNamesTo(names);\n      }\n      identity = `abstract value${names.length > 1 ? 's' : ''} ${names.join(\" and \")}`;\n    } else\n      identity = val.intrinsicName || \"(some value)\";\n\n    let source_locations = [];\n    if (val instanceof AbstractValue)\n      val.addSourceLocationsTo(source_locations);\n\n    let location;\n    if (propertyName instanceof SymbolValue) location = `at symbol [${propertyName.$Description || \"(no description)\"}]`;\n    else if (propertyName instanceof StringValue) location = `at ${propertyName.value}`;\n    else if (typeof propertyName === \"string\") location = `at ${propertyName}`;\n    else location = source_locations.length === 0 ? \"\" : `at ${source_locations.join(\"\\n\")}`;\n\n    let message = `This operation is not yet supported on ${identity} ${location}`;\n\n    return realm.createIntrospectionErrorThrowCompletion(message);\n  }\n\n}\n"]}