{"version":3,"sources":["../../src/utils/parse.js"],"names":["realm","code","filename","sourceType","startLine","ast","cheap","node","loc","source","e","SyntaxError","referenceErrors","error","some","msg","message","indexOf","intrinsics","ReferenceError","$ErrorData","locationData","sourceCode","stackDecorated"],"mappings":";;;;;;kBAqBe,UAAUA,KAAV,EAAwBC,IAAxB,EAAsCC,QAAtC,EAAiI;AAAA,MAAzEC,UAAyE,uEAAhD,QAAgD;AAAA,MAAtCC,SAAsC,uEAAlB,CAAkB;;AAC9I,MAAI;AACF,QAAIC,MAAM,oBAAMJ,IAAN,EAAY,EAAEC,kBAAF,EAAYC,sBAAZ,EAAwBC,oBAAxB,EAAZ,CAAV;AACA,4BAASE,KAAT,CAAeD,GAAf,EAAoB,UAACE,IAAD,EAAU;AAC5BA,WAAKC,GAAL,CAASC,MAAT,GAAkBP,QAAlB;AACD,KAFD;AAGA,WAAOG,GAAP;AACD,GAND,CAME,OAAOK,CAAP,EAAU;AACV,QAAIA,aAAaC,WAAjB,EAA8B;AAC5B;AACA;AACA,UAAIC,kBAAkB,CACpB,6CADoB,EAEpB,4CAFoB,EAGpB,iDAHoB,CAAtB;;AAMA,UAAIC,cAAJ;AACA,UAAID,gBAAgBE,IAAhB,CAAqB,UAACC,GAAD;AAAA,eAASL,EAAEM,OAAF,CAAUC,OAAV,CAAkBF,GAAlB,KAA0B,CAAnC;AAAA,OAArB,CAAJ,EAAgE;AAC9DF,gBAAQ,0BAAUb,KAAV,EAAiBA,MAAMkB,UAAN,CAAiBC,cAAlC,EAAkD,CAAC,uBAAgBnB,KAAhB,EAAuBU,EAAEM,OAAzB,CAAD,CAAlD,CAAR;AACD,OAFD,MAEO;AACLH,gBAAQ,0BAAUb,KAAV,EAAiBA,MAAMkB,UAAN,CAAiBP,WAAlC,EAA+C,CAAC,uBAAgBX,KAAhB,EAAuBU,EAAEM,OAAzB,CAAD,CAA/C,CAAR;AACD;AACD;AACA;AACA;AACA,+BAAUH,MAAMO,UAAhB;AACAP,YAAMO,UAAN,CAAiBC,YAAjB,GAAgC;AAC9BnB,kBAAUA,QADoB;AAE9BoB,oBAAYrB,IAFkB;AAG9BO,aAAKE,EAAEF,GAHuB;AAI9Be,wBAAgB;AAJc,OAAhC;AAMA,YAAM,iCAAoBV,KAApB,CAAN;AACD,KA1BD,MA0BO;AACL,YAAMH,CAAN;AACD;AACF;AACF,C;;AAhDD;;;;AAGA;;AACA;;AACA;;AACA;;;;AACA","file":"parse.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport invariant from \"../invariant.js\";\nimport type { SourceType } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { ThrowCompletion } from \"../completions.js\";\nimport { StringValue } from \"../values/index.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport traverse from \"babel-traverse\";\nimport { parse } from \"babylon\";\nimport type { BabelNodeFile } from \"babel-types\";\n\nexport default function (realm: Realm, code: string, filename: string, sourceType: SourceType = \"script\", startLine: number = 1): BabelNodeFile {\n  try {\n    let ast = parse(code, { filename, sourceType, startLine });\n    traverse.cheap(ast, (node) => {\n      node.loc.source = filename;\n    });\n    return ast;\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Babel reports all errors as syntax errors, even if a SyntaxError should be thrown.\n      // What we do here is a totally robust way to address that issue.\n      let referenceErrors = [\n        'Invalid left-hand side in postfix operation',\n        'Invalid left-hand side in prefix operation',\n        'Invalid left-hand side in assignment expression',\n      ];\n\n      let error;\n      if (referenceErrors.some((msg) => e.message.indexOf(msg) >= 0)) {\n        error = Construct(realm, realm.intrinsics.ReferenceError, [new StringValue(realm, e.message)]);\n      } else {\n        error = Construct(realm, realm.intrinsics.SyntaxError, [new StringValue(realm, e.message)]);\n      }\n      // These constructors are currently guaranteed to produce an object with\n      // built-in error data. Append location information about the syntax error\n      // and the source code to it so that we can use it to print nicer errors.\n      invariant(error.$ErrorData);\n      error.$ErrorData.locationData = {\n        filename: filename,\n        sourceCode: code,\n        loc: e.loc,\n        stackDecorated: false\n      };\n      throw new ThrowCompletion(error);\n    } else {\n      throw e;\n    }\n  }\n}\n"]}