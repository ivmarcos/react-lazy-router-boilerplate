{"version":3,"sources":["../src/realm.js"],"names":["construct_empty_effects","t","Tracer","effects","F","thisArgument","argumentsList","newTarget","performCall","result","ExecutionContext","context","caller","function","loc","realm","value","oldReadOnly","isReadOnly","variableEnvironment","environmentRecord","lexicalEnvironment","intrinsics","undefined","empty","Map","Set","Realm","opts","contextStack","MOBILE_JSC_VERSION","isPartial","partial","mathRandomSeed","mathRandomGenerator","strictlyMonotonicDateNow","timeout","timeoutCounter","timeoutCounterThreshold","start","Date","now","compatibility","$TemplateMap","preludeGenerator","debugNames","uniqueSuffix","setupTrackedPropertyAccessors","tracers","$GlobalObject","evaluators","Object","create","$GlobalEnv","key","globrec","dclrec","$DeclarativeRecord","HasBinding","GetBindingValue","readOnlyValue","forEach","ctx","setReadOnly","total","Error","length","push","c","pop","ast","strictCode","env","partially_evaluate","evaluateCompletion","f","getAndResetModifiedMaps","savedBindings","savedProperties","saved_generator","generator","saved_createdObjects","createdObjects","t1","beginPartialEvaluation","modifiedBindings","modifiedProperties","astGenerator","astBindings","astProperties","astCreatedObjects","restoreBindings","restoreProperties","t2","endPartialEvaluation","getRunningContext","savedEffects","v","g","b","p","o","leadingComment","completion","bindings","properties","appendGenerator","realmModifiedBindings","val","m","has","set","realmModifiedProperties","desc","propertyBinding","size","realmCreatedObjects","ob","a","add","msg","createIntrospectionErrorThrowCompletion","reason","method","args","createReadOnlyError","emitConsoleLog","console","getString","values","res","next","shift","nextString","binding","isNewObject","object","descriptor","getElements","some","element","d","types","buildNode","kind","intrinsicName","Constructor","getType","propertyValue","path","isIntrinsic","_buildNode","node","memberExpression","identifier","rebuildNestedProperties","abstractValue","template","getTemplate","rebuildObjectProperty","derive","nextContextLocation","setLocation","message","currentLocation","__IntrospectionError","type","realmGenerator","realmGeneratorBody","body","generatorBody","i","firstEntry","nodes","n","leadingComments","declaresDerivedId"],"mappings":"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","file":"realm.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { RealmOptions, Intrinsics, Compatibility, PropertyBinding, Descriptor } from \"./types.js\";\nimport type { NativeFunctionValue, FunctionValue } from \"./values/index.js\";\nimport { Value, ObjectValue, AbstractValue, AbstractObjectValue, StringValue, ConcreteValue } from \"./values/index.js\";\nimport { TypesDomain, ValuesDomain } from \"./domains/index.js\";\nimport { LexicalEnvironment, Reference, GlobalEnvironmentRecord } from \"./environment.js\";\nimport type { Binding } from \"./environment.js\";\nimport { cloneDescriptor, GetValue, Construct, ThrowIfMightHaveBeenDeleted } from \"./methods/index.js\";\nimport type { NormalCompletion } from \"./completions.js\";\nimport { Completion, IntrospectionThrowCompletion, ThrowCompletion, AbruptCompletion } from \"./completions.js\";\nimport invariant from \"./invariant.js\";\nimport seedrandom from \"seedrandom\";\nimport { Generator, PreludeGenerator } from \"./utils/generator.js\";\nimport type { BabelNode, BabelNodeSourceLocation, BabelNodeExpression } from \"babel-types\";\nimport type { EnvironmentRecord } from \"./environment.js\";\nimport * as t from \"babel-types\";\nimport { ToString } from \"./methods/to.js\";\n\nexport type Bindings = Map<Binding, void | Value>;\nexport type EvaluationResult = Completion | Reference | Value;\nexport type PropertyBindings = Map<PropertyBinding, void | Descriptor>;\n\nexport type CreatedObjects = Set<ObjectValue | AbstractObjectValue>;\nexport type Effects = [EvaluationResult, Generator, Bindings, PropertyBindings, CreatedObjects];\n\nexport class Tracer {\n  beginPartialEvaluation() {}\n  endPartialEvaluation(effects: void | Effects) {}\n  detourCall(F: FunctionValue, thisArgument: void | Value, argumentsList: Array<Value>, newTarget: void | ObjectValue, performCall: () => Value): void | Value {}\n  beforeCall(F: FunctionValue, thisArgument: void | Value, argumentsList: Array<Value>, newTarget: void | ObjectValue) {}\n  afterCall(F: FunctionValue, thisArgument: void | Value, argumentsList: Array<Value>, newTarget: void | ObjectValue, result: void | Reference | Value | AbruptCompletion) {}\n}\n\nexport class ExecutionContext {\n  function: ?FunctionValue;\n  caller: ?ExecutionContext;\n  loc: ?BabelNodeSourceLocation;\n  ScriptOrModule: any;\n  realm: Realm;\n  variableEnvironment: LexicalEnvironment;\n  lexicalEnvironment: LexicalEnvironment;\n  isReadOnly: boolean;\n  savedEffects: void | Effects;\n\n  setCaller(context: ExecutionContext): void {\n    this.caller = context;\n  }\n\n  setFunction(F: null | FunctionValue) {\n    this.function = F;\n  }\n\n  setLocation(loc: null | BabelNodeSourceLocation) {\n    if (!loc) return;\n    this.loc = loc;\n  }\n\n  setRealm(realm: Realm): void {\n    this.realm = realm;\n  }\n\n  /*\n   Read-only envs disallow:\n   - creating bindings in their scope\n   - creating or modifying objects when they are current running context\n  */\n  setReadOnly(value: boolean): boolean {\n    let oldReadOnly = this.isReadOnly;\n    if (this.variableEnvironment) this.variableEnvironment.environmentRecord.isReadOnly = value;\n    if (this.lexicalEnvironment) this.lexicalEnvironment.environmentRecord.isReadOnly = value;\n    this.isReadOnly = value;\n    return oldReadOnly;\n  }\n\n  suspend(): void {\n    // TODO: suspend\n  }\n\n  resume(): Value {\n    // TODO: resume\n    return this.realm.intrinsics.undefined;\n  }\n}\n\nexport function construct_empty_effects(realm: Realm): Effects {\n  return [realm.intrinsics.empty, new Generator(realm), new Map(), new Map(), new Set()];\n}\n\nexport class Realm {\n  constructor(opts: RealmOptions) {\n    this.isReadOnly = false;\n    this.isPartial  = !!opts.partial;\n    if (opts.mathRandomSeed !== undefined) {\n      this.mathRandomGenerator = seedrandom(opts.mathRandomSeed);\n    }\n    this.strictlyMonotonicDateNow = !!opts.strictlyMonotonicDateNow;\n\n    this.timeout = opts.timeout;\n    if (this.timeout) {\n      // We'll call Date.now for every this.timeoutCounterThreshold'th AST node.\n      // The threshold is there to reduce the cost of the surprisingly expensive Date.now call.\n      this.timeoutCounter = this.timeoutCounterThreshold = 1024;\n    }\n\n    this.start = Date.now();\n    this.compatibility = opts.compatibility || \"browser\";\n\n\n    this.$TemplateMap  = [];\n\n    if (this.isPartial) {\n      this.preludeGenerator = new PreludeGenerator(opts.debugNames, opts.uniqueSuffix);\n      ObjectValue.setupTrackedPropertyAccessors();\n    }\n\n    this.tracers = [];\n\n    // These get initialized in construct_realm to avoid the dependency\n    this.intrinsics = ({}: any);\n    this.$GlobalObject = (({}: any): ObjectValue);\n    this.evaluators = (Object.create(null): any);\n    this.$GlobalEnv = ((undefined: any): LexicalEnvironment);\n  }\n\n  start: number;\n  isReadOnly: boolean;\n  isPartial: boolean;\n  timeout: void | number;\n  mathRandomGenerator: void | () => number;\n  strictlyMonotonicDateNow: boolean;\n\n  modifiedBindings: void | Bindings;\n  modifiedProperties: void | PropertyBindings;\n\n  createdObjects: void | CreatedObjects;\n\n  currentLocation: ?BabelNodeSourceLocation;\n  nextContextLocation: ?BabelNodeSourceLocation;\n  contextStack: Array<ExecutionContext> = [];\n  $GlobalEnv: LexicalEnvironment;\n  intrinsics: Intrinsics;\n\n  $GlobalObject: ObjectValue | AbstractObjectValue;\n  compatibility: Compatibility;\n\n  $TemplateMap: Array<{$Strings: Array<string>, $Array: ObjectValue}>;\n\n  generator: void | Generator;\n  preludeGenerator: void | PreludeGenerator;\n  timeoutCounter: number;\n  timeoutCounterThreshold: number;\n  evaluators: { [key: string]: (ast: BabelNode, strictCode: boolean, env: LexicalEnvironment, realm: Realm, metadata?: any) => NormalCompletion | Value | Reference };\n\n  tracers: Array<Tracer>;\n\n  MOBILE_JSC_VERSION = \"jsc-600-1-4-17\";\n\n  // to force flow to type the annotations\n  isCompatibleWith(compatibility: Compatibility): boolean {\n    return compatibility === this.compatibility;\n  }\n\n  // Checks if there is a let binding at global scope with the given name\n  // returning it if so\n  getGlobalLetBinding(key: string): void | Value {\n    let globrec = this.$GlobalEnv.environmentRecord;\n    // GlobalEnv should have a GlobalEnvironmentRecord\n    invariant(globrec instanceof GlobalEnvironmentRecord);\n    let dclrec = globrec.$DeclarativeRecord;\n\n    return dclrec.HasBinding(key) ? dclrec.GetBindingValue(key, false) : undefined;\n  }\n\n  /*\n   Read only realms disallow:\n   - using console.log\n   - creating bindings in any existing scopes\n   - modifying object properties in any existing scopes\n   Setting a realm read-only sets all contained environments to read-only, but\n   all new environments (e.g. new ExecutionContexts) will be writeable.\n   */\n  setReadOnly(readOnlyValue: boolean) {\n    this.isReadOnly = readOnlyValue;\n    this.$GlobalEnv.environmentRecord.isReadOnly = readOnlyValue;\n    this.contextStack.forEach((ctx) => {\n      ctx.setReadOnly(readOnlyValue);\n    });\n  }\n\n  testTimeout() {\n    let timeout = this.timeout;\n    if (timeout && !--this.timeoutCounter) {\n      this.timeoutCounter = this.timeoutCounterThreshold;\n      let total = Date.now() - this.start;\n      if (total > timeout) {\n        throw new Error(\"Timed out\");\n      }\n    }\n  }\n\n  getRunningContext(): ExecutionContext {\n    let context = this.contextStack[this.contextStack.length - 1];\n    invariant(context, \"There's no running execution context\");\n    return context;\n  }\n\n  pushContext(context: ExecutionContext): void {\n    this.contextStack.push(context);\n  }\n\n  popContext(context: ExecutionContext): void {\n    let c = this.contextStack.pop();\n    invariant(c === context);\n  }\n\n  // Evaluate the given ast in a sandbox and return the evaluation results\n  // in the form a completion, a code generator, a map of changed variable\n  // bindings and a map of changed property bindings.\n  partially_evaluate_node(ast: BabelNode, strictCode: boolean, env: LexicalEnvironment): Effects {\n    return this.partially_evaluate(() => env.evaluateCompletion(ast, strictCode));\n  }\n\n  partially_evaluate(f: () => Completion | Value | Reference): Effects {\n    // Save old state and set up empty state for ast\n    let [savedBindings, savedProperties] = this.getAndResetModifiedMaps();\n    let saved_generator = this.generator;\n    let saved_createdObjects = this.createdObjects;\n    this.generator = new Generator(this);\n    this.createdObjects = new Set();\n\n    for (let t1 of this.tracers) t1.beginPartialEvaluation();\n\n    let c;\n    let result;\n    try {\n      c = f();\n      if (c instanceof Reference) c = GetValue(this, c);\n\n      invariant(this.generator !== undefined);\n      invariant(this.modifiedBindings !== undefined);\n      invariant(this.modifiedProperties !== undefined);\n      invariant(this.createdObjects !== undefined);\n      let astGenerator = this.generator;\n      let astBindings = this.modifiedBindings;\n      let astProperties = this.modifiedProperties;\n      let astCreatedObjects = this.createdObjects;\n\n      // Return the captured state changes and evaluation result\n      result = [c, astGenerator, astBindings, astProperties, astCreatedObjects];\n      return result;\n    } finally {\n      // Roll back the state changes\n      this.restoreBindings(this.modifiedBindings);\n      this.restoreProperties(this.modifiedProperties);\n      this.generator = saved_generator;\n      this.modifiedBindings = savedBindings;\n      this.modifiedProperties = savedProperties;\n      this.createdObjects = saved_createdObjects;\n\n      for (let t2 of this.tracers) t2.endPartialEvaluation(result);\n    }\n  }\n\n  capture_effects() {\n    let context = this.getRunningContext();\n    if (context.savedEffects !== undefined) {\n      // Already called capture_effects in this context, just carry on\n      return;\n    }\n    context.savedEffects = [this.intrinsics.undefined, this.generator,\n      this.modifiedBindings, this.modifiedProperties, this.createdObjects];\n    this.generator = new Generator(this);\n    this.modifiedBindings = new Map();\n    this.modifiedProperties = new Map();\n    this.createdObjects = new Set();\n  }\n\n  get_captured_effects(v?: Value): void | Effects {\n    let context = this.getRunningContext();\n    if (context.savedEffects === undefined) return undefined;\n    if (v === undefined) v = this.intrinsics.undefined;\n    invariant(this.generator !== undefined);\n    invariant(this.modifiedBindings !== undefined);\n    invariant(this.modifiedProperties !== undefined);\n    invariant(this.createdObjects !== undefined);\n    return [v, this.generator, this.modifiedBindings,\n       this.modifiedProperties, this.createdObjects];\n  }\n\n  stop_effect_capture() {\n    let context = this.getRunningContext();\n    if (context.savedEffects !== undefined) {\n      let [c, g, b, p, o] = context.savedEffects;\n      c;\n      context.savedEffects = undefined;\n      this.generator = g;\n      this.modifiedBindings = b;\n      this.modifiedProperties = p;\n      this.createdObjects = o;\n    }\n  }\n\n  // Apply the given effects to the global state\n  apply_effects(effects: Effects, leadingComment: string = \"\") {\n    let [completion, generator, bindings, properties, createdObjects] = effects;\n\n    // ignore completion\n    completion;\n\n    // Add generated code for property modifications\n    this.appendGenerator(generator, leadingComment);\n\n    // Restore bindings\n    this.restoreBindings(bindings);\n    this.restoreProperties(properties);\n\n    // track bindings\n    let realmModifiedBindings = this.modifiedBindings;\n    if (realmModifiedBindings !== undefined) {\n      bindings.forEach((val, key, m) => {\n        invariant(realmModifiedBindings !== undefined);\n        if (!realmModifiedBindings.has(key)) {\n          realmModifiedBindings.set(key, val);\n        }\n      });\n    }\n    let realmModifiedProperties = this.modifiedProperties;\n    if (realmModifiedProperties !== undefined) {\n      properties.forEach((desc, propertyBinding, m) => {\n        invariant(realmModifiedProperties !== undefined);\n        if (!realmModifiedProperties.has(propertyBinding)) {\n          realmModifiedProperties.set(propertyBinding, desc);\n        }\n      });\n    }\n\n    // add created objects\n    if (createdObjects.size > 0) {\n      let realmCreatedObjects = this.createdObjects;\n      if (realmCreatedObjects === undefined)\n        this.createdObjects = new Set(createdObjects);\n      else {\n        createdObjects.forEach((ob, a) => {\n          invariant(realmCreatedObjects !== undefined);\n          realmCreatedObjects.add(ob);\n        });\n      }\n    }\n  }\n\n  createReadOnlyError(msg: string): IntrospectionThrowCompletion {\n    let completion = this.createIntrospectionErrorThrowCompletion(msg);\n    completion.reason = \"readonly\";\n    return completion;\n  }\n\n  outputToConsole(method: \"log\" | \"warn\" | \"error\", args: Array<string | ConcreteValue>): void {\n    if (this.isReadOnly)\n      throw this.createReadOnlyError(\"Trying to create console output in read-only realm\");\n    if (this.isPartial) {\n      invariant(this.generator !== undefined);\n      this.generator.emitConsoleLog(method, args);\n    } else {\n      console[method](getString(this, args));\n    }\n\n    function getString(realm: Realm, values: Array<string | ConcreteValue>) {\n      let res = \"\";\n      while (values.length) {\n        let next = values.shift();\n        let nextString = ToString(realm, next);\n        res += nextString;\n      }\n      return res;\n    }\n  }\n\n  // Record the current value of binding in this.modifiedBindings unless\n  // there is already an entry for binding.\n  recordModifiedBinding(binding: Binding, env: EnvironmentRecord): Binding {\n    if (env.isReadOnly)\n      throw this.createReadOnlyError(\"Trying to modify a binding in read-only realm\");\n    if (this.modifiedBindings !== undefined && !this.modifiedBindings.has(binding))\n      this.modifiedBindings.set(binding, binding.value);\n    return binding;\n  }\n\n  // Record the current value of binding in this.modifiedProperties unless\n  // there is already an entry for binding.\n  recordModifiedProperty(binding: PropertyBinding): void {\n    if (this.isReadOnly && (this.getRunningContext().isReadOnly || !this.isNewObject(binding.object))) {\n      throw this.createReadOnlyError(\"Trying to modify a property in read-only realm\");\n    }\n    if (this.modifiedProperties !== undefined && !this.modifiedProperties.has(binding)) {\n      this.modifiedProperties.set(binding, cloneDescriptor(binding.descriptor));\n    }\n  }\n\n  isNewObject(object: AbstractObjectValue | ObjectValue): boolean {\n    if (object instanceof AbstractObjectValue) {\n      let realm = this;\n      return object.values.getElements().some(element => realm.isNewObject(element));\n    }\n    return this.createdObjects === undefined || this.createdObjects.has(object);\n  }\n\n  recordNewObject(object: ObjectValue): void {\n    if (this.createdObjects !== undefined) {\n      this.createdObjects.add(object);\n    }\n  }\n\n  // Returns the current values of modifiedBindings and modifiedProperties\n  // and then assigns new empty maps to them.\n  getAndResetModifiedMaps(): [void | Bindings, void | PropertyBindings] {\n    let result = [this.modifiedBindings, this.modifiedProperties];\n    this.modifiedBindings = new Map();\n    this.modifiedProperties = new Map();\n    return result;\n  }\n\n  // Restores each Binding in the given map to the value it\n  // had when it was entered into the map and updates the map to record\n  // the value the Binding had just before the call to this method.\n  restoreBindings(modifiedBindings: void | Bindings) {\n    if (modifiedBindings === undefined) return;\n    modifiedBindings.forEach((val, key, m) => {\n      let v = key.value;\n      key.value = val;\n      m.set(key, v);\n    });\n  }\n\n  // Restores each PropertyBinding in the given map to the value it\n  // had when it was entered into the map and updates the map to record\n  // the value the Binding had just before the call to this method.\n  restoreProperties(modifiedProperties: void | PropertyBindings) {\n    if (modifiedProperties === undefined) return;\n    modifiedProperties.forEach(\n      (desc, propertyBinding, m) => {\n        let d = propertyBinding.descriptor;\n        propertyBinding.descriptor = desc;\n        m.set(propertyBinding, d);\n      });\n  }\n\n  // Provide the realm with maps in which to track modifications.\n  // A map can be set to undefined if no tracking is required.\n  setModifiedMaps(modifiedBindings: void | Bindings,\n      modifiedProperties: void | PropertyBindings) {\n    this.modifiedBindings = modifiedBindings;\n    this.modifiedProperties = modifiedProperties;\n  }\n\n  // Create a state-less abstract value.\n  // NOTE: `buildNode` MUST NOT create an AST which may mutate or access mutable state! Use `deriveAbstract` for that purpose.\n  createAbstract(types: TypesDomain, values: ValuesDomain, args: Array<Value>, buildNode: (Array<BabelNodeExpression> => BabelNodeExpression) | BabelNodeExpression, kind?: string, intrinsicName?: string) {\n    invariant(this.isPartial);\n    let Constructor = types.getType() === ObjectValue ? AbstractObjectValue : AbstractValue;\n    return new Constructor(this, types, values, args, buildNode, kind, intrinsicName);\n  }\n\n  rebuildObjectProperty(object: Value, key: string, propertyValue: Value, path: string) {\n    if (!(propertyValue instanceof AbstractValue)) return;\n    if (!propertyValue.isIntrinsic()) {\n      propertyValue.intrinsicName = `${path}.${key}`;\n      propertyValue.args = [object];\n      propertyValue._buildNode = ([node]) => t.memberExpression(node, t.identifier(key));\n      this.rebuildNestedProperties(propertyValue, propertyValue.intrinsicName);\n    }\n  }\n\n  rebuildNestedProperties(abstractValue: AbstractValue, path: string) {\n    if (!(abstractValue instanceof AbstractObjectValue)) return;\n    let template = abstractValue.getTemplate();\n    invariant(!template.intrinsicName || template.intrinsicName === path);\n    template.intrinsicName = path;\n    for (let [key, binding] of template.properties) {\n      if (binding === undefined || binding.descriptor === undefined) continue; // deleted\n      invariant(binding.descriptor !== undefined);\n      let value = binding.descriptor.value;\n      ThrowIfMightHaveBeenDeleted(value);\n      if (value === undefined) throw AbstractValue.createIntrospectionErrorThrowCompletion(abstractValue, key);\n      this.rebuildObjectProperty(abstractValue, key, value, path);\n    }\n  }\n\n  // Create a an abstract value in a way that may observe or mutate state.\n  // NOTE: If the state that is observed or mutated by the AST generated by `buildNode` is also represented in some form in the interpreter,\n  // i.e. not just external state, then the caller must make sure that all relevant interpreter state is updated correspondingly.\n  deriveAbstract(types: TypesDomain, values: ValuesDomain, args: Array<Value>, buildNode: (Array<BabelNodeExpression> => BabelNodeExpression) | BabelNodeExpression, kind?: string): AbstractValue {\n    invariant(this.isPartial);\n    let generator = this.generator;\n    invariant(generator);\n    return generator.derive(types, values, args, buildNode, kind);\n  }\n\n  createExecutionContext(): ExecutionContext {\n    let context = new ExecutionContext();\n\n    let loc = this.nextContextLocation;\n    if (loc) {\n      context.setLocation(loc);\n      this.nextContextLocation = null;\n    }\n\n    return context;\n  }\n\n  setNextExecutionContextLocation(loc: ?BabelNodeSourceLocation) {\n    if (!loc) return;\n\n    //if (this.nextContextLocation) {\n    //  throw new ThrowCompletion(\n    //    Construct(this, this.intrinsics.TypeError, [new StringValue(this, \"Already have a context location that we haven't used yet\")])\n    //  );\n    //} else {\n    this.nextContextLocation = loc;\n    //}\n  }\n\n  createIntrospectionErrorThrowCompletion(message?: void | string | StringValue): IntrospectionThrowCompletion {\n    if (message === undefined) message = \"TODO\";\n    if (typeof message === \"string\") message = new StringValue(this, message);\n    invariant(message instanceof StringValue);\n    this.nextContextLocation = this.currentLocation;\n    return new IntrospectionThrowCompletion(Construct(this, this.intrinsics.__IntrospectionError, [message]));\n  }\n\n  createErrorThrowCompletion(type: NativeFunctionValue, message?: void | string | StringValue): ThrowCompletion {\n    invariant(type !== this.intrinsics.__IntrospectionError);\n    if (message === undefined) message = \"TODO\";\n    if (typeof message === \"string\") message = new StringValue(this, message);\n    invariant(message instanceof StringValue);\n    this.nextContextLocation = this.currentLocation;\n    return new ThrowCompletion(Construct(this, type, [message]));\n  }\n\n  appendGenerator(generator: Generator, leadingComment: string = \"\"): void {\n    let realmGenerator = this.generator;\n    invariant(realmGenerator);\n    let realmGeneratorBody = realmGenerator.body;\n    let generatorBody = generator.body;\n    let i = 0;\n    if (generatorBody.length > 0 && leadingComment.length > 0) {\n      let firstEntry = generatorBody[i++];\n      let buildNode = (nodes, f) => {\n        let n = firstEntry.buildNode(nodes, f);\n        n.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n        return n;\n      };\n      realmGeneratorBody.push({ declaresDerivedId: firstEntry.declaresDerivedId, args: firstEntry.args, buildNode: buildNode });\n    }\n    for (; i < generatorBody.length; i++) realmGeneratorBody.push(generatorBody[i]);\n  }\n}\n"]}