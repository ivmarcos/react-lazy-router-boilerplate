{"version":3,"sources":["../../src/evaluators/AssignmentExpression.js"],"names":["ast","strictCode","env","realm","hasOwnProperty","operator","Error","LeftHandSideExpression","left","AssignmentExpression","right","AssignmentOperator","type","lref","evaluate","rref","rval","hasNameProperty","lval","op","slice","r"],"mappings":";;;;;;kBAuBe,UAAUA,GAAV,EAA8CC,UAA9C,EAAmEC,GAAnE,EAA4FC,KAA5F,EAA6H;AAC1I,MAAK,CAACH,IAAII,cAAJ,CAAmB,UAAnB,CAAF,IAAsCJ,IAAIK,QAAJ,KAAiB,IAA3D,EACE,MAAMC,MAAM,qBAAN,CAAN;;AAEF,MAAIC,yBAAyBP,IAAIQ,IAAjC;AACA,MAAIC,uBAAuBT,IAAIU,KAA/B;AACA,MAAIC,qBAAqBX,IAAIK,QAA7B;;AAEA;AACA,MAAIM,uBAAuB,GAA3B,EAA+B;AAC7B;AACA,QAAIJ,uBAAuBK,IAAvB,KAAgC,eAAhC,IAAmDL,uBAAuBK,IAAvB,KAAgC,cAAvF,EAAuG;AACrG;AACA,UAAIC,QAAOX,IAAIY,QAAJ,CAAaP,sBAAb,EAAqCN,UAArC,CAAX;AACA;AACA;AACA,UAAIc,QAAOb,IAAIY,QAAJ,CAAaL,oBAAb,EAAmCR,UAAnC,CAAX;AACA;AACA,UAAIe,QAAO,sBAASb,KAAT,EAAgBY,KAAhB,CAAX;AACA;AACA,UAAI,2CAA8BZ,KAA9B,EAAqCM,oBAArC,KACA,yBAAgBN,KAAhB,EAAuBI,sBAAvB,CADJ,EACoD;AAClD,iCAAUS,mCAAV;AACA;AACA,YAAIC,kBAAkB,4BAAed,KAAf,EAAsBa,KAAtB,EAA4B,MAA5B,CAAtB;AACA;AACA,YAAI,CAACC,eAAL,EAAqB;AACnB,mCAAUJ,uCAAV;AACA,uCAAgBV,KAAhB,EAAuBa,KAAvB,EAA6B,+BAAkBb,KAAlB,EAAyBU,KAAzB,CAA7B;AACD;AACF;AACD;AACA,4BAASV,KAAT,EAAgBU,KAAhB,EAAsBG,KAAtB;AACA;AACA,aAAOA,KAAP;AACD;AACD,UAAM,IAAIV,KAAJ,CAAU,+BAAV,CAAN;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AAED;;AAEA;AACA,MAAIO,OAAOX,IAAIY,QAAJ,CAAaP,sBAAb,EAAqCN,UAArC,CAAX;AACA;AACA,MAAIiB,OAAO,sBAASf,KAAT,EAAgBU,IAAhB,CAAX;AACA;AACA,MAAIE,OAAOb,IAAIY,QAAJ,CAAaL,oBAAb,EAAmCR,UAAnC,CAAX;AACA;AACA,MAAIe,OAAO,sBAASb,KAAT,EAAgBY,IAAhB,CAAX;AACA;AACA,MAAII,KAAQR,mBAAmBS,KAAnB,CAAyB,CAAzB,EAA4B,CAAC,CAA7B,CAAZ;AACA;AACA,MAAIC,IAAI,sBAASlB,KAAT,EAAgB,qCAAcA,KAAd,EAAqBgB,EAArB,EAAyBD,IAAzB,EAA+BF,IAA/B,CAAhB,CAAR;AACA;AACA,wBAASb,KAAT,EAAgBU,IAAhB,EAAsBQ,CAAtB;AACA;AACA,SAAOA,CAAP;AACD,C;;AAzED;;AACA;;AACA;;AAEA;;AACA;;;;AAEA","file":"AssignmentExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value, ObjectValue } from \"../values/index.js\";\nimport { GetValue } from \"../methods/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { PutValue, SetFunctionName, IsAnonymousFunctionDefinition, HasOwnProperty, GetReferencedName } from \"../methods/index.js\";\nimport { IsIdentifierRef } from \"../methods/is.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeAssignmentExpression, BabelBinaryOperator } from \"babel-types\";\nimport { computeBinary } from \"./BinaryExpression.js\";\n\n// ECMA262 12.15 Assignment Operators\nexport default function (ast: BabelNodeAssignmentExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  if ((!ast.hasOwnProperty(\"operator\")) || (ast.operator === null))\n    throw Error(\"Unexpected AST form\");\n\n  let LeftHandSideExpression = ast.left;\n  let AssignmentExpression = ast.right;\n  let AssignmentOperator = ast.operator;\n\n  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression\n  if (AssignmentOperator === \"=\"){\n    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then\n    if (LeftHandSideExpression.type !== \"ObjectLiteral\" && LeftHandSideExpression.type !== \"ArrayLiteral\") {\n      // a. Let lref be the result of evaluating LeftHandSideExpression.\n      let lref = env.evaluate(LeftHandSideExpression, strictCode);\n      // b. ReturnIfAbrupt(lref). -- Not neccessary\n      // c. Let rref be the result of evaluating AssignmentExpression.\n      let rref = env.evaluate(AssignmentExpression, strictCode);\n      // d. Let rval be ? GetValue(rref).\n      let rval = GetValue(realm, rref);\n      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then\n      if (IsAnonymousFunctionDefinition(realm, AssignmentExpression) &&\n          IsIdentifierRef(realm, LeftHandSideExpression)) {\n        invariant(rval instanceof ObjectValue);\n        // i. Let hasNameProperty be ? HasOwnProperty(rval, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, rval, \"name\");\n        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).\n        if (!hasNameProperty){\n          invariant(lref instanceof Reference);\n          SetFunctionName(realm, rval, GetReferencedName(realm, lref));\n        }\n      }\n      // f. Perform ? PutValue(lref, rval).\n      PutValue(realm, lref, rval);\n      // g. Return rval.\n      return rval;\n    }\n    throw new Error(\"Patterns aren't supported yet\");\n    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.\n    // 3. Let rref be the result of evaluating AssignmentExpression.\n    // 4. Let rval be ? GetValue(rref).\n    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.\n    // 6. ReturnIfAbrupt(status).\n    // 7. Return rval.\n  }\n\n  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression\n\n  // 1. Let lref be the result of evaluating LeftHandSideExpression.\n  let lref = env.evaluate(LeftHandSideExpression, strictCode);\n  // 2. Let lval be ? GetValue(lref).\n  let lval = GetValue(realm, lref);\n  // 3. Let rref be the result of evaluating AssignmentExpression.\n  let rref = env.evaluate(AssignmentExpression, strictCode);\n  // 4. Let rval be ? GetValue(rref).\n  let rval = GetValue(realm, rref);\n  // 5. Let op be the @ where AssignmentOperator is @=.\n  let op  = ((AssignmentOperator.slice(0, -1): any): BabelBinaryOperator);\n  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.\n  let r = GetValue(realm, computeBinary(realm, op, lval, rval));\n  // 7. Perform ? PutValue(lref, r).\n  PutValue(realm, lref, r);\n  // 8. Return r.\n  return r;\n}\n"]}