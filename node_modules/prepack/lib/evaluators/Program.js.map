{"version":3,"sources":["../../src/evaluators/Program.js"],"names":["ast","strictCode","env","realm","GlobalDeclarationInstantiation","val","body","node","type","potentialVal","evaluate","directives","length","directive","intrinsics","empty","envRec","environmentRecord","lexNames","varNames","kind","concat","name","HasVarDeclaration","createErrorThrowCompletion","SyntaxError","HasLexicalDeclaration","hasRestrictedGlobal","HasRestrictedGlobalProperty","varDeclarations","functionsToInitialize","declaredFunctionNames","reverse","d","fn","indexOf","fnDefinable","CanDeclareGlobalFunction","TypeError","push","unshift","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","lexDeclarations","s","dn","CreateImmutableBinding","CreateMutableBinding","f","fo","CreateGlobalFunctionBinding","CreateGlobalVarBinding"],"mappings":"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","file":"Program.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Reference } from \"../environment.js\";\nimport { Value, EmptyValue } from \"../values/index.js\";\nimport { GlobalEnvironmentRecord } from \"../environment.js\";\nimport { FindVarScopedDeclarations } from \"../methods/function.js\";\nimport { BoundNames } from \"../methods/index.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport invariant from \"../invariant.js\";\nimport traverse from \"../traverse.js\";\nimport type { BabelNodeProgram } from \"babel-types\";\n\n// ECMA262 15.1.11\nfunction GlobalDeclarationInstantiation(realm: Realm, ast: BabelNodeProgram, env: LexicalEnvironment, strictCode: boolean) {\n  // 1. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a global Environment Record.\n  invariant(envRec instanceof GlobalEnvironmentRecord, \"expected global environment record\");\n\n  // 3. Let lexNames be the LexicallyDeclaredNames of script.\n  let lexNames = [];\n\n  // 4. Let varNames be the VarDeclaredNames of script.\n  let varNames = [];\n\n  traverse(ast, function (node) {\n    if (node.type === \"VariableDeclaration\") {\n      if (node.kind === \"var\") {\n        varNames = varNames.concat(BoundNames(realm, node));\n      } else {\n        lexNames = lexNames.concat(BoundNames(realm, node));\n      }\n    } else if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n    return false;\n  });\n\n  // 5. For each name in lexNames, do\n  for (let name of lexNames) {\n    // a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasVarDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError,\n        name + \" already declared with var\");\n    }\n\n    // b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\");\n    }\n\n    // c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).\n    let hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(name);\n\n    // d. If hasRestrictedGlobal is true, throw a SyntaxError exception.\n    if (hasRestrictedGlobal) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError,\n        name + \" global object is restricted\");\n    }\n  }\n\n  // 6. For each name in varNames, do\n  for (let name of varNames) {\n    // a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\");\n    }\n  }\n\n  // 7. Let varDeclarations be the VarScopedDeclarations of script.\n  let varDeclarations = FindVarScopedDeclarations(ast);\n\n  // 8. Let functionsToInitialize be a new empty List.\n  let functionsToInitialize = [];\n\n  // 9. Let declaredFunctionNames be a new empty List.\n  let declaredFunctionNames = [];\n\n  // 10. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\", \"expected function\");\n\n      // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n\n      // iii. Let fn be the sole element of the BoundNames of d.\n      let fn = BoundNames(realm, d)[0];\n\n      // iv. If fn is not an element of declaredFunctionNames, then\n      if (declaredFunctionNames.indexOf(fn) < 0) {\n        // 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).\n        let fnDefinable = envRec.CanDeclareGlobalFunction(fn);\n\n        // 2. If fnDefinable is false, throw a TypeError exception.\n        if (!fnDefinable) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError,\n            fn + \": global function declarations are not allowed\");\n        }\n\n        // 3. Append fn to declaredFunctionNames.\n        declaredFunctionNames.push(fn);\n\n        // 4. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 11. Let declaredVarNames be a new empty List.\n  let declaredVarNames = [];\n\n  // 12. For each d in varDeclarations, do\n  for (let d of varDeclarations) {\n    // a. If d is a VariableDeclaration or a ForBinding, then\n    if (d.type === \"VariableDeclaration\") {\n      // i. For each String vn in the BoundNames of d, do\n      for (let vn of BoundNames(realm, d)) {\n        // ii. If vn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(vn) < 0) {\n          // 1. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).\n          let vnDefinable = envRec.CanDeclareGlobalVar(vn);\n\n          // 2. If vnDefinable is false, throw a TypeError exception.\n          if (!vnDefinable) {\n            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError,\n              vn + \": global variable declarations are not allowed\");\n          }\n\n          // 3. If vn is not an element of declaredVarNames, then\n          if (declaredVarNames.indexOf(vn) < 0) {\n            // a. Append vn to declaredVarNames.\n            declaredVarNames.push(vn);\n          }\n        }\n      }\n    }\n  }\n\n  // 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n\n  // 14. NOTE: Annex B.3.3.2 adds additional steps at this point.\n\n  // 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.\n  let lexDeclarations = [];\n  for (let s of ast.body) {\n    if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n      lexDeclarations.push(s);\n    }\n  }\n\n  // 16. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE Lexically declared names are only instantiated here but not initialized.\n\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of BoundNames(realm, d)) {\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\") {\n        // 1. Perform ? envRec.CreateImmutableBinding(dn, true).\n        envRec.CreateImmutableBinding(dn, true);\n      } else { // ii. Else,\n        // 1. Perform ? envRec.CreateMutableBinding(dn, false).\n        envRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 17. For each production f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = BoundNames(realm, f)[0];\n\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.\n    let fo = env.evaluate(f, strictCode);\n    invariant(fo instanceof Value);\n\n    // c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).\n    envRec.CreateGlobalFunctionBinding(fn, fo, false);\n  }\n\n  // 18. For each String vn in declaredVarNames, in list order do\n  for (let vn of declaredVarNames) {\n    // a. Perform ? envRec.CreateGlobalVarBinding(vn, false).\n    envRec.CreateGlobalVarBinding(vn, false);\n  }\n\n  // 19. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\nexport default function (ast: BabelNodeProgram, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  strictCode = IsStrict(ast);\n\n  GlobalDeclarationInstantiation(realm, ast, env, strictCode);\n\n  let val;\n\n  for (let node of ast.body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let potentialVal = env.evaluate(node, strictCode);\n      if (!(potentialVal instanceof EmptyValue)) val = potentialVal;\n    }\n  }\n\n  let directives = ast.directives;\n  if (!val && directives && directives.length) {\n    let directive = directives[directives.length - 1];\n    val = env.evaluate(directive, strictCode);\n  }\n\n  return val || realm.intrinsics.empty;\n}\n"]}