{"version":3,"sources":["../../src/evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","setNextExecutionContextLocation","loc","ref","evaluate","callee","func","getType","args","concat","arguments","deriveAbstract","topVal","nodes","fun_args","slice","t","callExpression","throwIfNotConcrete","intrinsics","eval","argList","length","undefined","evalText","strictCaller","evalRealm","thisValue","refEnv","WithBaseObject","thisCall","tailCall"],"mappings":";;;;;;kBAkCe,UAAUA,GAAV,EAAwCC,UAAxC,EAA6DC,GAA7D,EAAsFC,KAAtF,EAAuH;AACpI;AACAA,QAAMC,+BAAN,CAAsCJ,IAAIK,GAA1C;;AAEA;AACA,MAAIC,MAAMJ,IAAIK,QAAJ,CAAaP,IAAIQ,MAAjB,EAAyBP,UAAzB,CAAV;;AAEA;AACA,MAAIQ,OAAO,sBAASN,KAAT,EAAgBG,GAAhB,CAAX;;AAEA,MAAIG,wCAAiCA,KAAKC,OAAL,2BAArC,EAAuE;AACrE,QAAIC,OACF,CAACF,IAAD,EAAOG,MAAP,CAAc,oCAAuBT,KAAvB,EAA8BF,UAA9B,EAA0CC,GAA1C,EAAiDF,IAAIa,SAArD,CAAd,CADF;AAEA,WAAOV,MAAMW,cAAN,CACL,6CADK,EAEL,qBAAaC,MAFR,EAGLJ,IAHK,EAIL,UAACK,KAAD,EAAW;AACT,UAAIC,WAAaD,MAAME,KAAN,CAAY,CAAZ,CAAjB;AACA,aAAOC,EAAEC,cAAF,CAAiBJ,MAAM,CAAN,CAAjB,EAA2BC,QAA3B,CAAP;AACD,KAPI,CAAP;AAQD;AACDR,SAAOA,KAAKY,kBAAL,EAAP;;AAEA;AACA,MAAIf,yCAA4B,CAAC,iCAAoBH,KAApB,EAA2BG,GAA3B,CAA7B,IAAgE,+BAAkBH,KAAlB,EAAyBG,GAAzB,MAAkC,MAAtG,EAA8G;AAC5G;AACA,QAAIG,wCAAiC,uBAAUN,KAAV,EAAiBM,IAAjB,EAAuBN,MAAMmB,UAAN,CAAiBC,IAAxC,CAArC,EAAoF;AAClF;AACA,UAAIC,UAAU,oCAAuBrB,KAAvB,EAA8BF,UAA9B,EAA0CC,GAA1C,EAAiDF,IAAIa,SAArD,CAAd;AACA;AACA,UAAIW,QAAQC,MAAR,KAAmB,CAAvB,EAA0B,OAAOtB,MAAMmB,UAAN,CAAiBI,SAAxB;AAC1B;AACA,UAAIC,WAAWH,QAAQ,CAAR,CAAf;AACA;AACA,UAAII,eAAe3B,UAAnB;AACA;AACA,UAAI4B,YAAY1B,KAAhB;AACA;AACA,aAAO,2BAAYA,KAAZ,EAAmBwB,QAAnB,EAA6BE,SAA7B,EAAwCD,YAAxC,EAAsD,IAAtD,CAAP;AACD;AACF;;AAED,MAAIE,kBAAJ;;AAEA;AACA,MAAIxB,qCAAJ,EAA8B;AAC5B;AACA,QAAI,iCAAoBH,KAApB,EAA2BG,GAA3B,CAAJ,EAAqC;AACnC;AACAwB,kBAAY,0BAAa3B,KAAb,EAAoBG,GAApB,CAAZ;AACD,KAHD,MAGO;AAAE;AACP;AACA,UAAIyB,SAAS,qBAAQ5B,KAAR,EAAeG,GAAf,CAAb;AACA,+BAAUyB,gDAAV;;AAEA;AACAD,kBAAYC,OAAOC,cAAP,EAAZ;AACD;AACF,GAbD,MAaO;AAAE;AACP;AACAF,gBAAY3B,MAAMmB,UAAN,CAAiBI,SAA7B;AACD;;AAED;AACA,MAAIO,WAAWjC,GAAf;;AAEA;AACA,MAAIkC,WAAW,8BAAiB/B,KAAjB,EAAwB8B,QAAxB,CAAf;;AAEA;AACA,SAAO,gCAAmB9B,KAAnB,EAA0BF,UAA1B,EAAsCC,GAAtC,EAA2CI,GAA3C,EAAgDG,IAAhD,EAAsDqB,SAAtD,EAAmE9B,IAAIa,SAAvE,EAA2GqB,QAA3G,CAAP;AACD,C;;AA7FD;;AAEA;;AAEA;;AACA;;AAYA;;;;AACA;;IAAYf,C;;AACZ","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { EnvironmentRecord } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { ConcreteValue, AbstractValue, FunctionValue } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { PerformEval } from \"../methods/function.js\";\nimport {\n  SameValue,\n  GetValue,\n  GetThisValue,\n  GetBase,\n  IsInTailPosition,\n  IsPropertyReference,\n  GetReferencedName,\n  EvaluateDirectCall,\n  ArgumentListEvaluation\n} from \"../methods/index.js\";\nimport type { BabelNode, BabelNodeCallExpression, BabelNodeExpression, BabelNodeSpreadElement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\n\nexport default function (ast: BabelNodeCallExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  // ECMA262 12.3.4.1\n  realm.setNextExecutionContextLocation(ast.loc);\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let ref = env.evaluate(ast.callee, strictCode);\n\n  // 2. Let func be ? GetValue(ref).\n  let func = GetValue(realm, ref);\n\n  if (func instanceof AbstractValue && func.getType() === FunctionValue) {\n    let args =\n      [func].concat(ArgumentListEvaluation(realm, strictCode, env, ((ast.arguments: any): Array<BabelNode>)));\n    return realm.deriveAbstract(\n      new TypesDomain(AbstractValue),\n      ValuesDomain.topVal,\n      args,\n      (nodes) => {\n        let fun_args = ((nodes.slice(1): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n        return t.callExpression(nodes[0], fun_args);\n      });\n  }\n  func = func.throwIfNotConcrete();\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (ref instanceof Reference && !IsPropertyReference(realm, ref) && GetReferencedName(realm, ref) === \"eval\") {\n    // a. If SameValue(func, %eval%) is true, then\n    if (func instanceof ConcreteValue && SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n      let argList = ArgumentListEvaluation(realm, strictCode, env, ((ast.arguments: any): Array<BabelNode>));\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      return PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else { // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else { // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n  return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ((ast.arguments: any): Array<BabelNode>), tailCall);\n}\n"]}