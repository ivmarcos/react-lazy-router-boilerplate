{"version":3,"sources":["../../src/evaluators/UnaryExpression.js"],"names":["ast","strictCode","env","realm","expr","evaluate","argument","operator","value","computeAbstractly","oldValue","throwIfNotConcrete","isNaN","intrinsics","NaN","mightNotBeObject","false","true","undefined","val","proto","getType","prototype","isInstance","ref","createErrorThrowCompletion","ReferenceError","base","baseObj","deleteStatus","$Delete","TypeError","bindings","referencedName","DeleteBinding","Error","t","Constructor","type","op","createAbstract","topVal","node","unaryExpression"],"mappings":";;;;;;ypBAAA;;;;;;;;;kBA4Ce,UAAUA,GAAV,EAAyCC,UAAzC,EAA8DC,GAA9D,EAAuFC,KAAvF,EAAwH;AACrI,MAAIC,OAAOF,IAAIG,QAAJ,CAAaL,IAAIM,QAAjB,EAA2BL,UAA3B,CAAX;;AAEA,MAAID,IAAIO,QAAJ,KAAiB,GAArB,EAA0B;AACxB;;AAEA;AACAH;;AAEA;AACA,QAAII,QAAQ,sBAASL,KAAT,EAAgBC,IAAhB,CAAZ;AACA,QAAII,yCAAkC,4BAAeL,KAAf,EAAsBK,KAAtB,CAAtC,EAAoE,OAAOC,kBAAkBN,KAAlB,sBAAsC,GAAtC,EAA2CK,KAA3C,CAAP;AACpE,QAAIE,WAAW,sBAASP,KAAT,EAAgBK,MAAMG,kBAAN,EAAhB,CAAf;;AAEA;AACA,QAAIC,MAAMF,QAAN,CAAJ,EAAqB;AACnB,aAAOP,MAAMU,UAAN,CAAiBC,GAAxB;AACD;;AAED;AACA,WAAO,uBAAgBX,KAAhB,EAAuB,CAACO,QAAxB,CAAP;AACD,GAlBD,MAkBO,IAAIV,IAAIO,QAAJ,KAAiB,GAArB,EAA0B;AAC/B;;AAEA;AACAH;;AAEA;AACA,QAAII,SAAQ,sBAASL,KAAT,EAAgBC,IAAhB,CAAZ;AACA,QAAII,0CAAkC,4BAAeL,KAAf,EAAsBK,MAAtB,CAAtC,EAAoE,OAAOC,kBAAkBN,KAAlB,sBAAsC,GAAtC,EAA2CK,MAA3C,CAAP;AACpE,WAAO,uBAAgBL,KAAhB,EAAuB,sBAASA,KAAT,EAAgBK,OAAMG,kBAAN,EAAhB,CAAvB,CAAP;AACD,GAVM,MAUA,IAAIX,IAAIO,QAAJ,KAAiB,GAArB,EAA0B;AAC/B;;AAEA;AACAH;;AAEA;AACA,QAAII,UAAQ,sBAASL,KAAT,EAAgBC,IAAhB,CAAZ;AACA,QAAII,2CAAkC,4BAAeL,KAAf,EAAsBK,OAAtB,CAAtC,EAAoE,OAAOC,kBAAkBN,KAAlB,sBAAsC,GAAtC,EAA2CK,OAA3C,CAAP;AACpE,QAAIE,YAAW,qBAAQP,KAAR,EAAeK,QAAMG,kBAAN,EAAf,CAAf;;AAEA;AACA,WAAO,uBAAgBR,KAAhB,EAAuB,CAACO,SAAxB,CAAP;AACD,GAbM,MAaA,IAAIV,IAAIO,QAAJ,KAAiB,GAArB,EAA0B;AAC/B;;AAEA;AACAH;;AAEA;AACA,QAAII,UAAQ,sBAASL,KAAT,EAAgBC,IAAhB,CAAZ;AACA,QAAII,2CAAkCA,QAAMO,gBAAN,EAAtC,EAAgE,OAAON,kBAAkBN,KAAlB,sBAAsC,GAAtC,EAA2CK,OAA3C,CAAP;AAChE,QAAIE,aAAW,8BAAiBP,KAAjB,EAAwBK,OAAxB,CAAf;;AAEA;AACA,QAAIE,eAAa,IAAjB,EAAuB,OAAOP,MAAMU,UAAN,CAAiBG,KAAxB;;AAEvB;AACA,WAAOb,MAAMU,UAAN,CAAiBI,IAAxB;AACD,GAhBM,MAgBA,IAAIjB,IAAIO,QAAJ,KAAiB,MAArB,EAA6B;AAClC;AACAH;;AAEA;AACA,0BAASD,KAAT,EAAgBC,IAAhB;;AAEA;AACA,WAAOD,MAAMU,UAAN,CAAiBK,SAAxB;AACD,GATM,MASA,IAAIlB,IAAIO,QAAJ,KAAiB,QAArB,EAA+B;AACpC;;AAEA;AACA,QAAIY,MAAMf,IAAV;;AAEA;AACA,QAAIe,qCAAJ,EAA8B;AAC5B;AACA,UAAI,qCAAwBhB,KAAxB,EAA+BgB,GAA/B,CAAJ,EAAyC;AACvC,eAAO,uBAAgBhB,KAAhB,EAAuB,WAAvB,CAAP;AACD;AACF;;AAED;AACAgB,UAAM,sBAAShB,KAAT,EAAgBgB,GAAhB,CAAN;;AAEA;AACA,QAAI,wBAAWhB,KAAX,EAAkBgB,GAAlB,CAAJ,EAA4B;AAC1B,aAAO,uBAAgBhB,KAAhB,EAAuB,UAAvB,CAAP;AACD,KAFD,MAEO;AACL,UAAIiB,QAAQD,IAAIE,OAAJ,GAAcC,SAA1B;AACA,UAAIC,WAAWH,KAAX,wBAAJ,EAAuC;AACrC,eAAO,uBAAgBjB,KAAhB,EAAuB,WAAvB,CAAP;AACD,OAFD,MAEO,IAAIoB,WAAWH,KAAX,mBAAJ,EAAkC;AACvC,eAAO,uBAAgBjB,KAAhB,EAAuB,QAAvB,CAAP;AACD,OAFM,MAEA,IAAIoB,WAAWH,KAAX,qBAAJ,EAAoC;AACzC,eAAO,uBAAgBjB,KAAhB,EAAuB,QAAvB,CAAP;AACD,OAFM,MAEA,IAAIoB,WAAWH,KAAX,sBAAJ,EAAqC;AAC1C,eAAO,uBAAgBjB,KAAhB,EAAuB,SAAvB,CAAP;AACD,OAFM,MAEA,IAAIoB,WAAWH,KAAX,qBAAJ,EAAoC;AACzC,eAAO,uBAAgBjB,KAAhB,EAAuB,QAAvB,CAAP;AACD,OAFM,MAEA,IAAIoB,WAAWH,KAAX,qBAAJ,EAAoC;AACzC,eAAO,uBAAgBjB,KAAhB,EAAuB,QAAvB,CAAP;AACD,OAFM,MAEA,IAAIoB,WAAWH,KAAX,qBAAJ,EAAoC;AACzC,eAAO,uBAAgBjB,KAAhB,EAAuB,QAAvB,CAAP;AACD,OAFM,MAEA;AACL,iCAAUgB,mCAAV;AACA,eAAOV,kBAAkBN,KAAlB,sBAAsC,QAAtC,EAAgDgB,GAAhD,CAAP;AACD;AACF;AACF,GAzCM,MAyCA,IAAInB,IAAIO,QAAJ,KAAiB,QAArB,EAA+B;AACpC;;AAEA;AACA,QAAIiB,MAAMpB,IAAV;;AAEA;;AAEA;AACA,QAAI,EAAEoB,qCAAF,CAAJ,EAAiC,OAAOrB,MAAMU,UAAN,CAAiBI,IAAxB;;AAEjC;AACA,QAAI,qCAAwBd,KAAxB,EAA+BqB,GAA/B,CAAJ,EAAyC;AACvC;AACA,+BAAU,CAAC,+BAAkBrB,KAAlB,EAAyBqB,GAAzB,CAAX,EAA0C,mCAA1C;;AAEA;AACA,aAAOrB,MAAMU,UAAN,CAAiBI,IAAxB;AACD;;AAED;AACA,QAAI,iCAAoBd,KAApB,EAA2BqB,GAA3B,CAAJ,EAAqC;AACnC;AACA,UAAI,8BAAiBrB,KAAjB,EAAwBqB,GAAxB,CAAJ,EAAkC;AAChC,cAAMrB,MAAMsB,0BAAN,CAAiCtB,MAAMU,UAAN,CAAiBa,cAAlD,CAAN;AACD;;AAED;AACA,UAAIC,OAAO,qBAAQxB,KAAR,EAAeqB,GAAf,CAAX;AACA,+BAAUG,4BAAV;AACA,UAAIC,UAAU,6BAAgBzB,KAAhB,EAAuBwB,IAAvB,CAAd;;AAEA;AACA,UAAIE,eAAeD,QAAQE,OAAR,CAAgB,+BAAkB3B,KAAlB,EAAyBqB,GAAzB,CAAhB,CAAnB;;AAEA;AACA,UAAI,CAACK,YAAD,IAAiB,+BAAkB1B,KAAlB,EAAyBqB,GAAzB,CAArB,EAAoD;AAClD,cAAMrB,MAAMsB,0BAAN,CAAiCtB,MAAMU,UAAN,CAAiBkB,SAAlD,CAAN;AACD;;AAED;AACA,aAAO,wBAAiB5B,KAAjB,EAAwB0B,YAAxB,CAAP;AACD;;AAED;AACA;AACA,QAAIG,WAAW,qBAAQ7B,KAAR,EAAeqB,GAAf,CAAf;AACA,6BAAUQ,kDAAV;;AAEA;AACA,QAAIC,iBAAiB,+BAAkB9B,KAAlB,EAAyBqB,GAAzB,CAArB;AACA,6BAAU,OAAOS,cAAP,KAA0B,QAApC;AACA,WAAO,wBAAiB9B,KAAjB,EAAwB6B,SAASE,aAAT,CAAuBD,cAAvB,CAAxB,CAAP;AACD;;AAED,QAAM,IAAIE,KAAJ,CAAU,eAAV,CAAN;AACD,C;;AArMD;;AACA;;AACA;;AACA;;;;AACA;;AAeA;;IAAYC,C;;;;;;AAGZ,SAASb,UAAT,CAAoBH,KAApB,EAA2BiB,WAA3B,EAAiD;AAC/C,SAAOjB,iBAAiBiB,WAAjB,IAAgCjB,UAAUiB,YAAYf,SAA7D;AACD;;AAED,SAASb,iBAAT,CAA2BN,KAA3B,EAAkCmC,IAAlC,EAAwCC,EAAxC,EAA4CpB,GAA5C,EAAiD;AAC/C,SAAOhB,MAAMqC,cAAN,CAAqB,wBAAgBF,IAAhB,CAArB,EAA4C,qBAAaG,MAAzD,EAAiE,CAACtB,GAAD,CAAjE,EACL;AAAA;AAAA,QAAEuB,IAAF;;AAAA,WAAYN,EAAEO,eAAF,CAAkBJ,EAAlB,EAAsBG,IAAtB,CAAZ;AAAA,GADK,CAAP;AAED","file":"UnaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value, BooleanValue, NumberValue, StringValue, UndefinedValue, NullValue, SymbolValue, ObjectValue, AbstractValue } from \"../values/index.js\";\nimport { Reference, EnvironmentRecord } from \"../environment.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  GetReferencedName,\n  GetBase,\n  GetValue,\n  ToBooleanPartial,\n  ToObjectPartial,\n  ToNumber,\n  ToInt32,\n  IsSuperReference,\n  IsCallable,\n  IsUnresolvableReference,\n  IsStrictReference,\n  IsPropertyReference,\n  IsToNumberPure\n} from \"../methods/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeUnaryExpression } from \"babel-types\";\n\nfunction isInstance(proto, Constructor): boolean {\n  return proto instanceof Constructor || proto === Constructor.prototype;\n}\n\nfunction computeAbstractly(realm, type, op, val) {\n  return realm.createAbstract(new TypesDomain(type), ValuesDomain.topVal, [val],\n    ([node]) => t.unaryExpression(op, node));\n}\n\nexport default function (ast: BabelNodeUnaryExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  if (ast.operator === \"-\") {\n    // ECMA262 12.5.7.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n    let value = GetValue(realm, expr);\n    if (value instanceof AbstractValue && IsToNumberPure(realm, value)) return computeAbstractly(realm, NumberValue, \"-\", value);\n    let oldValue = ToNumber(realm, value.throwIfNotConcrete());\n\n    // 3. If oldValue is NaN, return NaN.\n    if (isNaN(oldValue)) {\n      return realm.intrinsics.NaN;\n    }\n\n    // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n    return new NumberValue(realm, -oldValue);\n  } else if (ast.operator === \"+\") {\n    // ECMA262 12.5.6.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Return ? ToNumber(? GetValue(expr)).\n    let value = GetValue(realm, expr);\n    if (value instanceof AbstractValue && IsToNumberPure(realm, value)) return computeAbstractly(realm, NumberValue, \"+\", value);\n    return new NumberValue(realm, ToNumber(realm, value.throwIfNotConcrete()));\n  } else if (ast.operator === \"~\") {\n    // ECMA262 12.5.8\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n    let value = GetValue(realm, expr);\n    if (value instanceof AbstractValue && IsToNumberPure(realm, value)) return computeAbstractly(realm, NumberValue, \"~\", value);\n    let oldValue = ToInt32(realm, value.throwIfNotConcrete());\n\n    // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n    return new NumberValue(realm, ~oldValue);\n  } else if (ast.operator === \"!\") {\n    // ECMA262 12.6.9\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n    let value = GetValue(realm, expr);\n    if (value instanceof AbstractValue && value.mightNotBeObject()) return computeAbstractly(realm, NumberValue, \"!\", value);\n    let oldValue = ToBooleanPartial(realm, value);\n\n    // 3. If oldValue is true, return false.\n    if (oldValue === true) return realm.intrinsics.false;\n\n    // 4. Return true.\n    return realm.intrinsics.true;\n  } else if (ast.operator === \"void\") {\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Perform ? GetValue(expr).\n    GetValue(realm, expr);\n\n    // 3. Return undefined.\n    return realm.intrinsics.undefined;\n  } else if (ast.operator === \"typeof\") {\n    // ECMA262 12.6.5\n\n    // 1. Let val be the result of evaluating UnaryExpression.\n    let val = expr;\n\n    // 2. If Type(val) is Reference, then\n    if (val instanceof Reference) {\n      // a. If IsUnresolvableReference(val) is true, return \"undefined\".\n      if (IsUnresolvableReference(realm, val)) {\n        return new StringValue(realm, \"undefined\");\n      }\n    }\n\n    // 3. Let val be ? GetValue(val).\n    val = GetValue(realm, val);\n\n    // 4. Return a String according to Table 35.\n    if (IsCallable(realm, val)) {\n      return new StringValue(realm, \"function\");\n    } else {\n      let proto = val.getType().prototype;\n      if (isInstance(proto, UndefinedValue)) {\n        return new StringValue(realm, \"undefined\");\n      } else if (isInstance(proto, NullValue)) {\n        return new StringValue(realm, \"object\");\n      } else if (isInstance(proto, StringValue)) {\n        return new StringValue(realm, \"string\");\n      } else if (isInstance(proto, BooleanValue)) {\n        return new StringValue(realm, \"boolean\");\n      } else if (isInstance(proto, NumberValue)) {\n        return new StringValue(realm, \"number\");\n      } else if (isInstance(proto, SymbolValue)) {\n        return new StringValue(realm, \"symbol\");\n      } else if (isInstance(proto, ObjectValue)) {\n        return new StringValue(realm, \"object\");\n      } else {\n        invariant(val instanceof AbstractValue);\n        return computeAbstractly(realm, StringValue, \"typeof\", val);\n      }\n    }\n  } else if (ast.operator === \"delete\") {\n    // ECMA262 12.5.3.2\n\n    // 1. Let ref be the result of evaluating UnaryExpression.\n    let ref = expr;\n\n    // 2. ReturnIfAbrupt(ref).\n\n    // 3. If Type(ref) is not Reference, return true.\n    if (!(ref instanceof Reference)) return realm.intrinsics.true;\n\n    // 4. If IsUnresolvableReference(ref) is true, then\n    if (IsUnresolvableReference(realm, ref)) {\n      // a. Assert: IsStrictReference(ref) is false.\n      invariant(!IsStrictReference(realm, ref), \"did not expect a strict reference\");\n\n      // b. Return true.\n      return realm.intrinsics.true;\n    }\n\n    // 5. If IsPropertyReference(ref) is true, then\n    if (IsPropertyReference(realm, ref)) {\n      // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.\n      if (IsSuperReference(realm, ref)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n\n      // b. Let baseObj be ! ToObject(GetBase(ref)).\n      let base = GetBase(realm, ref);\n      invariant(base instanceof Value);\n      let baseObj = ToObjectPartial(realm, base);\n\n      // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).\n      let deleteStatus = baseObj.$Delete(GetReferencedName(realm, ref));\n\n      // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.\n      if (!deleteStatus && IsStrictReference(realm, ref)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // e. Return deleteStatus.\n      return new BooleanValue(realm, deleteStatus);\n    }\n\n    // 6. Else ref is a Reference to an Environment Record binding,\n    // a. Let bindings be GetBase(ref).\n    let bindings = GetBase(realm, ref);\n    invariant(bindings instanceof EnvironmentRecord);\n\n    // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).\n    let referencedName = GetReferencedName(realm, ref);\n    invariant(typeof referencedName === \"string\");\n    return new BooleanValue(realm, bindings.DeleteBinding(referencedName));\n  }\n\n  throw new Error(\"unimplemented\");\n}\n"]}