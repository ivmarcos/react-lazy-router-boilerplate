{"version":3,"sources":["../../src/evaluators/ForInStatement.js"],"names":["ast","strictCode","env","realm","labelSet","left","right","body","type","kind","keyResult","emitResidualLoopIfSafe","declarations","id","throwIfNotConcreteObject","e","target","intrinsics","undefined","value","t","lh","ob","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","envRec","environmentRecord","absStr","createAbstract","topVal","stringLiteral","boundName","n","identifier","CreateMutableBinding","InitializeBinding","partially_evaluate_node","compl","gen","bindings","properties","createdObj","length","size","targetObject","sourceObject","forEach","desc","key","map","object","unknownProperty","sourceValue","cond","args","mem","condition","oe","values","getElements","o","co","generator","push","buildNode","obj","tgt","src","obj1","tgt1","src1","forInStatement","blockStatement","expressionStatement","assignmentExpression","memberExpression","template","getTemplate","binding","descriptor","$Set","isSimple","makePartial"],"mappings":"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","file":"ForInStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment, Reference } from \"../environment.js\";\nimport { BreakCompletion } from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { ForInOfHeadEvaluation, ForInOfBodyEvaluation } from \"./ForOfStatement.js\";\nimport { BoundNames, NewDeclarativeEnvironment, UpdateEmpty } from \"../methods/index.js\";\nimport { AbstractValue, AbstractObjectValue, ObjectValue, StringValue, UndefinedValue, Value } from \"../values/index.js\";\nimport type { BabelNodeForInStatement, BabelNodeStatement, BabelNodeVariableDeclaration } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\n// ECMA262 13.7.5.11\nexport default function (ast: BabelNodeForInStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm, labelSet: ?Array<string>): Value | Reference {\n  let { left, right, body } = ast;\n\n  try {\n    if (left.type === \"VariableDeclaration\") {\n      if (left.kind === \"var\") { // for (var ForBinding in Expression) Statement\n        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"enumerate\", strictCode);\n\n        if (keyResult instanceof AbstractObjectValue) {\n          return emitResidualLoopIfSafe(ast, strictCode, env, realm, left, keyResult, body);\n        }\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left.declarations[0].id, body, keyResult, \"varBinding\", labelSet, strictCode);\n      } else { // for (ForDeclaration in Expression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, BoundNames(realm, left), right, \"enumerate\", strictCode);\n        keyResult = keyResult.throwIfNotConcreteObject();\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n      }\n    } else { // for (LeftHandSideExpression in Expression) Statement\n      // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"enumerate\", strictCode);\n      keyResult = keyResult.throwIfNotConcreteObject();\n\n      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n    }\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target)\n        return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  }\n}\n\nfunction emitResidualLoopIfSafe(ast: BabelNodeForInStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm,\n    lh: BabelNodeVariableDeclaration, ob: AbstractObjectValue, body: BabelNodeStatement) {\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n  let blockEnv = NewDeclarativeEnvironment(realm, oldEnv);\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n  try {\n    let envRec = blockEnv.environmentRecord;\n    invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n    let absStr = realm.createAbstract(\n      new TypesDomain(StringValue), ValuesDomain.topVal, [], t.stringLiteral(\"never used\"));\n    let boundName;\n    for (let n of BoundNames(realm, lh)) {\n      invariant(boundName === undefined);\n      boundName = t.identifier(n);\n      envRec.CreateMutableBinding(n, false);\n      envRec.InitializeBinding(n, absStr);\n    }\n    let [compl, gen, bindings, properties, createdObj] =\n      realm.partially_evaluate_node(body, strictCode, blockEnv);\n    if (compl instanceof Value && gen.body.length === 0 && bindings.size === 0 &&\n        properties.size === 1) {\n      invariant(createdObj.size === 0); // or there will be more than one property\n      let targetObject;\n      let sourceObject;\n      properties.forEach((desc, key, map) => {\n        if (key.object.unknownProperty === key) {\n          targetObject = key.object;\n          invariant(desc !== undefined);\n          let sourceValue = desc.value;\n          if (sourceValue instanceof AbstractValue) {\n            // because sourceValue was written to key.object.unknownProperty it must be that\n            let cond = sourceValue.args[0];\n            // and because the write always creates a value of this shape\n            invariant(cond instanceof AbstractValue && cond.kind === \"template for property name condition\");\n            if (sourceValue.args[2] instanceof UndefinedValue) {\n              // check that the value that was assigned itself came from\n              // an expression of the form sourceObject[absStr].\n              let mem = sourceValue.args[1];\n              while (mem instanceof AbstractValue) {\n                if (mem.kind === \"sentinel member expression\" && mem.args[0] instanceof ObjectValue && mem.args[1] === absStr) {\n                  sourceObject = mem.args[0];\n                  break;\n                }\n                // check if mem is a test for absStr being equal to a known property\n                // if so skip over it until we get to the expression of the form sourceObject[absStr].\n                let condition = mem.args[0];\n                if (condition instanceof AbstractValue && condition.kind === \"check for known property\") {\n                  if (condition.args[0] === absStr) {\n                    mem = mem.args[2];\n                    continue;\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n      });\n      if (targetObject !== undefined && sourceObject !== undefined) {\n        let oe = ob.values.getElements();\n        if (oe.size !== 1) ob.throwIfNotConcreteObject();\n        let o; for (let co of oe) o = co; invariant(o !== undefined);\n        let generator = realm.generator; invariant(generator !== undefined);\n        generator.body.push({\n          // duplicate args to ensure refcount > 1\n          args: [o, targetObject, sourceObject, targetObject, sourceObject],\n          buildNode: ([obj, tgt, src, obj1, tgt1, src1]) => {\n            invariant(boundName !== undefined);\n            return t.forInStatement(lh, obj,\n              t.blockStatement([t.expressionStatement(t.assignmentExpression(\"=\",\n              t.memberExpression(tgt, boundName, true),\n              t.memberExpression(src, boundName, true)))]));\n          },\n        });\n\n        // At this point, we have emitted code to copy over all properties.\n        // However, the internal Prepack state of targetObject doesn't represent the copied properties yet.\n        // So, we copy all all known properties, and then mark the target object as simple or partial as appropriate.\n        // TODO: While correct, this generates inefficient code, which first inlines all known properties, and then copies them over again.\n\n        let template;\n        if (sourceObject instanceof AbstractObjectValue) template = sourceObject.getTemplate();\n\n        // TODO: The following case kicks in for ForInStatement11.js, but I don't understand why.\n        if (sourceObject instanceof ObjectValue) template = sourceObject;\n\n        if (template !== undefined) {\n          invariant(template.properties);\n          for (let [key, binding] of template.properties) {\n            if (binding === undefined || binding.descriptor === undefined) continue; // deleted\n            invariant(binding.descriptor !== undefined);\n            invariant(binding.descriptor.value !== undefined);\n            targetObject.$Set(key, binding.descriptor.value, targetObject);\n          }\n        }\n\n        // TODO: All other properties of the target object now have unknown values and those properties must be invalidated.\n        if (!targetObject.isSimple()) targetObject.makePartial();\n\n        return realm.intrinsics.undefined;\n      }\n    }\n  } finally {\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n\n  ob.throwIfNotConcreteObject();\n  return realm.intrinsics.undefined;\n}\n"]}