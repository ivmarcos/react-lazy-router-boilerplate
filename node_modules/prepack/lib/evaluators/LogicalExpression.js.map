{"version":3,"sources":["../../src/evaluators/LogicalExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","lbool","operator","rref","right","isTypeCompatibleWith","getType","compl1","gen1","bindings1","properties1","createdObj1","partially_evaluate_node","compl2","gen2","bindings2","properties2","createdObj2","restoreBindings","restoreProperties","createIntrospectionErrorThrowCompletion","completion","generator","bindings","properties","createdObjects","appendGenerator","types","joinValues","values","result","createAbstract","args","t","logicalExpression"],"mappings":"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","file":"LogicalExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport { IntrospectionThrowCompletion } from \"../completions.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { ObjectValue, AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport { GetValue, joinEffects, ToBoolean } from \"../methods/index.js\";\nimport type { BabelNodeLogicalExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\nexport default function (ast: BabelNodeLogicalExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = GetValue(realm, lref);\n\n  if (lval instanceof ConcreteValue) {\n    let lbool = ToBoolean(realm, lval);\n\n    if (ast.operator === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else if (ast.operator === \"||\") {\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n\n    let rref = env.evaluate(ast.right, strictCode);\n    return GetValue(realm, rref);\n  }\n  invariant(lval instanceof AbstractValue);\n\n  if (Value.isTypeCompatibleWith(lval.getType(), ObjectValue)) {\n    if (ast.operator === \"&&\")\n      return env.evaluate(ast.right, strictCode);\n    else {\n      return lval;\n    }\n  }\n\n  // Create empty effects for the case where ast.left is defined\n  let [compl1, gen1, bindings1, properties1, createdObj1] =\n    construct_empty_effects(realm);\n\n  // Evaluate ast.right in a sandbox to get its effects\n  let [compl2, gen2, bindings2, properties2, createdObj2] =\n    realm.partially_evaluate_node(ast.right, strictCode, env);\n\n  if (compl2 instanceof IntrospectionThrowCompletion) {\n    realm.restoreBindings(bindings2);\n    realm.restoreProperties(properties2);\n    throw compl2;\n  }\n  // todo: don't just give up on abrupt completions, but try to join states\n  // eg. foo || throwSomething()\n  if (!(compl2 instanceof Value))\n    throw AbstractValue.createIntrospectionErrorThrowCompletion(lval);\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of ast.left.\n  let [completion, generator, bindings, properties, createdObjects] =\n    ast.operator === \"&&\" ?\n      joinEffects(realm, lval,\n        [compl2, gen2, bindings2, properties2, createdObj2],\n        [compl1, gen1, bindings1, properties1, createdObj1])\n    :\n      joinEffects(realm, lval,\n        [compl1, gen1, bindings1, properties1, createdObj1],\n        [compl2, gen2, bindings2, properties2, createdObj2]);\n\n\n  // Apply the joined effects to the global state\n  realm.restoreBindings(bindings);\n  realm.restoreProperties(properties);\n\n  // Add generated code for property modifications\n  realm.appendGenerator(generator);\n\n  // Ignore the joined completion\n  completion;\n\n  // Ignore created objects\n  createdObjects;\n\n  // And return an actual logicalExpression\n  let types = TypesDomain.joinValues(lval, compl2);\n  let values = ValuesDomain.joinValues(realm, lval, compl2);\n  let result = realm.createAbstract(types, values,\n    [lval, compl2],\n    (args) => t.logicalExpression(ast.operator, args[0], args[1]));\n   result.values = ValuesDomain.joinValues(realm, lval, compl2);\n   return result;\n}\n"]}