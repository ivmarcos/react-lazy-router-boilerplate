{"version":3,"sources":["../../src/evaluators/VariableDeclaration.js"],"names":["ast","strictCode","env","realm","kind","letAndConst","declarations","declar","id","type","Error","Initializer","init","bindingId","name","lhs","rhs","evaluate","value","__originalName","hasNameProperty","intrinsics","empty","undefined"],"mappings":"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","file":"VariableDeclaration.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport { ObjectValue, StringValue } from \"../values/index.js\";\nimport {\n  PutValue,\n  GetValue,\n  ResolveBinding,\n  InitializeReferencedBinding,\n  IsAnonymousFunctionDefinition,\n  HasOwnProperty,\n  SetFunctionName,\n} from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeVariableDeclaration } from \"babel-types\";\n\n// ECMA262 13.3.1.4\nfunction letAndConst (ast: BabelNodeVariableDeclaration, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  for (let declar of ast.declarations) {\n    if (declar.id.type !== \"Identifier\") {\n      throw new Error(\"TODO: Patterns aren't supported yet\");\n    }\n\n    let Initializer = declar.init;\n    if (!Initializer) {\n      invariant(ast.kind !== \"const\", \"const without an initializer\");\n\n      // 1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).\n      let bindingId = declar.id.name;\n      let lhs = ResolveBinding(realm, bindingId, strictCode);\n\n      // 2. Return InitializeReferencedBinding(lhs, undefined).\n      InitializeReferencedBinding(realm, lhs, realm.intrinsics.undefined);\n      continue;\n    }\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    let bindingId = declar.id.name;\n\n    // 2. Let lhs be ResolveBinding(bindingId).\n    let lhs = ResolveBinding(realm, bindingId, strictCode);\n\n    // 3. Let rhs be the result of evaluating Initializer.\n    let rhs = env.evaluate(Initializer, strictCode);\n\n    // 4. Let value be ? GetValue(rhs).\n    let value = GetValue(realm, rhs);\n\n    // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then\n    if (IsAnonymousFunctionDefinition(realm, Initializer)) {\n      invariant(value instanceof ObjectValue);\n\n      // a. Let hasNameProperty be ? HasOwnProperty(value, \"name\").\n      let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n      // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).\n      if (!hasNameProperty) SetFunctionName(realm, value, new StringValue(realm, bindingId));\n    }\n\n    // 6. Return InitializeReferencedBinding(lhs, value).\n    InitializeReferencedBinding(realm, lhs, value);\n  }\n\n  return realm.intrinsics.empty;\n}\n\n// ECMA262 13.3.2.4\nexport default function (ast: BabelNodeVariableDeclaration, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  if (ast.kind === \"let\" || ast.kind === \"const\") {\n    return letAndConst(ast, strictCode, env, realm);\n  }\n\n  for (let declar of ast.declarations) {\n    if (declar.id.type !== \"Identifier\") {\n      throw new Error(\"TODO: Patterns aren't supported yet\");\n    }\n\n    let Initializer = declar.init;\n    if (!Initializer) continue;\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    let bindingId = declar.id.name;\n\n    // 2. Let lhs be ? ResolveBinding(bindingId).\n    let lhs = ResolveBinding(realm, bindingId, strictCode);\n\n    // 3. Let rhs be the result of evaluating Initializer.\n    let rhs = env.evaluate(Initializer, strictCode);\n\n    // 4. Let value be ? GetValue(rhs).\n    let value = GetValue(realm, rhs);\n    if (declar.id && declar.id.name) value.__originalName = bindingId;\n\n    // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then\n    if (IsAnonymousFunctionDefinition(realm, Initializer)) {\n      invariant(value instanceof ObjectValue);\n\n      // a. Let hasNameProperty be ? HasOwnProperty(value, \"name\").\n      let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n      // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).\n      if (!hasNameProperty) SetFunctionName(realm, value, new StringValue(realm, bindingId));\n    }\n\n    // 6. Return ? PutValue(lhs, value).\n    PutValue(realm, lhs, value);\n  }\n\n  return realm.intrinsics.empty;\n}\n"]}