{"version":3,"sources":["../../src/evaluators/BinaryExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","rref","right","rval","computeBinary","operator","getPureBinaryOperationResultType","t","op","ltype","rtype","undefined","mightNotBeObject","type","createAbstract","topVal","lnode","rnode","binaryExpression","throwIfNotConcrete","lprim","rprim","lstr","rstr","lnum","rnum","r","intrinsics","false","value","true","base","exponent","Math","pow","isNaN","NaN","createErrorThrowCompletion","TypeError"],"mappings":"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","file":"BinaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value, AbstractValue, UndefinedValue, NullValue, BooleanValue, NumberValue, ObjectValue, StringValue } from \"../values/index.js\";\nimport { GetValue } from \"../methods/index.js\";\nimport { HasProperty, HasSomeCompatibleType } from \"../methods/index.js\";\nimport { Add, AbstractEqualityComparison, StrictEqualityComparison, AbstractRelationalComparison, InstanceofOperator, IsToPrimitivePure, GetToPrimitivePureResultType, IsToNumberPure } from \"../methods/index.js\";\nimport { ToUint32, ToInt32, ToNumber, ToPrimitive, ToString, ToPropertyKey } from \"../methods/index.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeBinaryExpression, BabelBinaryOperator } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function (ast: BabelNodeBinaryExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  // evaluate left\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = GetValue(realm, lref);\n\n  // evaluate right\n  let rref = env.evaluate(ast.right, strictCode);\n  let rval = GetValue(realm, rref);\n\n  return computeBinary(realm, ast.operator, lval, rval);\n}\n\n// Returns result type if binary operation is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\nexport function getPureBinaryOperationResultType(realm: Realm, op: BabelBinaryOperator, lval: Value, rval: Value): void | typeof Value {\n  if (op === \"+\") {\n    let ltype = GetToPrimitivePureResultType(realm, lval);\n    let rtype = GetToPrimitivePureResultType(realm, rval);\n    if (ltype === undefined || rtype === undefined) return undefined;\n    if (ltype === StringValue || rtype === StringValue) return StringValue;\n    return NumberValue;\n  } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\" || op === \"!=\" || op === \"==\") {\n    if (IsToPrimitivePure(realm, lval) && IsToPrimitivePure(realm, rval)) return BooleanValue;\n    return undefined;\n  } else if (op === \"===\" || op === \"!==\") {\n    return BooleanValue;\n  } else if (op === \">>>\" || op === \"<<\" || op === \">>\" || op === \"&\" || op === \"|\" || op === \"^\" ||\n             op === \"**\" || op === \"%\" || op === \"/\" || op === \"*\" || op === \"-\") {\n    if (IsToNumberPure(realm, lval) && IsToNumberPure(realm, rval)) return NumberValue;\n    return undefined;\n  } else if (op === \"in\") {\n    // TODO. Tricky. Needs deeper analysis. Can call arbitrary code e.g. when object is a Proxy => Side effects!\n    return undefined;\n  } else if (op === \"instanceof\") {\n    // TODO. Tricky. Needs deeper analysis. Can throw exceptions, call arbitrary code => Side effects!\n    return undefined;\n  }\n  invariant(false, \"unimplemented \" + op);\n}\n\nexport function computeBinary(realm: Realm, op: BabelBinaryOperator, lval: Value, rval: Value): Value {\n  // partial evaluation shortcut for a particular pattern (avoiding general throwIfNotConcrete check)\n  if (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\") {\n    if (!lval.mightNotBeObject() && HasSomeCompatibleType(realm, rval, NullValue, UndefinedValue) ||\n      HasSomeCompatibleType(realm, lval, NullValue, UndefinedValue) && !rval.mightNotBeObject())\n      return new BooleanValue(realm, op[0] !== \"=\");\n  }\n\n  if ((lval instanceof AbstractValue) || (rval instanceof AbstractValue)) {\n    let type = getPureBinaryOperationResultType(realm, op, lval, rval);\n    if (type !== undefined) {\n      return realm.createAbstract(new TypesDomain(type), ValuesDomain.topVal, [lval, rval],\n        ([lnode, rnode]) => t.binaryExpression(op, lnode, rnode));\n    }\n  }\n\n  lval = lval.throwIfNotConcrete();\n  rval = rval.throwIfNotConcrete();\n\n  if (op === \"+\") {\n    // ECMA262 12.8.3 The Addition Operator\n    let lprim = ToPrimitive(realm, lval);\n    let rprim = ToPrimitive(realm, rval);\n\n    if (lprim instanceof StringValue || rprim instanceof StringValue) {\n      let lstr = ToString(realm, lprim);\n      let rstr = ToString(realm, rprim);\n      return new StringValue(realm, lstr + rstr);\n    }\n\n    let lnum = ToNumber(realm, lprim);\n    let rnum = ToNumber(realm, rprim);\n    return Add(realm, lnum, rnum);\n  } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n    // ECMA262 12.10.3\n    if (op === \"<\") {\n      let r = AbstractRelationalComparison(realm, lval, rval, true);\n      if (r instanceof UndefinedValue) {\n        return realm.intrinsics.false;\n      } else {\n        return r;\n      }\n    } else if (op === \"<=\") {\n      let r = AbstractRelationalComparison(realm, rval, lval, false);\n      if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n        return realm.intrinsics.false;\n      } else {\n        return realm.intrinsics.true;\n      }\n    } else if (op === \">\") {\n      let r = AbstractRelationalComparison(realm, rval, lval, false);\n      if (r instanceof UndefinedValue) {\n        return realm.intrinsics.false;\n      } else {\n        return r;\n      }\n    } else if (op === \">=\") {\n      let r = AbstractRelationalComparison(realm, lval, rval, true);\n      if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n        return realm.intrinsics.false;\n      } else {\n        return realm.intrinsics.true;\n      }\n    }\n  } else if (op === \">>>\") {\n    // ECMA262 12.9.5.1\n    let lnum = ToUint32(realm, lval);\n    let rnum = ToUint32(realm, rval);\n\n    return new NumberValue(realm, lnum >>> rnum);\n  } else if (op === \"<<\" || op === \">>\") {\n    let lnum = ToInt32(realm, lval);\n    let rnum = ToUint32(realm, rval);\n\n    if (op === \"<<\") {\n      // ECMA262 12.9.3.1\n      return new NumberValue(realm, lnum << rnum);\n    } else if (op === \">>\") {\n      // ECMA262 12.9.4.1\n      return new NumberValue(realm, lnum >> rnum);\n    }\n  } else if (op === \"**\") {\n    // ECMA262 12.6.3\n\n    // 5. Let base be ? ToNumber(leftValue).\n    let base = ToNumber(realm, lval);\n\n    // 6. Let exponent be ? ToNumber(rightValue).\n    let exponent = ToNumber(realm, rval);\n\n    // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.7.3.4.\n    return new NumberValue(realm, Math.pow(base, exponent));\n  } else if (op === \"%\" || op === \"/\" || op === \"*\" || op === \"-\") {\n    // ECMA262 12.7.3\n    let lnum = ToNumber(realm, lval);\n    let rnum = ToNumber(realm, rval);\n\n    if (isNaN(rnum)) return realm.intrinsics.NaN;\n    if (isNaN(lnum)) return realm.intrinsics.NaN;\n\n    if (op === \"-\") {\n      return Add(realm, lnum, rnum, true);\n    } else if (op === \"%\") {\n      // The sign of the result equals the sign of the dividend.\n      // If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\n      // If the dividend is finite and the divisor is an infinity, the result equals the dividend.\n      // If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.\n      return new NumberValue(realm, lnum % rnum);\n    } else if (op === \"/\") {\n      // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n      // Division of an infinity by an infinity results in NaN.\n      // Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n      // Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n      // Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n      // Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n      // Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n      return new NumberValue(realm, lnum / rnum);\n    } else if (op === \"*\") {\n      // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n      // Multiplication of an infinity by a zero results in NaN.\n      // Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n      // Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n      return new NumberValue(realm, lnum * rnum);\n    }\n  } else if (op === \"!==\") {\n    return new BooleanValue(realm, !StrictEqualityComparison(realm, lval, rval));\n  } else if (op === \"===\") {\n    return new BooleanValue(realm, StrictEqualityComparison(realm, lval, rval));\n  } else if (op === \"!=\") {\n    return new BooleanValue(realm, !AbstractEqualityComparison(realm, lval, rval));\n  } else if (op === \"==\") {\n    return new BooleanValue(realm, AbstractEqualityComparison(realm, lval, rval));\n  } else if (op === \"&\" || op === \"|\" || op === \"^\") {\n    // ECMA262 12.12.3\n\n    // 5. Let lnum be ? ToInt32(lval).\n    let lnum: number = ToInt32(realm, lval);\n\n    // 6. Let rnum be ? ToInt32(rval).\n    let rnum: number = ToInt32(realm, rval);\n\n    // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer.\n    if (op === \"&\") {\n      return new NumberValue(realm, lnum & rnum);\n    } else if (op === \"|\") {\n      return new NumberValue(realm, lnum | rnum);\n    } else if (op === \"^\") {\n      return new NumberValue(realm, lnum ^ rnum);\n    }\n  } else if (op === \"in\") {\n    // ECMA262 12.10.3\n\n    // 5. If Type(rval) is not Object, throw a TypeError exception.\n    if (!(rval instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).\n    return new BooleanValue(realm, HasProperty(realm, rval, ToPropertyKey(realm, lval)));\n  } else if (op === \"instanceof\") {\n    // ECMA262 12.10.3\n\n    // 5. Return ? InstanceofOperator(lval, rval).;\n    return new BooleanValue(realm, InstanceofOperator(realm, lval, rval));\n  }\n\n  invariant(false, \"unimplemented \" + op);\n}\n"]}