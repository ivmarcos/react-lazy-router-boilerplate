{"version":3,"sources":["../../src/evaluators/CatchClause.js"],"names":["ast","strictCode","env","realm","thrownValue","oldEnv","getRunningContext","lexicalEnvironment","catchEnv","catchEnvRec","environmentRecord","param","argName","CreateMutableBinding","value","B","evaluate","body"],"mappings":";;;;;;kBAqBe,UAAUA,GAAV,EAAqCC,UAArC,EAA0DC,GAA1D,EAAmFC,KAAnF,EAAiGC,WAAjG,EAAsI;AACnJ,2BAAUA,mDAAV,EAAkD,mCAAlD;;AAEA;AACA,MAAIC,SAASF,MAAMG,iBAAN,GAA0BC,kBAAvC;;AAEA;AACA,MAAIC,WAAW,sCAA0BL,KAA1B,EAAiCE,MAAjC,CAAf;;AAEA;AACA,MAAII,cAAcD,SAASE,iBAA3B;;AAEA;AAZmJ;AAAA;AAAA;;AAAA;AAanJ,yBAAoB,uBAAWP,KAAX,EAAkBH,IAAIW,KAAtB,CAApB,8HAAkD;AAAA,UAAzCC,OAAyC;;AAChD;AACAH,kBAAYI,oBAAZ,CAAiCD,OAAjC,EAA0C,KAA1C;AACD;;AAED;AAlBmJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmBnJT,QAAMG,iBAAN,GAA0BC,kBAA1B,GAA+CC,QAA/C;;AAEA,MAAI;AACF;AACA,sCAAsBL,KAAtB,EAA6BH,IAAIW,KAAjC,EAAwCP,YAAYU,KAApD,EAA2DN,QAA3D;;AAEA;AACE;AACA;;AAEF;AACA,QAAIO,IAAIP,SAASQ,QAAT,CAAkBhB,IAAIiB,IAAtB,EAA4BhB,UAA5B,CAAR;;AAEA;AACA,WAAOc,CAAP;AACD,GAbD,SAaU;AACR;AACAZ,UAAMG,iBAAN,GAA0BC,kBAA1B,GAA+CF,MAA/C;AACD;AACF,C;;AA5CD;;AACA;;;;AACA","file":"CatchClause.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport { ThrowCompletion } from \"../completions.js\";\nimport invariant from \"../invariant.js\";\nimport { NewDeclarativeEnvironment, BoundNames, BindingInitialization } from \"../methods/index.js\";\nimport type { BabelNodeCatchClause } from \"babel-types\";\n\n// ECAM262 13.15.7\nexport default function (ast: BabelNodeCatchClause, strictCode: boolean, env: LexicalEnvironment, realm: Realm, thrownValue: any): Value | Reference {\n  invariant(thrownValue instanceof ThrowCompletion, \"Metadata isn't a throw completion\");\n\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).\n  let catchEnv = NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 3. Let catchEnvRec be catchEnv's EnvironmentRecord.\n  let catchEnvRec = catchEnv.environmentRecord;\n\n  // 4. For each element argName of the BoundNames of CatchParameter, do\n  for (let argName of BoundNames(realm, ast.param)) {\n    // a. Perform ! catchEnvRec.CreateMutableBinding(argName, false).\n    catchEnvRec.CreateMutableBinding(argName, false);\n  }\n\n  // 5. Set the running execution context's LexicalEnvironment to catchEnv.\n  realm.getRunningContext().lexicalEnvironment = catchEnv;\n\n  try {\n    // 6. Let status be the result of performing BindingInitialization for CatchParameter passing thrownValue and catchEnv as arguments.\n    BindingInitialization(realm, ast.param, thrownValue.value, catchEnv);\n\n    // 7. If status is an abrupt completion, then\n      // a. Set the running execution context's LexicalEnvironment to oldEnv.\n      // b. Return Completion(status).\n\n    // 8. Let B be the result of evaluating Block.\n    let B = catchEnv.evaluate(ast.body, strictCode);\n\n    // 10. Return Completion(B).\n    return B;\n  } finally {\n    // 9. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n}\n"]}