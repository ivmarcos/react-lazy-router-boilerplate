{"version":3,"sources":["../../src/evaluators/ForOfStatement.js"],"names":["InternalGetResultValue","LoopContinues","ForInOfHeadEvaluation","ForInOfBodyEvaluation","ast","strictCode","env","realm","labelSet","left","right","body","type","kind","keyResult","throwIfNotConcreteObject","declarations","id","result","value","intrinsics","empty","completion","target","indexOf","BindingInstantiation","envRec","environmentRecord","decl","Error","CreateImmutableBinding","name","CreateMutableBinding","TDZnames","expr","iterationKind","oldEnv","getRunningContext","lexicalEnvironment","length","TDZ","TDZEnvRec","exprRef","evaluate","exprValue","undefined","obj","isSimple","throwIfNotConcrete","lhs","stmt","iterator","lhsKind","V","destructuring","nextResult","nextValue","iterationEnv","lhsRef","evaluateCompletion","names","lhsName","status","e","resultValue"],"mappings":"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","file":"ForOfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport { BreakCompletion, AbruptCompletion, ContinueCompletion } from \"../completions.js\";\nimport { AbstractObjectValue, EmptyValue, ObjectValue, Value, NullValue, UndefinedValue } from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  InitializeReferencedBinding,\n  GetValue,\n  PutValue,\n  IteratorStep,\n  IteratorValue,\n  NewDeclarativeEnvironment,\n  ResolveBinding,\n  IteratorClose,\n  ToObjectPartial,\n  EnumerateObjectProperties,\n  UpdateEmpty,\n  BoundNames,\n  BindingInitialization,\n  GetIterator,\n  IsDestructuring,\n  HasSomeCompatibleType\n} from \"../methods/index.js\";\nimport type { BabelNodeForOfStatement, BabelNodeVariableDeclaration, BabelNodeLVal, BabelNode, BabelNodeStatement } from \"babel-types\";\n\nexport type IterationKind = \"iterate\" | \"enumerate\";\nexport type LhsKind = \"lexicalBinding\" | \"varBinding\" | \"assignment\";\n\nexport function InternalGetResultValue(realm: Realm, result: Reference | Value | AbruptCompletion): Value {\n  if (result instanceof AbruptCompletion) {\n    return result.value || realm.intrinsics.empty;\n  } else if (result instanceof Value) {\n    return result;\n  }\n  invariant(false);\n}\n\n// ECMA262 13.7.1.2\nexport function LoopContinues(realm: Realm, completion: Reference | Value | AbruptCompletion, labelSet: ?Array<string>): boolean {\n  // 1. If completion.[[Type]] is normal, return true.\n  if (completion instanceof Value || completion instanceof Reference) return true;\n  invariant(completion instanceof AbruptCompletion);\n\n  // 2. If completion.[[Type]] is not continue, return false.\n  if (!(completion instanceof ContinueCompletion)) return false;\n\n  // 3. If completion.[[Target]] is empty, return true.\n  if (!completion.target) return true;\n\n  // 4. If completion.[[Target]] is an element of labelSet, return true.\n  if (labelSet != null && labelSet.indexOf(completion.target) >= 0) return true;\n\n  // 5. Return false.\n  return false;\n}\n\n// ECMA262 13.7.5.10\nfunction BindingInstantiation(realm: Realm, ast: BabelNodeVariableDeclaration, env: LexicalEnvironment) {\n  // ast = ForDeclaration : LetOrConst ForBinding\n\n  // 1. Let envRec be environment's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a declarative Environment Record.\n  invariant(envRec instanceof DeclarativeEnvironmentRecord);\n\n  // 3. For each element name of the BoundNames of ForBinding do\n  for (let decl of ast.declarations) {\n    if (decl.id.type !== \"Identifier\")\n      throw new Error(\"TODO: Patterns aren't supported yet\");\n    // a. If IsConstantDeclaration of LetOrConst is true, then\n    if (ast.kind === \"const\") {\n      // i. Perform ! envRec.CreateImmutableBinding(name, true).\n      envRec.CreateImmutableBinding(decl.id.name, true);\n    } else { // b.\n      // i. Perform ! envRec.CreateMutableBinding(name, false).\n      envRec.CreateMutableBinding(decl.id.name, false);\n    }\n  }\n}\n\n// ECMA262 13.7.5.12\nexport function ForInOfHeadEvaluation(realm: Realm, env: LexicalEnvironment, TDZnames: Array<string>, expr: BabelNode, iterationKind: IterationKind, strictCode: boolean) {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. If TDZnames is not an empty List, then\n  if (TDZnames.length) {\n    // a. Assert: TDZnames has no duplicate entries.\n\n    // b. Let TDZ be NewDeclarativeEnvironment(oldEnv).\n    let TDZ = NewDeclarativeEnvironment(realm, oldEnv);\n\n    // c. Let TDZEnvRec be TDZ's EnvironmentRecord.\n    let TDZEnvRec = TDZ.environmentRecord;\n\n    // d. For each string name in TDZnames, do\n    for (let name of TDZnames) {\n      if (typeof name === \"string\") {\n        // i. Perform ! TDZEnvRec.CreateMutableBinding(name, false).\n        TDZEnvRec.CreateMutableBinding(name, false);\n      }\n    }\n\n    // e. Set the running execution context's LexicalEnvironment to TDZ.\n    realm.getRunningContext().lexicalEnvironment = TDZ;\n    env = TDZ;\n  }\n\n  let exprRef;\n  try {\n    // 3. Let exprRef be the result of evaluating expr.\n    exprRef = env.evaluate(expr, strictCode);\n  } finally {\n    // 4. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n  env = oldEnv;\n\n  // 5. Let exprValue be ? GetValue(exprRef).\n  let exprValue = GetValue(realm, exprRef);\n\n  // 6. If iterationKind is enumerate, then\n  if (iterationKind === \"enumerate\") {\n    // a. If exprValue.[[Value]] is null or undefined, then\n    if (HasSomeCompatibleType(realm, exprValue, NullValue, UndefinedValue)) {\n      // i. Return Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: empty}.\n      throw new BreakCompletion(realm.intrinsics.empty, undefined);\n    }\n\n    // b. Let obj be ToObject(exprValue).\n    let obj = ToObjectPartial(realm, exprValue);\n\n    // c. Return ? EnumerateObjectProperties(obj).\n    if (obj instanceof AbstractObjectValue) {\n      if (obj.isSimple()) {\n        return obj;\n      } else {\n        obj.throwIfNotConcrete();\n      }\n      invariant(false);\n    } else {\n      return EnumerateObjectProperties(realm, obj);\n    }\n  } else { // 8. Else,\n    // 1. Assert: iterationKind is iterate.\n    invariant(iterationKind === \"iterate\", \"expected iterationKind to be iterate\");\n\n    // 1. Return ? GetIterator(exprValue).\n    return GetIterator(realm, exprValue);\n  }\n}\n\n// ECMA262 13.7.5.13\nexport function ForInOfBodyEvaluation(realm: Realm, env: LexicalEnvironment, lhs: BabelNodeVariableDeclaration | BabelNodeLVal, stmt: BabelNodeStatement, iterator: ObjectValue, lhsKind: LhsKind, labelSet: ?Array<string>, strictCode: boolean) {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 3. Let destructuring be IsDestructuring of lhs.\n  let destructuring = IsDestructuring(lhs);\n\n  // 4. If destructuring is true and if lhsKind is assignment, then\n  if (destructuring && lhsKind === \"assignment\") {\n    // a. Assert: lhs is a LeftHandSideExpression.\n\n    // b. Let assignmentPattern be the parse of the source text corresponding to lhs using AssignmentPattern as the goal symbol.\n  }\n\n  // 5. Repeat\n  while (true) {\n    // a. Let nextResult be ? IteratorStep(iterator).\n    let nextResult = IteratorStep(realm, iterator);\n\n    // b. If nextResult is false, return NormalCompletion(V).\n    if (!nextResult) return V;\n\n    // c. Let nextValue be ? IteratorValue(nextResult).\n    let nextValue = IteratorValue(realm, nextResult);\n\n    // d. If lhsKind is either assignment or varBinding, then\n    let iterationEnv : LexicalEnvironment;\n    let lhsRef;\n    if (lhsKind === \"assignment\" || lhsKind === \"varBinding\") {\n      // i. If destructuring is false, then\n      if (!destructuring) {\n        // 1. Let lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)\n        lhsRef = env.evaluateCompletion(lhs, strictCode);\n      }\n    } else { // e. Else,\n      // i. Assert: lhsKind is lexicalBinding.\n      invariant(lhsKind === \"lexicalBinding\", \"expected lhsKind to be lexicalBinding\");\n      invariant(lhs.type === \"VariableDeclaration\");\n\n      // ii. Assert: lhs is a ForDeclaration.\n\n      // iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).\n      iterationEnv = NewDeclarativeEnvironment(realm, oldEnv);\n\n      // iv. Perform BindingInstantiation for lhs passing iterationEnv as the argument.\n      BindingInstantiation(realm, lhs, iterationEnv);\n\n      // v. Set the running execution context's LexicalEnvironment to iterationEnv.\n      realm.getRunningContext().lexicalEnvironment = iterationEnv;\n      env = iterationEnv;\n\n      // vi. If destructuring is false, then\n      if (!destructuring) {\n        let names = BoundNames(realm, lhs);\n\n        // 1. Assert: lhs binds a single name.\n        invariant(names.length === 1, \"expected single name\");\n\n        // 2. Let lhsName be the sole element of BoundNames of lhs.\n        let lhsName = names[0];\n\n        // 3. Let lhsRef be ! ResolveBinding(lhsName).\n        lhsRef = ResolveBinding(realm, lhsName, strictCode);\n      }\n    }\n\n    // f. If destructuring is false, then\n    let status;\n    try {\n      if (!destructuring) {\n        // i. If lhsRef is an abrupt completion, then\n        if (lhsRef instanceof AbruptCompletion) {\n          // 1. Let status be lhsRef.\n          status = lhsRef;\n        } else if (lhsKind === \"lexicalBinding\") { // ii. Else if lhsKind is lexicalBinding, then\n          // 1. Let status be InitializeReferencedBinding(lhsRef, nextValue).\n          invariant(lhsRef instanceof Reference);\n          status = InitializeReferencedBinding(realm, lhsRef, nextValue);\n        } else { // iii. Else,\n          // 1. Let status be PutValue(lhsRef, nextValue).\n          invariant(lhsRef !== undefined);\n          status = PutValue(realm, lhsRef, nextValue);\n        }\n      } else { // g. Else,\n        // i. If lhsKind is assignment, then\n        if (lhsKind === \"assignment\") {\n          // 1. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using nextValue as the argument.\n        } else if (lhsKind === \"varBinding\") { // ii. Else if lhsKind is varBinding, then\n          // 1. Assert: lhs is a ForBinding.\n\n          // 2. Let status be the result of performing BindingInitialization for lhs passing nextValue and undefined as the arguments.\n          status = BindingInitialization(realm, lhs, nextValue, undefined);\n        } else { // iii. Else,\n          // 1. Assert: lhsKind is lexicalBinding.\n          invariant(lhsKind === \"lexicalBinding\");\n\n          // 2. Assert: lhs is a ForDeclaration.\n\n          // 3. Let status be the result of performing BindingInitialization for lhs passing nextValue and iterationEnv as arguments.\n          invariant(iterationEnv !== undefined);\n          status = BindingInitialization(realm, lhs, nextValue, iterationEnv);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        status = e;\n      } else {\n        throw e;\n      }\n    }\n\n    // h. If status is an abrupt completion, then\n    if (status instanceof AbruptCompletion) {\n      // i. Set the running execution context's LexicalEnvironment to oldEnv.\n      realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n      // ii. Return ? IteratorClose(iterator, status).\n      throw IteratorClose(realm, iterator, status);\n    }\n\n    // i. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n\n    // j. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    env = oldEnv;\n\n    // k. If LoopContinues(result, labelSet) is false, return ? IteratorClose(iterator, UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      result = UpdateEmpty(realm, result, V);\n      invariant(result instanceof AbruptCompletion);\n      throw IteratorClose(realm, iterator, result);\n    }\n\n    // l. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n  }\n\n  invariant(false);\n}\n\n// ECMA262 13.7.5.11\nexport default function (ast: BabelNodeForOfStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm, labelSet: ?Array<string>): Value | Reference {\n  let { left, right, body } = ast;\n\n  if (left.type === \"VariableDeclaration\") {\n    if (left.kind === \"var\") { // for (var ForBinding o fAssignmentExpression) Statement\n      // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n      keyResult = keyResult.throwIfNotConcreteObject();\n\n      // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left.declarations[0].id, body, keyResult, \"varBinding\", labelSet, strictCode);\n    } else { // for (ForDeclaration of AssignmentExpression) Statement\n      // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, BoundNames(realm, left), right, \"iterate\", strictCode);\n      keyResult = keyResult.throwIfNotConcreteObject();\n\n      // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n    }\n  } else { // for (LeftHandSideExpression of AssignmentExpression) Statement\n    // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n    let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n    keyResult = keyResult.throwIfNotConcreteObject();\n\n    // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n    return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n  }\n}\n"]}