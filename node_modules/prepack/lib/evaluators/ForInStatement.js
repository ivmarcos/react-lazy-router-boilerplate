"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

// ECMA262 13.7.5.11


exports.default = function (ast, strictCode, env, realm, labelSet) {
  var left = ast.left,
      right = ast.right,
      body = ast.body;


  try {
    if (left.type === "VariableDeclaration") {
      if (left.kind === "var") {
        // for (var ForBinding in Expression) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        var keyResult = (0, _ForOfStatement.ForInOfHeadEvaluation)(realm, env, [], right, "enumerate", strictCode);

        if (keyResult instanceof _index3.AbstractObjectValue) {
          return emitResidualLoopIfSafe(ast, strictCode, env, realm, left, keyResult, body);
        }

        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).
        return (0, _ForOfStatement.ForInOfBodyEvaluation)(realm, env, left.declarations[0].id, body, keyResult, "varBinding", labelSet, strictCode);
      } else {
        // for (ForDeclaration in Expression) Statement
        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).
        var _keyResult = (0, _ForOfStatement.ForInOfHeadEvaluation)(realm, env, (0, _index2.BoundNames)(realm, left), right, "enumerate", strictCode);
        _keyResult = _keyResult.throwIfNotConcreteObject();

        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).
        return (0, _ForOfStatement.ForInOfBodyEvaluation)(realm, env, left, body, _keyResult, "lexicalBinding", labelSet, strictCode);
      }
    } else {
      // for (LeftHandSideExpression in Expression) Statement
      // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
      var _keyResult2 = (0, _ForOfStatement.ForInOfHeadEvaluation)(realm, env, [], right, "enumerate", strictCode);
      _keyResult2 = _keyResult2.throwIfNotConcreteObject();

      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).
      return (0, _ForOfStatement.ForInOfBodyEvaluation)(realm, env, left, body, _keyResult2, "assignment", labelSet, strictCode);
    }
  } catch (e) {
    if (e instanceof _completions.BreakCompletion) {
      if (!e.target) return (0, _index2.UpdateEmpty)(realm, e, realm.intrinsics.undefined).value;
    }
    throw e;
  }
};

var _completions = require("../completions.js");

var _index = require("../domains/index.js");

var _environment = require("../environment.js");

var _ForOfStatement = require("./ForOfStatement.js");

var _index2 = require("../methods/index.js");

var _index3 = require("../values/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function emitResidualLoopIfSafe(ast, strictCode, env, realm, lh, ob, body) {
  var oldEnv = realm.getRunningContext().lexicalEnvironment;
  var blockEnv = (0, _index2.NewDeclarativeEnvironment)(realm, oldEnv);
  realm.getRunningContext().lexicalEnvironment = blockEnv;
  try {
    var envRec = blockEnv.environmentRecord;
    (0, _invariant2.default)(envRec instanceof _environment.DeclarativeEnvironmentRecord, "expected declarative environment record");
    var absStr = realm.createAbstract(new _index.TypesDomain(_index3.StringValue), _index.ValuesDomain.topVal, [], t.stringLiteral("never used"));
    var boundName = void 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _index2.BoundNames)(realm, lh)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var n = _step.value;

        (0, _invariant2.default)(boundName === undefined);
        boundName = t.identifier(n);
        envRec.CreateMutableBinding(n, false);
        envRec.InitializeBinding(n, absStr);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _realm$partially_eval = realm.partially_evaluate_node(body, strictCode, blockEnv),
        _realm$partially_eval2 = _slicedToArray(_realm$partially_eval, 5),
        compl = _realm$partially_eval2[0],
        gen = _realm$partially_eval2[1],
        bindings = _realm$partially_eval2[2],
        properties = _realm$partially_eval2[3],
        createdObj = _realm$partially_eval2[4];

    if (compl instanceof _index3.Value && gen.body.length === 0 && bindings.size === 0 && properties.size === 1) {
      (0, _invariant2.default)(createdObj.size === 0); // or there will be more than one property
      var targetObject = void 0;
      var sourceObject = void 0;
      properties.forEach(function (desc, key, map) {
        if (key.object.unknownProperty === key) {
          targetObject = key.object;
          (0, _invariant2.default)(desc !== undefined);
          var sourceValue = desc.value;
          if (sourceValue instanceof _index3.AbstractValue) {
            // because sourceValue was written to key.object.unknownProperty it must be that
            var cond = sourceValue.args[0];
            // and because the write always creates a value of this shape
            (0, _invariant2.default)(cond instanceof _index3.AbstractValue && cond.kind === "template for property name condition");
            if (sourceValue.args[2] instanceof _index3.UndefinedValue) {
              // check that the value that was assigned itself came from
              // an expression of the form sourceObject[absStr].
              var mem = sourceValue.args[1];
              while (mem instanceof _index3.AbstractValue) {
                if (mem.kind === "sentinel member expression" && mem.args[0] instanceof _index3.ObjectValue && mem.args[1] === absStr) {
                  sourceObject = mem.args[0];
                  break;
                }
                // check if mem is a test for absStr being equal to a known property
                // if so skip over it until we get to the expression of the form sourceObject[absStr].
                var condition = mem.args[0];
                if (condition instanceof _index3.AbstractValue && condition.kind === "check for known property") {
                  if (condition.args[0] === absStr) {
                    mem = mem.args[2];
                    continue;
                  }
                }
                break;
              }
            }
          }
        }
      });
      if (targetObject !== undefined && sourceObject !== undefined) {
        var oe = ob.values.getElements();
        if (oe.size !== 1) ob.throwIfNotConcreteObject();
        var o = void 0;var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = oe[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var co = _step2.value;
            o = co;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        (0, _invariant2.default)(o !== undefined);
        var generator = realm.generator;(0, _invariant2.default)(generator !== undefined);
        generator.body.push({
          // duplicate args to ensure refcount > 1
          args: [o, targetObject, sourceObject, targetObject, sourceObject],
          buildNode: function buildNode(_ref) {
            var _ref2 = _slicedToArray(_ref, 6),
                obj = _ref2[0],
                tgt = _ref2[1],
                src = _ref2[2],
                obj1 = _ref2[3],
                tgt1 = _ref2[4],
                src1 = _ref2[5];

            (0, _invariant2.default)(boundName !== undefined);
            return t.forInStatement(lh, obj, t.blockStatement([t.expressionStatement(t.assignmentExpression("=", t.memberExpression(tgt, boundName, true), t.memberExpression(src, boundName, true)))]));
          }
        });

        // At this point, we have emitted code to copy over all properties.
        // However, the internal Prepack state of targetObject doesn't represent the copied properties yet.
        // So, we copy all all known properties, and then mark the target object as simple or partial as appropriate.
        // TODO: While correct, this generates inefficient code, which first inlines all known properties, and then copies them over again.

        var template = void 0;
        if (sourceObject instanceof _index3.AbstractObjectValue) template = sourceObject.getTemplate();

        // TODO: The following case kicks in for ForInStatement11.js, but I don't understand why.
        if (sourceObject instanceof _index3.ObjectValue) template = sourceObject;

        if (template !== undefined) {
          (0, _invariant2.default)(template.properties);
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = template.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  key = _step3$value[0],
                  binding = _step3$value[1];

              if (binding === undefined || binding.descriptor === undefined) continue; // deleted
              (0, _invariant2.default)(binding.descriptor !== undefined);
              (0, _invariant2.default)(binding.descriptor.value !== undefined);
              targetObject.$Set(key, binding.descriptor.value, targetObject);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }

        // TODO: All other properties of the target object now have unknown values and those properties must be invalidated.
        if (!targetObject.isSimple()) targetObject.makePartial();

        return realm.intrinsics.undefined;
      }
    }
  } finally {
    // 6. Set the running execution context's LexicalEnvironment to oldEnv.
    realm.getRunningContext().lexicalEnvironment = oldEnv;
  }

  ob.throwIfNotConcreteObject();
  return realm.intrinsics.undefined;
}
//# sourceMappingURL=ForInStatement.js.map