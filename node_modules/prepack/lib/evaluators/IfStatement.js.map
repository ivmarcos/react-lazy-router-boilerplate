{"version":3,"sources":["../../src/evaluators/IfStatement.js"],"names":["evaluate","evaluateWithAbstractConditional","ast","strictCode","env","realm","exprRef","test","exprValue","stmtCompletion","evaluateCompletion","consequent","alternate","intrinsics","undefined","mightNotBeObject","condValue","partially_evaluate_node","compl1","gen1","bindings1","properties1","createdObj1","compl2","gen2","bindings2","properties2","createdObj2","joinedEffects","completion","capture_effects","apply_effects"],"mappings":";;;;;;ypBAAA;;;;;;;;;QAqBgBA,Q,GAAAA,Q;QAuCAC,+B,GAAAA,+B;;AAjDhB;;AAEA;;AAEA;;AACA;;AACA;;AAEA;;;;;;AAEO,SAASD,QAAT,CACHE,GADG,EACwBC,UADxB,EAC6CC,GAD7C,EAEHC,KAFG,EAE2C;AAChD;AACA,MAAIC,UAAUF,IAAIJ,QAAJ,CAAaE,IAAIK,IAAjB,EAAuBJ,UAAvB,CAAd;AACA;AACA,MAAIK,YAAY,sBAASH,KAAT,EAAgBC,OAAhB,CAAhB;;AAEA,MAAIE,yCAAJ,EAAwC;AACtC,QAAIC,uBAAJ;AACA,QAAI,uBAAUJ,KAAV,EAAiBG,SAAjB,CAAJ,EAAiC;AAC/B;AACAC,uBAAiBL,IAAIM,kBAAJ,CAAuBR,IAAIS,UAA3B,EAAuCR,UAAvC,CAAjB;AACD,KAHD,MAGO;AACL,UAAID,IAAIU,SAAR;AACE;AACAH,yBAAiBL,IAAIM,kBAAJ,CAAuBR,IAAIU,SAA3B,EAAsCT,UAAtC,CAAjB,CAFF;AAIE;AACAM,yBAAiBJ,MAAMQ,UAAN,CAAiBC,SAAlC;AACH;AACD;AACA,QAAIL,gDAAJ,EACE,OAAOA,cAAP;AACFA,qBAAiB,yBAAYJ,KAAZ,EAAmBI,cAAnB,EAAmCJ,MAAMQ,UAAN,CAAiBC,SAApD,CAAjB;AACA,QAAIL,uDAAJ,EAAgD;AAC9C,YAAMA,cAAN;AACD;AACD,WAAOA,cAAP;AACD;AACD,2BAAUD,yCAAV;;AAEA,MAAI,CAACA,UAAUO,gBAAV,EAAL,EAAmC;AACjC,WAAOX,IAAIJ,QAAJ,CAAaE,IAAIS,UAAjB,EAA6BR,UAA7B,CAAP;AACD,GAFD,MAEO;AACL,WAAOF,gCAAgCO,SAAhC,EAA2CN,IAAIS,UAA/C,EAA2DT,IAAIU,SAA/D,EAA0ET,UAA1E,EAAsFC,GAAtF,EAA2FC,KAA3F,CAAP;AACD;AACF;;AAEM,SAASJ,+BAAT,CAAyCe,SAAzC,EACHL,UADG,EACoBC,SADpB,EAC2CT,UAD3C,EAEHC,GAFG,EAEsBC,KAFtB,EAE0E;AAC/E;AAD+E,8BAG7EA,MAAMY,uBAAN,CAA8BN,UAA9B,EAA0CR,UAA1C,EAAsDC,GAAtD,CAH6E;AAAA;AAAA,MAE1Ec,MAF0E;AAAA,MAElEC,IAFkE;AAAA,MAE5DC,SAF4D;AAAA,MAEjDC,WAFiD;AAAA,MAEpCC,WAFoC;;AAAA,aAM7EV,YACEP,MAAMY,uBAAN,CAA8BL,SAA9B,EAAyCT,UAAzC,EAAqDC,GAArD,CADF,GAEE,oCAAwBC,KAAxB,CAR2E;AAAA;AAAA,MAK1EkB,MAL0E;AAAA,MAKlEC,IALkE;AAAA,MAK5DC,SAL4D;AAAA,MAKjDC,WALiD;AAAA,MAKpCC,WALoC;;AAU/E;AACA;;;AACA,MAAIC,gBACF,yBAAYvB,KAAZ,EAAmBW,SAAnB,EACE,CAACE,MAAD,EAASC,IAAT,EAAeC,SAAf,EAA0BC,WAA1B,EAAuCC,WAAvC,CADF,EAEE,CAACC,MAAD,EAASC,IAAT,EAAeC,SAAf,EAA0BC,WAA1B,EAAuCC,WAAvC,CAFF,CADF;AAIA,MAAIE,aAAaD,cAAc,CAAd,CAAjB;AACA,MAAIC,mDAAJ,EAA4C;AAC1C;AACA;AACA;AACA;AACAxB,UAAMyB,eAAN;AACD;AACD;AACA;AACAzB,QAAM0B,aAAN,CAAoBH,aAApB;;AAEA;AACA,MAAIC,mDAAJ,EAA4C,MAAMA,UAAN;AAC5C,2BAAUA,uDAA0CA,kCAA1C,IAAyEA,4CAAnF;AACA,SAAOA,UAAP;AACD","file":"IfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbruptCompletion, Completion, NormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { GetValue, joinEffects, ToBoolean, UpdateEmpty } from \"../methods/index.js\";\nimport type { BabelNode, BabelNodeIfStatement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport function evaluate (\n    ast: BabelNodeIfStatement, strictCode: boolean, env: LexicalEnvironment,\n    realm: Realm): Completion | Value | Reference {\n  // 1. Let exprRef be the result of evaluating Expression\n  let exprRef = env.evaluate(ast.test, strictCode);\n  // 2. Let exprValue be ToBoolean(? GetValue(exprRef))\n  let exprValue = GetValue(realm, exprRef);\n\n  if (exprValue instanceof ConcreteValue) {\n    let stmtCompletion;\n    if (ToBoolean(realm, exprValue)) {\n      // 3.a. Let stmtCompletion be the result of evaluating the first Statement\n      stmtCompletion = env.evaluateCompletion(ast.consequent, strictCode);\n    } else {\n      if (ast.alternate)\n        // 4.a. Let stmtCompletion be the result of evaluating the second Statement\n        stmtCompletion = env.evaluateCompletion(ast.alternate, strictCode);\n      else\n        // 3 (of the if only statement). Return NormalCompletion(undefined)\n        stmtCompletion = realm.intrinsics.undefined;\n    }\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    if (stmtCompletion instanceof Reference)\n      return stmtCompletion;\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    return stmtCompletion;\n  }\n  invariant(exprValue instanceof AbstractValue);\n\n  if (!exprValue.mightNotBeObject()) {\n    return env.evaluate(ast.consequent, strictCode);\n  } else {\n    return evaluateWithAbstractConditional(exprValue, ast.consequent, ast.alternate, strictCode, env, realm);\n  }\n}\n\nexport function evaluateWithAbstractConditional(condValue: AbstractValue,\n    consequent: BabelNode, alternate: ?BabelNode, strictCode: boolean,\n    env: LexicalEnvironment, realm: Realm): NormalCompletion | Value | Reference {\n  // Evaluate consequent and alternate in sandboxes and get their effects.\n  let [compl1, gen1, bindings1, properties1, createdObj1] =\n    realm.partially_evaluate_node(consequent, strictCode, env);\n\n  let [compl2, gen2, bindings2, properties2, createdObj2] =\n    alternate ?\n      realm.partially_evaluate_node(alternate, strictCode, env) :\n      construct_empty_effects(realm);\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of condValue.\n  let joinedEffects =\n    joinEffects(realm, condValue,\n      [compl1, gen1, bindings1, properties1, createdObj1],\n      [compl2, gen2, bindings2, properties2, createdObj2]);\n  let completion = joinedEffects[0];\n  if (completion instanceof NormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    realm.capture_effects();\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.apply_effects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof NormalCompletion || completion instanceof Value || completion instanceof Reference);\n  return completion;\n}\n"]}