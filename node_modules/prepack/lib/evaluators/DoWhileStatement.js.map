{"version":3,"sources":["../../src/evaluators/DoWhileStatement.js"],"names":["ast","strictCode","env","realm","labelSet","body","test","V","intrinsics","undefined","stmt","evaluateCompletion","target","value","resultValue","exprRef","evaluate","exprValue"],"mappings":";;;;;;kBAsBe,UAAUA,GAAV,EAA0CC,UAA1C,EAA+DC,GAA/D,EAAwFC,KAAxF,EAAsGC,QAAtG,EAAmJ;AAAA,MAC1JC,IAD0J,GAC3IL,GAD2I,CAC1JK,IAD0J;AAAA,MACpJC,IADoJ,GAC3IN,GAD2I,CACpJM,IADoJ;;AAGhK;;AACA,MAAIC,IAAIJ,MAAMK,UAAN,CAAiBC,SAAzB;;AAEA;AACA,SAAO,IAAP,EAAa;AACX;AACA,QAAIC,OAAOR,IAAIS,kBAAJ,CAAuBN,IAAvB,EAA6BJ,UAA7B,CAAX;;AAEA;AACA,QAAI,mCAAcE,KAAd,EAAqBO,IAArB,EAA2BN,QAA3B,MAAyC,KAA7C,EAAoD;AAClD,+BAAUM,6CAAV;AACA;AACA,UAAIA,4CAAJ,EAAqC;AACnC,YAAI,CAACA,KAAKE,MAAV,EACE,OAAQ,yBAAYT,KAAZ,EAAmBO,IAAnB,EAAyBH,CAAzB,CAAD,CAAmCM,KAA1C;AACH;AACD,YAAM,yBAAYV,KAAZ,EAAmBO,IAAnB,EAAyBH,CAAzB,CAAN;AACD;;AAED;AACA,QAAIO,cAAc,4CAAuBX,KAAvB,EAA8BO,IAA9B,CAAlB;AACA,QAAI,EAAEI,wCAAF,CAAJ,EAA0CP,IAAIO,WAAJ;;AAE1C;AACA,QAAIC,UAAUb,IAAIc,QAAJ,CAAaV,IAAb,EAAmBL,UAAnB,CAAd;;AAEA;AACA,QAAIgB,YAAY,sBAASd,KAAT,EAAgBY,OAAhB,CAAhB;;AAEA;AACA,QAAI,8BAAiBZ,KAAjB,EAAwBc,SAAxB,MAAuC,KAA3C,EAAkD,OAAOV,CAAP;AACnD;;AAED,2BAAU,KAAV;AACD,C;;AA5CD;;AACA;;AACA;;AACA;;AACA","file":"DoWhileStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport { EmptyValue } from \"../values/index.js\";\nimport { ToBooleanPartial, GetValue, UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { AbruptCompletion, BreakCompletion } from \"../completions.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeDoWhileStatement } from \"babel-types\";\n\nexport default function (ast: BabelNodeDoWhileStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm, labelSet: ?Array<string>): Value | Reference {\n  let { body, test } = ast;\n\n  // 1. Let V be undefined.\n  let V = realm.intrinsics.undefined;\n\n  // 2. Repeat\n  while (true) {\n    // a. Let stmt be the result of evaluating Statement.\n    let stmt = env.evaluateCompletion(body, strictCode);\n\n    // b. If LoopContinues(stmt, labelSet) is false, return Completion(UpdateEmpty(stmt, V)).\n    if (LoopContinues(realm, stmt, labelSet) === false) {\n      invariant(stmt instanceof AbruptCompletion);\n      // ECMA262 13.1.7\n      if (stmt instanceof BreakCompletion) {\n        if (!stmt.target)\n          return (UpdateEmpty(realm, stmt, V): any).value;\n      }\n      throw UpdateEmpty(realm, stmt, V);\n    }\n\n    // c. If stmt.[[Value]] is not empty, let V be stmt.[[Value]].\n    let resultValue = InternalGetResultValue(realm, stmt);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n    // d. Let exprRef be the result of evaluating Expression.\n    let exprRef = env.evaluate(test, strictCode);\n\n    // e. Let exprValue be ? GetValue(exprRef).\n    let exprValue = GetValue(realm, exprRef);\n\n    // f. If ToBoolean(exprValue) is false, return NormalCompletion(V).\n    if (ToBooleanPartial(realm, exprValue) === false) return V;\n  }\n\n  invariant(false);\n}\n"]}