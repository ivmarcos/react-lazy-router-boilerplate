{"version":3,"sources":["../../src/evaluators/ForStatement.js"],"names":["CreatePerIterationEnvironment","ast","strictCode","env","realm","labelSet","init","test","update","body","type","kind","varDcl","evaluate","ForBodyEvaluation","oldEnv","loopEnv","loopEnvRec","environmentRecord","isConst","boundNames","dn","CreateImmutableBinding","CreateMutableBinding","getRunningContext","lexicalEnvironment","forDcl","evaluateCompletion","perIterationLets","bodyResult","exprRef","perIterationBindings","length","lastIterationEnv","lastIterationEnvRec","outer","parent","thisIterationEnv","thisIterationEnvRec","bn","lastValue","GetBindingValue","InitializeBinding","intrinsics","undefined","increment","stmt","V","testRef","testValue","result","target","value","resultValue","incRef"],"mappings":";;;;;QAqBgBA,6B,GAAAA,6B;;kBA0FD,UAAUC,GAAV,EAAsCC,UAAtC,EAA2DC,GAA3D,EAAoFC,KAApF,EAAkGC,QAAlG,EAA+I;AAAA,MACtJC,IADsJ,GACzHL,GADyH,CACtJK,IADsJ;AAAA,MAChJC,IADgJ,GACzHN,GADyH,CAChJM,IADgJ;AAAA,MAC1IC,MAD0I,GACzHP,GADyH,CAC1IO,MAD0I;AAAA,MAClIC,IADkI,GACzHR,GADyH,CAClIQ,IADkI;;;AAG5J,MAAIH,QAAQA,KAAKI,IAAL,KAAc,qBAA1B,EAAiD;AAC/C,QAAIJ,KAAKK,IAAL,KAAc,KAAlB,EAAyB;AAAE;AACzB;AACA,UAAIC,SAAST,IAAIU,QAAJ,CAAaP,IAAb,EAAmBJ,UAAnB,CAAb;;AAEA;AACAU;;AAEA;AACA,aAAOE,kBAAkBV,KAAlB,EAAyBG,IAAzB,EAA+BC,MAA/B,EAAuCC,IAAvC,EAA6C,EAA7C,EAAiDJ,QAAjD,EAA2DH,UAA3D,CAAP;AACD,KATD,MASO;AAAE;AACP;AACA,UAAIa,SAASZ,GAAb;;AAEA;AACA,UAAIa,UAAU,uCAA0BZ,KAA1B,EAAiCW,MAAjC,CAAd;;AAEA;AACA,UAAIE,aAAaD,QAAQE,iBAAzB;;AAEA;AACA,UAAIC,UAAUb,KAAKK,IAAL,KAAc,OAA5B;;AAEA;AACA,UAAIS,aAAa,wBAAWhB,KAAX,EAAkBE,IAAlB,CAAjB;;AAEA;AAhBK;AAAA;AAAA;;AAAA;AAiBL,8BAAec,UAAf,mIAA2B;AAAA,cAAlBC,EAAkB;;AACzB;AACA,cAAIF,OAAJ,EAAa;AACX;AACAF,uBAAWK,sBAAX,CAAkCD,EAAlC,EAAsC,IAAtC;AACD,WAHD,MAGO;AAAE;AACP;AACAJ,uBAAWM,oBAAX,CAAgCF,EAAhC,EAAoC,KAApC;AACD;AACF;;AAED;AA5BK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6BLjB,YAAMoB,iBAAN,GAA0BC,kBAA1B,GAA+CT,OAA/C;;AAEA;AACA,UAAIU,SAASV,QAAQW,kBAAR,CAA2BrB,IAA3B,EAAiCJ,UAAjC,CAAb;;AAEA;AACA,UAAIwB,+CAAJ,EAAwC;AACtC;AACAtB,cAAMoB,iBAAN,GAA0BC,kBAA1B,GAA+CV,MAA/C;;AAEA;AACA,cAAMW,MAAN;AACD;;AAED;AACA,UAAIE,mBAAmB,CAACT,OAAD,GAAWC,UAAX,GAAwB,EAA/C;;AAEA,UAAIS,mBAAJ;AACA,UAAI;AACF;AACAA,qBAAaf,kBAAkBV,KAAlB,EAAyBG,IAAzB,EAA+BC,MAA/B,EAAuCC,IAAvC,EAA6CmB,gBAA7C,EAA+DvB,QAA/D,EAAyEH,UAAzE,CAAb;AACD,OAHD,SAGU;AACR;AACAE,cAAMoB,iBAAN,GAA0BC,kBAA1B,GAA+CV,MAA/C;AACD;AACD;AACA,aAAOc,UAAP;AACD;AACF,GAnED,MAmEO;AAAE;AACP;AACA,QAAIvB,IAAJ,EAAU;AACR;AACA,UAAIwB,UAAU3B,IAAIU,QAAJ,CAAaP,IAAb,EAAmBJ,UAAnB,CAAd;;AAEA;AACA,4BAASE,KAAT,EAAgB0B,OAAhB;AACD;;AAED;AACA,WAAOhB,kBAAkBV,KAAlB,EAAyBG,IAAzB,EAA+BC,MAA/B,EAAuCC,IAAvC,EAA6C,EAA7C,EAAiDJ,QAAjD,EAA2DH,UAA3D,CAAP;AACD;AACF,C;;AArLD;;AACA;;AACA;;AACA;;AACA;;;;;;AAGA;AACO,SAASF,6BAAT,CAAuCI,KAAvC,EAAqD2B,oBAArD,EAA0F;AAC/F;AACA,MAAIA,qBAAqBC,MAArB,GAA8B,CAAlC,EAAqC;AACnC;AACA,QAAIC,mBAAmB7B,MAAMoB,iBAAN,GAA0BC,kBAAjD;AACA;AACA,QAAIS,sBAAsBD,iBAAiBf,iBAA3C;AACA;AACA,QAAIiB,QAAQF,iBAAiBG,MAA7B;AACA;AACA,6BAAUD,UAAU,IAApB;AACA;AACA,QAAIE,mBAAmB,uCAA0BjC,KAA1B,EAAiC+B,KAAjC,CAAvB;AACA;AACA,QAAIG,sBAAsBD,iBAAiBnB,iBAA3C;AACA;AAbmC;AAAA;AAAA;;AAAA;AAcnC,2BAAea,oBAAf,8HAAqC;AAAA,YAA5BQ,EAA4B;;AACnC;AACAD,4BAAoBf,oBAApB,CAAyCgB,EAAzC,EAA6C,KAA7C;AACA;AACA,YAAIC,YAAYN,oBAAoBO,eAApB,CAAoCF,EAApC,EAAwC,IAAxC,CAAhB;AACA;AACAD,4BAAoBI,iBAApB,CAAsCH,EAAtC,EAA0CC,SAA1C;AACD;AACD;AAtBmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuBnCpC,UAAMoB,iBAAN,GAA0BC,kBAA1B,GAA+CY,gBAA/C;AACD;AACD;AACA,SAAOjC,MAAMuC,UAAN,CAAiBC,SAAxB;AACD;;AAED;AApDA;;;;;;;;;AAqDA,SAAS9B,iBAAT,CAA2BV,KAA3B,EAAyCG,IAAzC,EAA+CsC,SAA/C,EAA0DC,IAA1D,EAAgEf,oBAAhE,EAAqG1B,QAArG,EAA+GH,UAA/G,EAA2I;AACzI;AACA,MAAI6C,IAAW3C,MAAMuC,UAAN,CAAiBC,SAAhC;;AAEA;AACA5C,gCAA8BI,KAA9B,EAAqC2B,oBAArC;AACA,MAAI5B,MAAMC,MAAMoB,iBAAN,GAA0BC,kBAApC;;AAEA;AACA,SAAO,IAAP,EAAa;AACX;AACA,QAAIlB,IAAJ,EAAU;AACR;AACA,UAAIyC,UAAU7C,IAAIU,QAAJ,CAAaN,IAAb,EAAmBL,UAAnB,CAAd;;AAEA;AACA,UAAI+C,YAAY,sBAAS7C,KAAT,EAAgB4C,OAAhB,CAAhB;;AAEA;AACA,UAAI,CAAC,8BAAiB5C,KAAjB,EAAwB6C,SAAxB,CAAL,EAAyC,OAAOF,CAAP;AAC1C;;AAED;AACA,QAAIG,SAAS/C,IAAIwB,kBAAJ,CAAuBmB,IAAvB,EAA6B5C,UAA7B,CAAb;;AAEA;AACA,QAAI,CAAC,mCAAcE,KAAd,EAAqB8C,MAArB,EAA6B7C,QAA7B,CAAL,EAA6C;AAC3C,+BAAU6C,+CAAV;AACA;AACA,UAAIA,8CAAJ,EAAuC;AACrC,YAAI,CAACA,OAAOC,MAAZ,EACE,OAAQ,yBAAY/C,KAAZ,EAAmB8C,MAAnB,EAA2BH,CAA3B,CAAD,CAAqCK,KAA5C;AACH;AACD,YAAM,yBAAYhD,KAAZ,EAAmB8C,MAAnB,EAA2BH,CAA3B,CAAN;AACD;;AAED;AACA,QAAIM,cAAc,4CAAuBjD,KAAvB,EAA8B8C,MAA9B,CAAlB;AACA,QAAI,EAAEG,wCAAF,CAAJ,EAA0CN,IAAIM,WAAJ;;AAE1C;AACArD,kCAA8BI,KAA9B,EAAqC2B,oBAArC;AACA5B,UAAMC,MAAMoB,iBAAN,GAA0BC,kBAAhC;;AAEA;AACA,QAAIoB,SAAJ,EAAe;AACb;AACA,UAAIS,SAASnD,IAAIU,QAAJ,CAAagC,SAAb,EAAwB3C,UAAxB,CAAb;;AAEA;AACA,4BAASE,KAAT,EAAgBkD,MAAhB;AACD;AACF;;AAED,2BAAU,KAAV;AACD;;AAED","file":"ForStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment, Reference } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\nimport { Value, EmptyValue } from \"../values/index.js\";\nimport { AbruptCompletion, BreakCompletion } from \"../completions.js\";\nimport { BoundNames, NewDeclarativeEnvironment, GetValue, ToBooleanPartial, UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue } from \"./ForOfStatement.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeForStatement } from \"babel-types\";\n\n// ECMA262 13.7.4.9\nexport function CreatePerIterationEnvironment(realm: Realm, perIterationBindings: Array<string>) {\n  // 1. If perIterationBindings has any elements, then\n  if (perIterationBindings.length > 0) {\n    // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.\n    let lastIterationEnv = realm.getRunningContext().lexicalEnvironment;\n    // b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord.\n    let lastIterationEnvRec = lastIterationEnv.environmentRecord;\n    // c. Let outer be lastIterationEnv's outer environment reference.\n    let outer = lastIterationEnv.parent;\n    // d. Assert: outer is not null.\n    invariant(outer !== null);\n    // e. Let thisIterationEnv be NewDeclarativeEnvironment(outer).\n    let thisIterationEnv = NewDeclarativeEnvironment(realm, outer);\n    // f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord.\n    let thisIterationEnvRec = thisIterationEnv.environmentRecord;\n    // g. For each element bn of perIterationBindings do,\n    for (let bn of perIterationBindings) {\n      // i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false).\n      thisIterationEnvRec.CreateMutableBinding(bn, false);\n      // ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).\n      let lastValue = lastIterationEnvRec.GetBindingValue(bn, true);\n      // iii.Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).\n      thisIterationEnvRec.InitializeBinding(bn, lastValue);\n    }\n    // h. Set the running execution context's LexicalEnvironment to thisIterationEnv.\n    realm.getRunningContext().lexicalEnvironment = thisIterationEnv;\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 13.7.4.8\nfunction ForBodyEvaluation(realm: Realm, test, increment, stmt, perIterationBindings: Array<string>, labelSet, strictCode: boolean): Value {\n  // 1. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n  CreatePerIterationEnvironment(realm, perIterationBindings);\n  let env = realm.getRunningContext().lexicalEnvironment;\n\n  // 3. Repeat\n  while (true) {\n    // a. If test is not [empty], then\n    if (test) {\n      // i. Let testRef be the result of evaluating test.\n      let testRef = env.evaluate(test, strictCode);\n\n      // ii. Let testValue be ? GetValue(testRef).\n      let testValue = GetValue(realm, testRef);\n\n      // iii. If ToBoolean(testValue) is false, return NormalCompletion(V).\n      if (!ToBooleanPartial(realm, testValue)) return V;\n    }\n\n    // b. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n\n    // c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      // ECMA262 13.1.7\n      if (result instanceof BreakCompletion) {\n        if (!result.target)\n          return (UpdateEmpty(realm, result, V): any).value;\n      }\n      throw UpdateEmpty(realm, result, V);\n    }\n\n    // d. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n    // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n    CreatePerIterationEnvironment(realm, perIterationBindings);\n    env = realm.getRunningContext().lexicalEnvironment;\n\n    // f. If increment is not [empty], then\n    if (increment) {\n      // i. Let incRef be the result of evaluating increment.\n      let incRef = env.evaluate(increment, strictCode);\n\n      // ii. Perform ? GetValue(incRef).\n      GetValue(realm, incRef);\n    }\n  }\n\n  invariant(false);\n}\n\n// ECMA262 13.7.4.7\nexport default function (ast: BabelNodeForStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm, labelSet: ?Array<string>): Value | Reference {\n  let { init, test, update, body } = ast;\n\n  if (init && init.type === \"VariableDeclaration\") {\n    if (init.kind === \"var\") { // for (var VariableDeclarationList; Expression; Expression) Statement\n      // 1. Let varDcl be the result of evaluating VariableDeclarationList.\n      let varDcl = env.evaluate(init, strictCode);\n\n      // 2. ReturnIfAbrupt(varDcl).\n      varDcl;\n\n      // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).\n      return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n    } else { // for (LexicalDeclaration Expression; Expression) Statement\n      // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n      let oldEnv = env;\n\n      // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).\n      let loopEnv = NewDeclarativeEnvironment(realm, oldEnv);\n\n      // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.\n      let loopEnvRec = loopEnv.environmentRecord;\n\n      // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.\n      let isConst = init.kind === \"const\";\n\n      // 5. Let boundNames be the BoundNames of LexicalDeclaration.\n      let boundNames = BoundNames(realm, init);\n\n      // 6. For each element dn of boundNames do\n      for (let dn of boundNames) {\n        // a. If isConst is true, then\n        if (isConst) {\n          // i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).\n          loopEnvRec.CreateImmutableBinding(dn, true);\n        } else { // b. Else,\n          // i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).\n          loopEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // 7. Set the running execution context's LexicalEnvironment to loopEnv.\n      realm.getRunningContext().lexicalEnvironment = loopEnv;\n\n      // 8. Let forDcl be the result of evaluating LexicalDeclaration.\n      let forDcl = loopEnv.evaluateCompletion(init, strictCode);\n\n      // 9. If forDcl is an abrupt completion, then\n      if (forDcl instanceof AbruptCompletion) {\n        // a. Set the running execution context's LexicalEnvironment to oldEnv.\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n        // b. Return Completion(forDcl).\n        throw forDcl;\n      }\n\n      // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».\n      let perIterationLets = !isConst ? boundNames : [];\n\n      let bodyResult;\n      try {\n        // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).\n        bodyResult = ForBodyEvaluation(realm, test, update, body, perIterationLets, labelSet, strictCode);\n      } finally {\n        // 12. Set the running execution context's LexicalEnvironment to oldEnv.\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n      }\n      // 13. Return Completion(bodyResult).\n      return bodyResult;\n    }\n  } else { // for (Expression; Expression; Expression) Statement\n    // 1. If the first Expression is present, then\n    if (init) {\n      // a. Let exprRef be the result of evaluating the first Expression.\n      let exprRef = env.evaluate(init, strictCode);\n\n      // b. Perform ? GetValue(exprRef).\n      GetValue(realm, exprRef);\n    }\n\n    // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).\n    return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n  }\n}\n"]}