{"version":3,"sources":["../../src/evaluators/LabeledStatement.js"],"names":["ast","strictCode","env","realm","newLabelSet","LabelledEvaluation","labelSet","type","labeledAst","label","name","push","normalCompletionStmtResult","body","stmtResult","target","value","kind","evaluate","createErrorThrowCompletion","intrinsics","SyntaxError"],"mappings":";;;;;;kBA+De,UAAUA,GAAV,EAA0CC,UAA1C,EAA+DC,GAA/D,EAAwFC,KAAxF,EAAyH;AACtI;AACA,MAAIC,cAAc,EAAlB;;AAEA;AACA,SAAOC,mBAAmBD,WAAnB,EAAgCJ,GAAhC,EAAqCC,UAArC,EAAiDC,GAAjD,EAAsDC,KAAtD,CAAP;AACD,C;;AAtDD;;AAGA;AACA,SAASE,kBAAT,CAA4BC,QAA5B,EAAqDN,GAArD,EAAqEC,UAArE,EAA0FC,GAA1F,EAAmHC,KAAnH,EAAoJ;AAClJ;AACA,UAAQH,IAAIO,IAAZ;AACE,SAAK,kBAAL;AACE,UAAIC,aAAeR,GAAnB;AACA;AACA,UAAIS,QAAQD,WAAWC,KAAX,CAAiBC,IAA7B;;AAEA;AACAJ,eAASK,IAAT,CAAcF,KAAd;;AAEA;AACA,UAAIG,mCAAJ;AACA,UAAI;AACFA,qCAA6BP,mBAAmBC,QAAnB,EAA6BE,WAAWK,IAAxC,EAA8CZ,UAA9C,EAA0DC,GAA1D,EAA+DC,KAA/D,CAA7B;AACD,OAFD,CAEE,OAAOW,UAAP,EAAmB;AACnB;AACA,YAAIA,sDAAyCA,WAAWC,MAAX,KAAsBN,KAAnE,EAA0E;AACxE;AACAG,uCAA6BE,WAAWE,KAAxC;AACD,SAHD,MAGO;AACL;AACA,gBAAMF,UAAN;AACD;AACF;AACD;AACA,aAAOF,0BAAP;;AAEF,SAAK,qBAAL;AACE,UAAIZ,IAAIiB,IAAJ,KAAa,KAAjB,EAAwB;AACtB,eAAOf,IAAIgB,QAAJ,CAAalB,GAAb,EAAkBC,UAAlB,CAAP;AACD;AACD;AACF,SAAK,qBAAL;AACA,SAAK,kBAAL;AACE,YAAME,MAAMgB,0BAAN,CAAiChB,MAAMiB,UAAN,CAAiBC,WAAlD,EACJrB,IAAIO,IAAJ,GAAW,uBADP,CAAN;;AAGF;AACE,aAAOL,IAAIgB,QAAJ,CAAalB,GAAb,EAAkBC,UAAlB,EAA8BK,QAA9B,CAAP;AArCJ;AAuCD;;AAED;AA9DA","file":"LabeledStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport { BreakCompletion } from \"../completions.js\";\nimport type { BabelNodeLabeledStatement, BabelNode } from \"babel-types\";\n\n// ECMA262 13.13.14\nfunction LabelledEvaluation(labelSet: Array<string>, ast: BabelNode, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  // LabelledStatement:LabelIdentifier:LabelledItem\n  switch (ast.type) {\n    case 'LabeledStatement':\n      let labeledAst = ((ast: any): BabelNodeLabeledStatement);\n      // 1. Let label be the StringValue of LabelIdentifier.\n      let label = labeledAst.label.name;\n\n      // 2. Append label as an element of labelSet.\n      labelSet.push(label);\n\n      // 3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.\n      let normalCompletionStmtResult;\n      try {\n        normalCompletionStmtResult = LabelledEvaluation(labelSet, labeledAst.body, strictCode, env, realm);\n      } catch (stmtResult) {\n        // 4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then\n        if (stmtResult instanceof BreakCompletion && stmtResult.target === label) {\n          // a. Let stmtResult be NormalCompletion(stmtResult.[[Value]]).\n          normalCompletionStmtResult = stmtResult.value;\n        } else {\n          // 5. Return Completion(stmtResult).\n          throw stmtResult;\n        }\n      }\n      // 5. Return Completion(stmtResult).\n      return normalCompletionStmtResult;\n\n    case 'VariableDeclaration':\n      if (ast.kind === 'var') {\n        return env.evaluate(ast, strictCode);\n      }\n      // fall through to throw\n    case 'FunctionDeclaration':\n    case 'ClassDeclaration':\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError,\n        ast.type + \" may not have a label\");\n\n    default:\n      return env.evaluate(ast, strictCode, labelSet);\n  }\n}\n\n// ECMA262 13.13.15\nexport default function (ast: BabelNodeLabeledStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  //1. Let newLabelSet be a new empty List.\n  let newLabelSet = [];\n\n  //2. Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.\n  return LabelledEvaluation(newLabelSet, ast, strictCode, env, realm);\n}\n"]}