"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

exports.default = function (ast, strictCode, env, realm) {
  var expr = env.evaluate(ast.argument, strictCode);

  if (ast.operator === "-") {
    // ECMA262 12.5.7.1

    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Let oldValue be ? ToNumber(? GetValue(expr)).
    var value = (0, _index3.GetValue)(realm, expr);
    if (value instanceof _index.AbstractValue && (0, _index3.IsToNumberPure)(realm, value)) return computeAbstractly(realm, _index.NumberValue, "-", value);
    var oldValue = (0, _index3.ToNumber)(realm, value.throwIfNotConcrete());

    // 3. If oldValue is NaN, return NaN.
    if (isNaN(oldValue)) {
      return realm.intrinsics.NaN;
    }

    // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.
    return new _index.NumberValue(realm, -oldValue);
  } else if (ast.operator === "+") {
    // ECMA262 12.5.6.1

    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Return ? ToNumber(? GetValue(expr)).
    var _value = (0, _index3.GetValue)(realm, expr);
    if (_value instanceof _index.AbstractValue && (0, _index3.IsToNumberPure)(realm, _value)) return computeAbstractly(realm, _index.NumberValue, "+", _value);
    return new _index.NumberValue(realm, (0, _index3.ToNumber)(realm, _value.throwIfNotConcrete()));
  } else if (ast.operator === "~") {
    // ECMA262 12.5.8

    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Let oldValue be ? ToInt32(? GetValue(expr)).
    var _value2 = (0, _index3.GetValue)(realm, expr);
    if (_value2 instanceof _index.AbstractValue && (0, _index3.IsToNumberPure)(realm, _value2)) return computeAbstractly(realm, _index.NumberValue, "~", _value2);
    var _oldValue = (0, _index3.ToInt32)(realm, _value2.throwIfNotConcrete());

    // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.
    return new _index.NumberValue(realm, ~_oldValue);
  } else if (ast.operator === "!") {
    // ECMA262 12.6.9

    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Let oldValue be ToBoolean(? GetValue(expr)).
    var _value3 = (0, _index3.GetValue)(realm, expr);
    if (_value3 instanceof _index.AbstractValue && _value3.mightNotBeObject()) return computeAbstractly(realm, _index.NumberValue, "!", _value3);
    var _oldValue2 = (0, _index3.ToBooleanPartial)(realm, _value3);

    // 3. If oldValue is true, return false.
    if (_oldValue2 === true) return realm.intrinsics.false;

    // 4. Return true.
    return realm.intrinsics.true;
  } else if (ast.operator === "void") {
    // 1. Let expr be the result of evaluating UnaryExpression.
    expr;

    // 2. Perform ? GetValue(expr).
    (0, _index3.GetValue)(realm, expr);

    // 3. Return undefined.
    return realm.intrinsics.undefined;
  } else if (ast.operator === "typeof") {
    // ECMA262 12.6.5

    // 1. Let val be the result of evaluating UnaryExpression.
    var val = expr;

    // 2. If Type(val) is Reference, then
    if (val instanceof _environment.Reference) {
      // a. If IsUnresolvableReference(val) is true, return "undefined".
      if ((0, _index3.IsUnresolvableReference)(realm, val)) {
        return new _index.StringValue(realm, "undefined");
      }
    }

    // 3. Let val be ? GetValue(val).
    val = (0, _index3.GetValue)(realm, val);

    // 4. Return a String according to Table 35.
    if ((0, _index3.IsCallable)(realm, val)) {
      return new _index.StringValue(realm, "function");
    } else {
      var proto = val.getType().prototype;
      if (isInstance(proto, _index.UndefinedValue)) {
        return new _index.StringValue(realm, "undefined");
      } else if (isInstance(proto, _index.NullValue)) {
        return new _index.StringValue(realm, "object");
      } else if (isInstance(proto, _index.StringValue)) {
        return new _index.StringValue(realm, "string");
      } else if (isInstance(proto, _index.BooleanValue)) {
        return new _index.StringValue(realm, "boolean");
      } else if (isInstance(proto, _index.NumberValue)) {
        return new _index.StringValue(realm, "number");
      } else if (isInstance(proto, _index.SymbolValue)) {
        return new _index.StringValue(realm, "symbol");
      } else if (isInstance(proto, _index.ObjectValue)) {
        return new _index.StringValue(realm, "object");
      } else {
        (0, _invariant2.default)(val instanceof _index.AbstractValue);
        return computeAbstractly(realm, _index.StringValue, "typeof", val);
      }
    }
  } else if (ast.operator === "delete") {
    // ECMA262 12.5.3.2

    // 1. Let ref be the result of evaluating UnaryExpression.
    var ref = expr;

    // 2. ReturnIfAbrupt(ref).

    // 3. If Type(ref) is not Reference, return true.
    if (!(ref instanceof _environment.Reference)) return realm.intrinsics.true;

    // 4. If IsUnresolvableReference(ref) is true, then
    if ((0, _index3.IsUnresolvableReference)(realm, ref)) {
      // a. Assert: IsStrictReference(ref) is false.
      (0, _invariant2.default)(!(0, _index3.IsStrictReference)(realm, ref), "did not expect a strict reference");

      // b. Return true.
      return realm.intrinsics.true;
    }

    // 5. If IsPropertyReference(ref) is true, then
    if ((0, _index3.IsPropertyReference)(realm, ref)) {
      // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.
      if ((0, _index3.IsSuperReference)(realm, ref)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);
      }

      // b. Let baseObj be ! ToObject(GetBase(ref)).
      var base = (0, _index3.GetBase)(realm, ref);
      (0, _invariant2.default)(base instanceof _index.Value);
      var baseObj = (0, _index3.ToObjectPartial)(realm, base);

      // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).
      var deleteStatus = baseObj.$Delete((0, _index3.GetReferencedName)(realm, ref));

      // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.
      if (!deleteStatus && (0, _index3.IsStrictReference)(realm, ref)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      // e. Return deleteStatus.
      return new _index.BooleanValue(realm, deleteStatus);
    }

    // 6. Else ref is a Reference to an Environment Record binding,
    // a. Let bindings be GetBase(ref).
    var bindings = (0, _index3.GetBase)(realm, ref);
    (0, _invariant2.default)(bindings instanceof _environment.EnvironmentRecord);

    // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).
    var referencedName = (0, _index3.GetReferencedName)(realm, ref);
    (0, _invariant2.default)(typeof referencedName === "string");
    return new _index.BooleanValue(realm, bindings.DeleteBinding(referencedName));
  }

  throw new Error("unimplemented");
};

var _index = require("../values/index.js");

var _environment = require("../environment.js");

var _index2 = require("../domains/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _index3 = require("../methods/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isInstance(proto, Constructor) {
  return proto instanceof Constructor || proto === Constructor.prototype;
}

function computeAbstractly(realm, type, op, val) {
  return realm.createAbstract(new _index2.TypesDomain(type), _index2.ValuesDomain.topVal, [val], function (_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        node = _ref2[0];

    return t.unaryExpression(op, node);
  });
}
//# sourceMappingURL=UnaryExpression.js.map