{"version":3,"sources":["../../src/evaluators/ArrowFunctionExpression.js"],"names":["ast","strictCode","env","realm","ConciseBody","body","type","t","blockStatement","returnStatement","strict","scope","parameters","params","closure"],"mappings":";;;;;;kBAqBe,UAAUA,GAAV,EAAiDC,UAAjD,EAAsEC,GAAtE,EAA+FC,KAA/F,EAAgI;AAC7I,MAAIC,cAAcJ,IAAIK,IAAtB;AACA,MAAID,YAAYE,IAAZ,KAAqB,gBAAzB,EAA2C;AACzCF,kBAAcG,EAAEC,cAAF,CAAiB,CAACD,EAAEE,eAAF,CAAkBL,WAAlB,CAAD,CAAjB,CAAd;AACD;;AAED;AACA,MAAIM,SAAST,cAAc,sBAASD,IAAIK,IAAb,CAA3B;;AAEA;AACA,MAAIM,QAAQT,GAAZ;;AAEA;AACA,MAAIU,aAAaZ,IAAIa,MAArB;;AAEA;AACA,MAAIC,UAAU,2BAAeX,KAAf,EAAsB,OAAtB,EAA+BS,UAA/B,EAA2CR,WAA3C,EAAwDO,KAAxD,EAA+DD,MAA/D,CAAd;;AAEA;AACA,SAAOI,OAAP;AACD,C;;AA1BD;;AACA;;;;AACA;;IAAYP,C","file":"ArrowFunctionExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport { FunctionCreate } from \"../methods/index.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeArrowFunctionExpression } from \"babel-types\";\n\n// ECMA262 14.2.16\nexport default function (ast: BabelNodeArrowFunctionExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  let ConciseBody = ast.body;\n  if (ConciseBody.type !== \"BlockStatement\") {\n    ConciseBody = t.blockStatement([t.returnStatement(ConciseBody)]);\n  }\n\n  // 1. If the function code for this ArrowFunction is strict mode code, let strict be true. Otherwise let strict be false.\n  let strict = strictCode || IsStrict(ast.body);\n\n  // 2. Let scope be the LexicalEnvironment of the running execution context.\n  let scope = env;\n\n  // 3. Let parameters be CoveredFormalsList of ArrowParameters.\n  let parameters = ast.params;\n\n  // 4. Let closure be FunctionCreate(Arrow, parameters, ConciseBody, scope, strict).\n  let closure = FunctionCreate(realm, \"arrow\", parameters, ConciseBody, scope, strict);\n\n  // 5. Return closure.\n  return closure;\n}\n"]}