{"version":3,"sources":["../../src/evaluators/MemberExpression.js"],"names":["ast","strictCode","env","realm","baseReference","evaluate","object","baseValue","propertyNameValue","computed","propertyNameReference","property","name","bv","propertyKey","strict"],"mappings":";;;;;;kBAoBe,UAAUA,GAAV,EAA0CC,UAA1C,EAA+DC,GAA/D,EAAwFC,KAAxF,EAAyH;AACtI;AACA,MAAIC,gBAAgBF,IAAIG,QAAJ,CAAaL,IAAIM,MAAjB,EAAyBL,UAAzB,CAApB;;AAEA;AACA,MAAIM,YAAY,sBAASJ,KAAT,EAAgBC,aAAhB,CAAhB;;AAEA,MAAII,0BAAJ;AACA,MAAIR,IAAIS,QAAR,EAAkB;AAChB;AACA,QAAIC,wBAAwBR,IAAIG,QAAJ,CAAaL,IAAIW,QAAjB,EAA2BV,UAA3B,CAA5B;;AAEA;AACAO,wBAAoB,sBAASL,KAAT,EAAgBO,qBAAhB,CAApB;AACD,GAND,MAMO;AACL;AACAF,wBAAoB,uBAAgBL,KAAhB,EAAuBH,IAAIW,QAAJ,CAAaC,IAApC,CAApB;AACD;;AAED;AACA,MAAIC,KAAK,oCAAuBV,KAAvB,EAA8BI,SAA9B,CAAT;;AAEA;AACA,MAAIO,cAAc,kCAAqBX,KAArB,EAA4BK,iBAA5B,CAAlB;;AAEA;AACA,MAAIO,SAASd,UAAb;;AAEA;AACA,SAAO,2BAAcY,EAAd,EAAkBC,WAAlB,EAA+BC,MAA/B,CAAP;AACD,C;;AApCD;;AACA;;AACA","file":"MemberExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { StringValue } from \"../values/index.js\";\nimport { GetValue, ToPropertyKeyPartial, RequireObjectCoercible } from \"../methods/index.js\";\nimport type { BabelNodeMemberExpression } from \"babel-types\";\n\n// ECMA262 12.3.2.1\nexport default function (ast: BabelNodeMemberExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  // 1. Let baseReference be the result of evaluating MemberExpression.\n  let baseReference = env.evaluate(ast.object, strictCode);\n\n  // 2. Let baseValue be ? GetValue(baseReference).\n  let baseValue = GetValue(realm, baseReference);\n\n  let propertyNameValue;\n  if (ast.computed) {\n    // 3. Let propertyNameReference be the result of evaluating Expression.\n    let propertyNameReference = env.evaluate(ast.property, strictCode);\n\n    // 4. Let propertyNameValue be ? GetValue(propertyNameReference).\n    propertyNameValue = GetValue(realm, propertyNameReference);\n  } else {\n    // 3. Let propertyNameString be StringValue of IdentifierName.\n    propertyNameValue = new StringValue(realm, ast.property.name);\n  }\n\n  // 5. Let bv be ? RequireObjectCoercible(baseValue).\n  let bv = RequireObjectCoercible(realm, baseValue);\n\n  // 6. Let propertyKey be ? ToPropertyKey(propertyNameValue).\n  let propertyKey = ToPropertyKeyPartial(realm, propertyNameValue);\n\n  // 7. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.\n  let strict = strictCode;\n\n  // 8. Return a value of type Reference whose base value is bv, whose referenced name is propertyKey, and whose strict reference flag is strict.\n  return new Reference(bv, propertyKey, strict);\n}\n"]}