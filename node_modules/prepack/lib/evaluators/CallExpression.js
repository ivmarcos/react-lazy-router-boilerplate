"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  // ECMA262 12.3.4.1
  realm.setNextExecutionContextLocation(ast.loc);

  // 1. Let ref be the result of evaluating MemberExpression.
  var ref = env.evaluate(ast.callee, strictCode);

  // 2. Let func be ? GetValue(ref).
  var func = (0, _index2.GetValue)(realm, ref);

  if (func instanceof _index.AbstractValue && func.getType() === _index.FunctionValue) {
    var args = [func].concat((0, _index2.ArgumentListEvaluation)(realm, strictCode, env, ast.arguments));
    return realm.deriveAbstract(new _index3.TypesDomain(_index.AbstractValue), _index3.ValuesDomain.topVal, args, function (nodes) {
      var fun_args = nodes.slice(1);
      return t.callExpression(nodes[0], fun_args);
    });
  }
  func = func.throwIfNotConcrete();

  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is "eval", then
  if (ref instanceof _environment.Reference && !(0, _index2.IsPropertyReference)(realm, ref) && (0, _index2.GetReferencedName)(realm, ref) === "eval") {
    // a. If SameValue(func, %eval%) is true, then
    if (func instanceof _index.ConcreteValue && (0, _index2.SameValue)(realm, func, realm.intrinsics.eval)) {
      // i. Let argList be ? ArgumentListEvaluation(Arguments).
      var argList = (0, _index2.ArgumentListEvaluation)(realm, strictCode, env, ast.arguments);
      // ii. If argList has no elements, return undefined.
      if (argList.length === 0) return realm.intrinsics.undefined;
      // iii. Let evalText be the first element of argList.
      var evalText = argList[0];
      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.
      var strictCaller = strictCode;
      // v. Let evalRealm be the current Realm Record.
      var evalRealm = realm;
      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).
      return (0, _function.PerformEval)(realm, evalText, evalRealm, strictCaller, true);
    }
  }

  var thisValue = void 0;

  // 4. If Type(ref) is Reference, then
  if (ref instanceof _environment.Reference) {
    // a. If IsPropertyReference(ref) is true, then
    if ((0, _index2.IsPropertyReference)(realm, ref)) {
      // i. Let thisValue be GetThisValue(ref).
      thisValue = (0, _index2.GetThisValue)(realm, ref);
    } else {
      // b. Else, the base of ref is an Environment Record
      // i. Let refEnv be GetBase(ref).
      var refEnv = (0, _index2.GetBase)(realm, ref);
      (0, _invariant2.default)(refEnv instanceof _environment.EnvironmentRecord);

      // ii. Let thisValue be refEnv.WithBaseObject().
      thisValue = refEnv.WithBaseObject();
    }
  } else {
    // 5. Else Type(ref) is not Reference,
    // a. Let thisValue be undefined.
    thisValue = realm.intrinsics.undefined;
  }

  // 6. Let thisCall be this CallExpression.
  var thisCall = ast;

  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)
  var tailCall = (0, _index2.IsInTailPosition)(realm, thisCall);

  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).
  return (0, _index2.EvaluateDirectCall)(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall);
};

var _environment = require("../environment.js");

var _index = require("../values/index.js");

var _function = require("../methods/function.js");

var _index2 = require("../methods/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _index3 = require("../domains/index.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=CallExpression.js.map