{"version":3,"sources":["../../src/evaluators/ObjectExpression.js"],"names":["ast","strictCode","env","realm","obj","intrinsics","ObjectPrototype","properties","prop","type","propKey","EvalPropertyName","exprValueRef","evaluate","value","propValue","hasNameProperty","kind","methodDef","strict","body","scope","closure","params","$Key","$Closure","desc","writable","enumerable","configurable","formalParameterList","get","set","Error","computed","propertyKeyName","key","throwIfNotConcrete","name"],"mappings":"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","file":"ObjectExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { ObjectValue, StringValue } from \"../values/index.js\";\nimport {\n  ObjectCreate,\n  SetFunctionName,\n  GetValue,\n  ToStringPartial,\n  ToPropertyKey,\n  CreateDataPropertyOrThrow,\n  IsAnonymousFunctionDefinition,\n  HasOwnProperty,\n  FunctionCreate,\n  DefinePropertyOrThrow,\n  MakeMethod\n} from \"../methods/index.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeObjectExpression, BabelNodeObjectProperty, BabelNodeObjectMethod } from \"babel-types\";\n\n// Returns the result of evaluating PropertyName.\nfunction EvalPropertyName(prop: BabelNodeObjectProperty | BabelNodeObjectMethod, env: LexicalEnvironment, realm: Realm, strictCode: boolean): PropertyKeyValue {\n  if (prop.computed) {\n    let propertyKeyName = GetValue(realm, env.evaluate(prop.key, strictCode)).throwIfNotConcrete();\n    return ToPropertyKey(realm, propertyKeyName);\n  } else {\n    if (prop.key.type === \"Identifier\") {\n      return new StringValue(realm, prop.key.name);\n    } else {\n      return ToStringPartial(realm, GetValue(realm, env.evaluate(prop.key, strictCode)));\n    }\n  }\n}\n\n// ECMA262 12.2.6.8\nexport default function (ast: BabelNodeObjectExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  // 1. Let obj be ObjectCreate(%ObjectPrototype%).\n  let obj = ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n  // 2. Let status be the result of performing PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.\n  for (let prop of ast.properties) {\n    if (prop.type === \"ObjectProperty\") {\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n\n      // 3. Let exprValueRef be the result of evaluating AssignmentExpression.\n      let exprValueRef = env.evaluate(prop.value, strictCode);\n\n      // 4. Let propValue be ? GetValue(exprValueRef).\n      let propValue = GetValue(realm, exprValueRef);\n\n      // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then\n      if (IsAnonymousFunctionDefinition(realm, prop.value)) {\n        invariant(propValue instanceof ObjectValue);\n\n        // a. Let hasNameProperty be ? HasOwnProperty(propValue, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, propValue, \"name\");\n\n        // b. If hasNameProperty is false, perform SetFunctionName(propValue, propKey).\n        if (!hasNameProperty) SetFunctionName(realm, propValue, propKey);\n      }\n\n      // 6. Assert: enumerable is true.\n\n      // 7. Return CreateDataPropertyOrThrow(object, propKey, propValue).\n      CreateDataPropertyOrThrow(realm, obj, propKey, propValue);\n    } else if (prop.type === \"ObjectMethod\") {\n      if (prop.kind === \"method\") {\n        // 1. Let methodDef be DefineMethod of MethodDefinition with argument object.\n        let methodDef;\n        {\n          // 1. Let propKey be the result of evaluating PropertyName.\n          let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n          // 2. ReturnIfAbrupt(propKey).\n\n          // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n          let strict = strictCode || IsStrict(prop.body);\n\n          // 4. Let scope be the running execution context's LexicalEnvironment.\n          let scope = env;\n\n          // 5. If functionPrototype was passed as a parameter, let kind be Normal; otherwise let kind be Method.\n          let kind = \"method\";\n\n          // 6. Let closure be FunctionCreate(kind, StrictFormalParameters, FunctionBody, scope, strict). If functionPrototype was passed as a parameter, then pass its value as the prototype optional argument of FunctionCreate.\n          let closure = FunctionCreate(realm, kind, prop.params, prop.body, scope, strict);\n\n          // 7. Perform MakeMethod(closure, object).\n          MakeMethod(realm, closure, obj);\n\n          // 8. Return the Record{[[Key]]: propKey, [[Closure]]: closure}.\n          methodDef = { $Key: propKey, $Closure: closure };\n        }\n\n        // 2. ReturnIfAbrupt(methodDef).\n\n        // 3. Perform SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]).\n        SetFunctionName(realm, methodDef.$Closure, methodDef.$Key);\n\n        // 4. Let desc be the PropertyDescriptor{[[Value]]: methodDef.[[Closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n        let desc = {\n          value: methodDef.$Closure,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n\n        // 5. Return ? DefinePropertyOrThrow(object, methodDef.[[Key]], desc).\n        DefinePropertyOrThrow(realm, obj, methodDef.$Key, desc);\n      } else if (prop.kind === \"get\") {\n        // 1. Let propKey be the result of evaluating PropertyName.\n        let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n        // 2. ReturnIfAbrupt(propKey).\n\n        // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n        let strict = strictCode || IsStrict(prop.body);\n\n        // 4. Let scope be the running execution context's LexicalEnvironment.\n        let scope = env;\n\n        // 5. Let formalParameterList be the production FormalParameters:[empty] .\n        let formalParameterList = [];\n\n        // 6. Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).\n        let closure = FunctionCreate(realm, \"method\", formalParameterList, prop.body, scope, strict);\n\n        // 7. Perform MakeMethod(closure, object).\n        MakeMethod(realm, closure, obj);\n\n        // 8. Perform SetFunctionName(closure, propKey, \"get\").\n        SetFunctionName(realm, closure, propKey, \"get\");\n\n        // 9. Let desc be the PropertyDescriptor{[[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n        let desc = {\n          get: closure,\n          enumerable: true,\n          configurable: true\n        };\n\n        // 10. Return ? DefinePropertyOrThrow(object, propKey, desc).\n        DefinePropertyOrThrow(realm, obj, propKey, desc);\n      } else {\n        // 1. Let propKey be the result of evaluating PropertyName.\n        let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n        // 2. ReturnIfAbrupt(propKey).\n\n        // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n        let strict = strictCode || IsStrict(prop.body);\n\n        // 4. Let scope be the running execution context's LexicalEnvironment.\n        let scope = env;\n\n        // 5. Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).\n        let closure = FunctionCreate(realm, \"method\", prop.params, prop.body, scope, strict);\n\n        // 6. Perform MakeMethod(closure, object).\n        MakeMethod(realm, closure, obj);\n\n        // 7. Perform SetFunctionName(closure, propKey, \"set\").\n        SetFunctionName(realm, closure, propKey, \"set\");\n\n        // 8. Let desc be the PropertyDescriptor{[[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n        let desc = {\n          set: closure,\n          enumerable: true,\n          configurable: true\n        };\n\n        // 9. Return ? DefinePropertyOrThrow(object, propKey, desc).\n        DefinePropertyOrThrow(realm, obj, propKey, desc);\n      }\n    } else {\n      throw new Error(\"unknown property node\");\n    }\n  }\n\n  // 3. ReturnIfAbrupt(status).\n\n  // 4. Return obj.\n  return obj;\n}\n"]}