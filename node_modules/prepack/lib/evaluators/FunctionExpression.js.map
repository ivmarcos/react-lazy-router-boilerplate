{"version":3,"sources":["../../src/evaluators/FunctionExpression.js"],"names":["ast","strictCode","env","realm","id","generator","strict","body","scope","funcEnv","envRec","environmentRecord","name","CreateImmutableBinding","closure","params","loc","prototype","intrinsics","GeneratorPrototype","originalConstructor","value","writable","enumerable","configurable","InitializeBinding"],"mappings":";;;;;;kBAwBe,UAAUA,GAAV,EAA4CC,UAA5C,EAAiEC,GAAjE,EAA0FC,KAA1F,EAA2H;AACxI;;AAEA,MAAIH,IAAII,EAAR,EAAY;AACV,QAAIJ,IAAIK,SAAR,EAAmB;AACjB;AACA,UAAIC,SAASL,cAAc,sBAASD,IAAIO,IAAb,CAA3B;;AAEA;AACA,UAAIC,QAAQN,GAAZ;;AAEA;AACA,UAAIO,UAAU,sCAA0BN,KAA1B,EAAiCK,KAAjC,CAAd;;AAEA;AACA,UAAIE,SAASD,QAAQE,iBAArB;;AAEA;AACA,+BAAUX,IAAII,EAAd;AACA,UAAIQ,OAAOZ,IAAII,EAAJ,CAAOQ,IAAlB;;AAEA;AACAF,aAAOG,sBAAP,CAA8BD,IAA9B,EAAoC,KAApC;;AAEA;AACA,UAAIE,UAAU,uCAAwBX,KAAxB,EAA+B,QAA/B,EAAyCH,IAAIe,MAA7C,EAAqDf,IAAIO,IAAzD,EAA+DE,OAA/D,EAAwEH,MAAxE,CAAd;AACAQ,cAAQE,GAAR,GAAchB,IAAIgB,GAAlB;;AAEA;AACA,UAAIC,YAAY,0BAAad,KAAb,EAAoBA,MAAMe,UAAN,CAAiBC,kBAArC,CAAhB;AACAF,gBAAUG,mBAAV,GAAgCN,OAAhC;;AAEA;AACA,6CAAsBX,KAAtB,EAA6BW,OAA7B,EAAsC,WAAtC,EAAmD;AACjDO,eAAOJ,SAD0C;AAEjDK,kBAAU,IAFuC;AAGjDC,oBAAY,KAHqC;AAIjDC,sBAAc;AAJmC,OAAnD;;AAOA;AACA,kCAAgBrB,KAAhB,EAAuBW,OAAvB,EAAgC,wBAAgBX,KAAhB,EAAuBS,IAAvB,CAAhC;;AAEA;AACAF,aAAOe,iBAAP,CAAyBb,IAAzB,EAA+BE,OAA/B;;AAEA;AACA,aAAOA,OAAP;AACD,KA5CD,MA4CO;AACL;AACA,UAAIR,UAASL,cAAc,sBAASD,IAAIO,IAAb,CAA3B;;AAEA;AACA,UAAIC,SAAQN,GAAZ;;AAEA;AACA,UAAIO,WAAU,sCAA0BN,KAA1B,EAAiCK,MAAjC,CAAd;;AAEA;AACA,UAAIE,UAASD,SAAQE,iBAArB;;AAEA;AACA,+BAAUX,IAAII,EAAd;AACA,UAAIQ,QAAOZ,IAAII,EAAJ,CAAOQ,IAAlB;;AAEA;AACAF,cAAOG,sBAAP,CAA8BD,KAA9B,EAAoC,KAApC;;AAEA;AACA,UAAIE,WAAU,2BAAeX,KAAf,EAAsB,QAAtB,EAAgCH,IAAIe,MAApC,EAA4Cf,IAAIO,IAAhD,EAAsDE,QAAtD,EAA+DH,OAA/D,CAAd;AACAQ,eAAQE,GAAR,GAAchB,IAAIgB,GAAlB;;AAEA;AACA,kCAAgBb,KAAhB,EAAuBW,QAAvB;;AAEA;AACA,kCAAgBX,KAAhB,EAAuBW,QAAvB,EAAgC,wBAAgBX,KAAhB,EAAuBS,KAAvB,CAAhC;;AAEA;AACAF,cAAOe,iBAAP,CAAyBb,KAAzB,EAA+BE,QAA/B;;AAEA;AACA,aAAOA,QAAP;AACD;AACF,GAjFD,MAiFO;AACL,QAAId,IAAIK,SAAR,EAAmB;AACjB;AACA,UAAIC,WAASL,cAAc,sBAASD,IAAIO,IAAb,CAA3B;;AAEA;AACA,UAAIC,UAAQN,GAAZ;;AAEA;AACA,UAAIY,YAAU,uCAAwBX,KAAxB,EAA+B,QAA/B,EAAyCH,IAAIe,MAA7C,EAAqDf,IAAIO,IAAzD,EAA+DC,OAA/D,EAAsEF,QAAtE,CAAd;;AAEA;AACA,UAAIW,aAAY,0BAAad,KAAb,EAAoBA,MAAMe,UAAN,CAAiBC,kBAArC,CAAhB;AACAF,iBAAUG,mBAAV,GAAgCN,SAAhC;;AAEA;AACA,6CAAsBX,KAAtB,EAA6BW,SAA7B,EAAsC,WAAtC,EAAmD;AACjDO,eAAOJ,UAD0C;AAEjDK,kBAAU,IAFuC;AAGjDC,oBAAY,KAHqC;AAIjDC,sBAAc;AAJmC,OAAnD;;AAOA;AACA,aAAOV,SAAP;AACD,KAxBD,MAwBO;AACL;AACA,UAAIR,WAASL,cAAc,sBAASD,IAAIO,IAAb,CAA3B;;AAEA;AACA,UAAIC,UAAQN,GAAZ;;AAEA;AACA,UAAIY,YAAU,2BAAeX,KAAf,EAAsB,QAAtB,EAAgCH,IAAIe,MAApC,EAA4Cf,IAAIO,IAAhD,EAAsDC,OAAtD,EAA6DF,QAA7D,CAAd;;AAEA;AACA,kCAAgBH,KAAhB,EAAuBW,SAAvB;;AAEA;AACA,aAAOA,SAAP;AACD;AACF;AACF,C;;AAvID;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAEA","file":"FunctionExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport { NewDeclarativeEnvironment, SetFunctionName, FunctionCreate,  MakeConstructor } from \"../methods/index.js\";\nimport { ObjectCreate } from \"../methods/create.js\";\nimport { GeneratorFunctionCreate } from \"../methods/function.js\";\nimport { DefinePropertyOrThrow } from \"../methods/properties.js\";\nimport { StringValue } from \"../values/index.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport type { BabelNodeFunctionExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function (ast: BabelNodeFunctionExpression, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value | Reference {\n  // ECMA262 14.1.21\n\n  if (ast.id) {\n    if (ast.generator) {\n      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n      let funcEnv = NewDeclarativeEnvironment(realm, scope);\n\n      // 4. Let envRec be funcEnv's EnvironmentRecord.\n      let envRec = funcEnv.environmentRecord;\n\n      // 5. Let name be StringValue of BindingIdentifier.\n      invariant(ast.id);\n      let name = ast.id.name;\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      envRec.CreateImmutableBinding(name, false);\n\n      // 7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).\n      let closure = GeneratorFunctionCreate(realm, \"normal\", ast.params, ast.body, funcEnv, strict);\n      closure.loc = ast.loc;\n\n      // 8. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 9. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      DefinePropertyOrThrow(realm, closure, \"prototype\", {\n        value: prototype,\n        writable: true,\n        enumerable: false,\n        configurable: false\n      });\n\n      // 10. Perform SetFunctionName(closure, name).\n      SetFunctionName(realm, closure, new StringValue(realm, name));\n\n      // 11. Perform envRec.InitializeBinding(name, closure).\n      envRec.InitializeBinding(name, closure);\n\n      // 12. Return closure.\n      return closure;\n    } else {\n      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n      let funcEnv = NewDeclarativeEnvironment(realm, scope);\n\n      // 4. Let envRec be funcEnv's EnvironmentRecord.\n      let envRec = funcEnv.environmentRecord;\n\n      // 5. Let name be StringValue of BindingIdentifier.\n      invariant(ast.id);\n      let name = ast.id.name;\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      envRec.CreateImmutableBinding(name, false);\n\n      // 7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).\n      let closure = FunctionCreate(realm, \"normal\", ast.params, ast.body, funcEnv, strict);\n      closure.loc = ast.loc;\n\n      // 8. Perform MakeConstructor(closure).\n      MakeConstructor(realm, closure);\n\n      // 9. Perform SetFunctionName(closure, name).\n      SetFunctionName(realm, closure, new StringValue(realm, name));\n\n      // 10. Perform envRec.InitializeBinding(name, closure).\n      envRec.InitializeBinding(name, closure);\n\n      // 11. Return closure.\n      return closure;\n    }\n  } else {\n    if (ast.generator) {\n      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the LexicalEnvironment of the running execution context.\n      let scope = env;\n\n      // 3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).\n      let closure = GeneratorFunctionCreate(realm, \"normal\", ast.params, ast.body, scope, strict);\n\n      // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 5. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      DefinePropertyOrThrow(realm, closure, \"prototype\", {\n        value: prototype,\n        writable: true,\n        enumerable: false,\n        configurable: false\n      });\n\n      // 6. Return closure.\n      return closure;\n    } else {\n      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the LexicalEnvironment of the running execution context.\n      let scope = env;\n\n      // 3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).\n      let closure = FunctionCreate(realm, \"normal\", ast.params, ast.body, scope, strict);\n\n      // 4. Perform MakeConstructor(closure).\n      MakeConstructor(realm, closure);\n\n      // 5. Return closure.\n      return closure;\n    }\n  }\n}\n"]}