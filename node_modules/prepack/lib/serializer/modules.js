"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Modules = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _environment = require("../environment.js");

var _realm = require("../realm.js");

var _index = require("../methods/index.js");

var _completions = require("../completions.js");

var _index2 = require("../values/index.js");

var _index3 = require("../domains/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _logger = require("./logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2017-present, Facebook, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This source code is licensed under the BSD-style license found in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * LICENSE file in the root directory of this source tree. An additional grant
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * of patent rights can be found in the PATENTS file in the same directory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ModuleTracer = function (_Tracer) {
  _inherits(ModuleTracer, _Tracer);

  function ModuleTracer(modules, logModules) {
    _classCallCheck(this, ModuleTracer);

    var _this = _possibleConstructorReturn(this, (ModuleTracer.__proto__ || Object.getPrototypeOf(ModuleTracer)).call(this));

    _this.modules = modules;
    _this.partialEvaluation = 0;
    _this.requireStack = [];
    _this.requireSequence = [];
    _this.logModules = logModules;
    return _this;
  }

  _createClass(ModuleTracer, [{
    key: "log",
    value: function log(message) {
      if (this.logModules) console.log("[modules] " + this.requireStack.map(function (_) {
        return "  ";
      }).join("") + message);
    }
  }, {
    key: "beginPartialEvaluation",
    value: function beginPartialEvaluation() {
      this.log(">partial evaluation");
      this.partialEvaluation++;
      this.requireStack.push(undefined);
    }
  }, {
    key: "endPartialEvaluation",
    value: function endPartialEvaluation(effects) {
      var popped = this.requireStack.pop();
      (0, _invariant2.default)(popped === undefined);
      this.partialEvaluation--;
      this.log("<partial evaluation");
    }
  }, {
    key: "detourCall",
    value: function detourCall(F, thisArgument, argumentsList, newTarget, performCall) {
      var realm = this.modules.realm;
      if (F === this.modules.getRequire() && this.modules.delayUnsupportedRequires && argumentsList.length === 1) {
        var moduleId = argumentsList[0];
        var moduleIdValue = void 0;
        if (moduleId instanceof _index2.NumberValue || moduleId instanceof _index2.StringValue) {
          moduleIdValue = moduleId.value;
          if (!this.modules.moduleIds.has(moduleIdValue)) {
            this.modules.logger.logError(moduleId, "Module referenced by require call has not been defined.");
          }
        } else {
          this.modules.logger.logError(moduleId, "First argument to require function is not a number or string value.");
          return undefined;
        }
        this.log(">require(" + moduleIdValue + ")");
        var result = void 0;
        try {
          this.requireStack.push(moduleIdValue);
          var requireSequenceStart = this.requireSequence.length;
          this.requireSequence.push(moduleIdValue);
          var effects = realm.partially_evaluate(function () {
            try {
              return performCall();
            } catch (e) {
              if (e instanceof _completions.Completion) return e;
              throw e;
            }
          });

          var _effects = _slicedToArray(effects, 1);

          result = _effects[0];

          (0, _invariant2.default)(result instanceof _index2.Value || result instanceof _completions.Completion);
          if (result instanceof _completions.IntrospectionThrowCompletion) {
            var _modules$getMessageAn = this.modules.getMessageAndStack(effects),
                _modules$getMessageAn2 = _slicedToArray(_modules$getMessageAn, 2),
                message = _modules$getMessageAn2[0],
                stack = _modules$getMessageAn2[1];

            console.log("delaying require(" + moduleIdValue + "): " + message + " " + stack);
            // So we are about to emit a delayed require(...) call.
            // However, before we do that, let's try to require all modules that we
            // know this delayed require call will require.
            // This way, we ensure that those modules will be fully initialized
            // before the require call executes.
            // TODO: More needs to be done to make the delayUnsupportedRequires
            // feature completely safe. Open issues are:
            // 1) Side-effects on the heap of delayed factory functions are not discovered or rejected.
            // 2) While we do process an appropriate list of transitively required modules here,
            //    more modules would have been required if the Introspection exception had not been thrown.
            //    To be correct, those modules would have to be prepacked here as well.
            var nestedModulesIds = new Set();
            for (var i = requireSequenceStart; i < this.requireSequence.length; i++) {
              var nestedModuleId = this.requireSequence[i];
              if (nestedModulesIds.has(nestedModuleId)) continue;
              nestedModulesIds.add(nestedModuleId);
              this.modules.tryInitializeModule(nestedModuleId, "initialization of module " + nestedModuleId + " as it's required by module " + moduleIdValue);
            }

            result = realm.deriveAbstract(_index3.TypesDomain.topVal, _index3.ValuesDomain.topVal, [], function (_ref) {
              var _ref2 = _toArray(_ref);

              return t.callExpression(t.identifier("require"), [t.valueToNode(moduleIdValue)]);
            });
          } else {
            realm.apply_effects(effects, "initialization of module " + moduleIdValue);
          }
        } finally {
          var popped = this.requireStack.pop();
          (0, _invariant2.default)(popped === moduleIdValue);
          var _message = "";
          (0, _invariant2.default)(!(result instanceof _completions.IntrospectionThrowCompletion));
          if (result instanceof _completions.ThrowCompletion) _message = " threw an error";
          this.log("<require(" + moduleIdValue + ")" + _message);
        }
        if (result instanceof _completions.Completion) throw result;
        return result;
      } else if (F === this.modules.getDefine()) {
        if (this.partialEvaluation !== 0) this.modules.logger.logError(F, "Defining a module in nested partial evaluation is not supported.");
        var factoryFunction = argumentsList[0];
        if (factoryFunction instanceof _index2.FunctionValue) this.modules.factoryFunctions.add(factoryFunction);else this.modules.logger.logError(factoryFunction, "First argument to define function is not a function value.");
        var _moduleId = argumentsList[1];
        if (_moduleId instanceof _index2.NumberValue || _moduleId instanceof _index2.StringValue) this.modules.moduleIds.add(_moduleId.value);else this.modules.logger.logError(_moduleId, "Second argument to define function is not a number or string value.");
      }
      return undefined;
    }
  }]);

  return ModuleTracer;
}(_realm.Tracer);

var Modules = exports.Modules = function () {
  function Modules(realm, logger, logModules, delayUnsupportedRequires) {
    _classCallCheck(this, Modules);

    this.realm = realm;
    this.logger = logger;
    this._require = realm.intrinsics.undefined;
    this._define = realm.intrinsics.undefined;
    this.factoryFunctions = new Set();
    this.moduleIds = new Set();
    this.initializedModules = new Map();
    realm.tracers.push(new ModuleTracer(this, logModules));
    this.delayUnsupportedRequires = delayUnsupportedRequires;
  }

  _createClass(Modules, [{
    key: "_getGlobalProperty",
    value: function _getGlobalProperty(name) {
      if (this.active) return this.realm.intrinsics.undefined;
      this.active = true;
      try {
        var realm = this.realm;
        return this.logger.tryQuery(function () {
          return (0, _index.Get)(realm, realm.$GlobalObject, name);
        }, realm.intrinsics.undefined, false);
      } finally {
        this.active = false;
      }
    }
  }, {
    key: "getRequire",
    value: function getRequire() {
      if (!(this._require instanceof _index2.FunctionValue)) this._require = this._getGlobalProperty("require");
      return this._require;
    }
  }, {
    key: "getDefine",
    value: function getDefine() {
      if (!(this._define instanceof _index2.FunctionValue)) this._define = this._getGlobalProperty("__d");
      return this._define;
    }
  }, {
    key: "getIsRequire",
    value: function getIsRequire(formalParameters, functions) {
      var realm = this.realm;
      var logger = this.logger;
      var modules = this;
      return function (scope, node) {
        if (!t.isIdentifier(node.callee) || node.arguments.length !== 1 || !node.arguments[0]) return false;
        var argument = node.arguments[0];
        if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument)) return false;

        (0, _invariant2.default)(node.callee);
        var innerName = node.callee.name;

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          var _loop = function _loop() {
            var f = _step.value;

            var scopedBinding = scope.getBinding(innerName);
            if (scopedBinding) {
              if (modules.factoryFunctions.has(f) && formalParameters[1] === scopedBinding.path.node) {
                (0, _invariant2.default)(scopedBinding.kind === "param");
                return "continue";
              }
              // The name binds to some local entity, but nothing we'd know what exactly it is
              return {
                v: false
              };
            }

            var doesNotMatter = true;
            var reference = logger.tryQuery(function () {
              return (0, _index.ResolveBinding)(realm, innerName, doesNotMatter, f.$Environment);
            }, undefined, false);
            if (reference === undefined) {
              // We couldn't resolve as we came across some behavior that we cannot deal with abstractly
              return {
                v: false
              };
            }
            if ((0, _index.IsUnresolvableReference)(realm, reference)) return {
                v: false
              };
            var referencedBase = reference.base;
            var referencedName = reference.referencedName;
            if (typeof referencedName !== "string") return {
                v: false
              };
            var value = void 0;
            if (reference.base instanceof _environment.GlobalEnvironmentRecord) {
              value = logger.tryQuery(function () {
                return (0, _index.Get)(realm, realm.$GlobalObject, innerName);
              }, realm.intrinsics.undefined, false);
            } else {
              (0, _invariant2.default)(referencedBase instanceof _environment.DeclarativeEnvironmentRecord);
              var binding = referencedBase.bindings[referencedName];
              if (!binding.initialized) return {
                  v: false
                };
              value = binding.value;
            }
            if (value !== modules.getRequire()) return {
                v: false
              };
          };

          for (var _iterator = functions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ret = _loop();

            switch (_ret) {
              case "continue":
                continue;

              default:
                if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return true;
      };
    }
  }, {
    key: "getMessageAndStack",
    value: function getMessageAndStack(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 5),
          result = _ref4[0],
          generator = _ref4[1],
          bindings = _ref4[2],
          properties = _ref4[3],
          createdObjects = _ref4[4];

      var realm = this.realm;
      if (!(result instanceof _completions.Completion) || !(result.value instanceof _index2.ObjectValue)) return ["(no message)", "(no stack)"];

      // Temporarily apply state changes in order to retrieve message
      realm.restoreBindings(bindings);
      realm.restoreProperties(properties);

      var value = result.value;
      var message = this.logger.tryQuery(function () {
        return (0, _index.ToStringPartial)(realm, (0, _index.Get)(realm, value, "message"));
      }, "(cannot get message)", false);
      var stack = this.logger.tryQuery(function () {
        return (0, _index.ToStringPartial)(realm, (0, _index.Get)(realm, value, "stack"));
      }, "", false);

      // Undo state changes
      realm.restoreBindings(bindings);
      realm.restoreProperties(properties);

      if (result instanceof _completions.IntrospectionThrowCompletion && result.reason !== undefined) message = "[" + result.reason + "] " + message;

      var i = stack.indexOf("\n");
      if (i >= 0) stack = stack.slice(i);
      return [message, stack];
    }
  }, {
    key: "tryInitializeModule",
    value: function tryInitializeModule(moduleId, message) {
      var realm = this.realm;
      // setup execution environment
      var context = new _realm.ExecutionContext();
      var env = realm.$GlobalEnv;
      context.lexicalEnvironment = env;
      context.variableEnvironment = env;
      context.realm = realm;
      var oldDelayUnsupportedRequires = this.delayUnsupportedRequires;
      this.delayUnsupportedRequires = false;
      realm.pushContext(context);
      try {
        var _node = t.callExpression(t.identifier("require"), [t.valueToNode(moduleId)]);

        var effects = realm.partially_evaluate_node(_node, true, env, false);
        var result = effects[0];
        if (result instanceof _completions.IntrospectionThrowCompletion) return effects;

        realm.apply_effects(effects, message);
        if (result instanceof _completions.Completion) {
          console.log("=== UNEXPECTED ERROR during " + message + " ===");
          this.logger.logCompletion(result);
          return undefined;
        }

        return effects;
      } finally {
        realm.popContext(context);
        this.delayUnsupportedRequires = oldDelayUnsupportedRequires;
      }
    }
  }, {
    key: "initializeMoreModules",
    value: function initializeMoreModules() {
      // partially evaluate all factory methods by calling require
      var count = 0;
      var introspectionErrors = Object.create(null);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.moduleIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var moduleId = _step2.value;

          if (this.initializedModules.has(moduleId)) continue;

          var effects = this.tryInitializeModule(moduleId, "Speculative initialization of module " + moduleId);

          if (effects === undefined) break;
          var result = effects[0];
          if (result instanceof _completions.IntrospectionThrowCompletion) {
            (0, _invariant2.default)(result instanceof _completions.IntrospectionThrowCompletion);

            var _getMessageAndStack = this.getMessageAndStack(effects),
                _getMessageAndStack2 = _slicedToArray(_getMessageAndStack, 2),
                message = _getMessageAndStack2[0],
                stack = _getMessageAndStack2[1];

            var stacks = introspectionErrors[message] = introspectionErrors[message] || [];
            stacks.push(stack);
            continue;
          }

          (0, _invariant2.default)(result instanceof _index2.Value);
          count++;
          this.initializedModules.set(moduleId, result);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (count > 0) console.log("=== speculatively initialized " + count + " additional modules");
      var a = [];
      for (var key in introspectionErrors) {
        a.push([introspectionErrors[key], key]);
      }a.sort(function (x, y) {
        return y[0].length - x[0].length;
      });
      if (a.length) {
        console.log("=== speculative module initialization failures ordered by frequency");
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = a[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _step3$value = _slicedToArray(_step3.value, 2),
                stacks = _step3$value[0],
                n = _step3$value[1];

            console.log(stacks.length + "x " + n + " " + stacks.join("\nas well as") + "]");
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    }
  }, {
    key: "resolveInitializedModules",
    value: function resolveInitializedModules() {
      // partial evaluate all possible requires and see which are possible to inline
      var realm = this.realm;
      // setup execution environment
      var context = new _realm.ExecutionContext();
      var env = realm.$GlobalEnv;
      context.lexicalEnvironment = env;
      context.variableEnvironment = env;
      context.realm = realm;
      realm.pushContext(context);
      var oldReadOnly = realm.setReadOnly(true);
      var oldDelayUnsupportedRequires = this.delayUnsupportedRequires;
      this.delayUnsupportedRequires = false;
      try {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.moduleIds[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var moduleId = _step4.value;

            var _node2 = t.callExpression(t.identifier("require"), [t.valueToNode(moduleId)]);

            var _realm$partially_eval = realm.partially_evaluate_node(_node2, true, env, false),
                _realm$partially_eval2 = _slicedToArray(_realm$partially_eval, 5),
                compl = _realm$partially_eval2[0],
                generator = _realm$partially_eval2[1],
                bindings = _realm$partially_eval2[2],
                properties = _realm$partially_eval2[3],
                createdObjects = _realm$partially_eval2[4];
            // for lint unused


            (0, _invariant2.default)(bindings);

            if (compl instanceof _completions.AbruptCompletion) continue;
            (0, _invariant2.default)(compl instanceof _index2.Value);

            if (generator.body.length !== 0 || compl instanceof _index2.ObjectValue && createdObjects.has(compl)) continue;
            // Check for escaping property assignments, if none escape, we're safe
            // to replace the require with its exports object
            var escapes = false;
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = properties[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var _step5$value = _slicedToArray(_step5.value, 1),
                    binding = _step5$value[0];

                if (!createdObjects.has(binding.object)) escapes = true;
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }

            if (escapes) continue;

            this.initializedModules.set(moduleId, compl);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      } finally {
        realm.popContext(context);
        realm.setReadOnly(oldReadOnly);
        this.delayUnsupportedRequires = oldDelayUnsupportedRequires;
      }
    }
  }]);

  return Modules;
}();
//# sourceMappingURL=modules.js.map