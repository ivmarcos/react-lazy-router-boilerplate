{"version":3,"sources":["../../src/serializer/visitors.js"],"names":["t","markVisited","node","data","_renamedOnce","shouldVisit","ClosureRefReplacer","ReferencedIdentifier","path","state","ignorePath","serializedBindings","innerName","name","scope","hasBinding","serializedBinding","serializedValue","replaceWith","CallExpression","requireReturns","isRequire","requireStatistics","count","modified","callee","moduleId","arguments","value","new_node","get","undefined","replaced","ids","getBindingIdentifierPaths","nestedPath","visitName","doesNotMatter","ref","tryQuery","realm","val","$Environment","map","functionInfo","parent","isLabeledStatement","isBreakStatement","isContinueStatement","ClosureRefVisitor","usesArguments","ThisExpression","usesThis","getBindingIdentifiers","IdentifierCollector","add"],"mappings":"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","file":"visitors.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { IsUnresolvableReference, ResolveBinding } from \"../methods/index.js\";\nimport { FunctionValue } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeExpression, BabelNodeCallExpression } from \"babel-types\";\nimport { BabelTraversePath } from \"babel-traverse\";\nimport type { TryQuery, FunctionInfo, Names } from \"./types.js\";\n\nexport type ClosureRefVisitorState = {\n  tryQuery: TryQuery<*>,\n  val: FunctionValue;\n  reasons: Array<string>;\n  name: string;\n  functionInfo: FunctionInfo;\n  map: Names;\n  realm: Realm;\n};\n\nexport type ClosureRefReplacerState = {\n  serializedBindings: any,\n  modified: Names;\n  requireReturns: Map<number | string, BabelNodeExpression>;\n  requireStatistics: { replaced: 0, count: 0 };\n  isRequire: void | (scope: any, node: BabelNodeCallExpression) => boolean;\n}\n\nfunction markVisited(node, data) {\n  (node: any)._renamedOnce = data;\n}\n\nfunction shouldVisit(node, data) {\n  return (node: any)._renamedOnce !== data;\n}\n\n// replaceWith causes the node to be re-analysed, so to prevent double replacement\n// we add this property on the node to mark it such that it does not get replaced\n// again on this pass\n// TODO: Make this work when replacing with arbitrary BabelNodeExpressions. Currently\n//       if the node that we're substituting contains identifiers as children,\n//       they will be visited again and possibly transformed.\n//       If necessary we could implement this by following node.parentPath and checking\n//       if any parent nodes are marked visited, but that seem unnecessary right now.let closureRefReplacer = {\nexport let ClosureRefReplacer = {\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    if (ignorePath(path)) return;\n\n    let serializedBindings = state.serializedBindings;\n    let innerName = path.node.name;\n    if (path.scope.hasBinding(innerName, /*noGlobals*/true)) return;\n\n    let serializedBinding = serializedBindings[innerName];\n    if (serializedBinding && shouldVisit(path.node, serializedBindings)) {\n      markVisited(serializedBinding.serializedValue, serializedBindings);\n      path.replaceWith(serializedBinding.serializedValue);\n    }\n  },\n\n  CallExpression(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    // Here we apply the require optimization by replacing require calls with their\n    // corresponding initialized modules.\n    let requireReturns = state.requireReturns;\n    if (!state.isRequire || !state.isRequire(path.scope, path.node)) return;\n    state.requireStatistics.count++;\n    if (state.modified[path.node.callee.name]) return;\n\n    let moduleId = path.node.arguments[0].value;\n    let new_node = requireReturns.get(moduleId);\n    if (new_node !== undefined) {\n      markVisited(new_node, state.serializedBindings);\n      path.replaceWith(new_node);\n      state.requireStatistics.replaced++;\n    }\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefReplacerState) {\n    let serializedBindings = state.serializedBindings;\n    let ids = path.getBindingIdentifierPaths();\n\n    for (let innerName in ids) {\n      let nestedPath = ids[innerName];\n      if (path.scope.hasBinding(innerName, /*noGlobals*/true)) return;\n\n      let serializedBinding = serializedBindings[innerName];\n      if (serializedBinding && shouldVisit(nestedPath.node, serializedBindings)) {\n        markVisited(serializedBinding.serializedValue, serializedBindings);\n        nestedPath.replaceWith(serializedBinding.serializedValue);\n      }\n    }\n  }\n};\n\nfunction visitName(state, name, modified) {\n  let doesNotMatter = true;\n  let ref = state.tryQuery(\n    () => ResolveBinding(state.realm, name, doesNotMatter, state.val.$Environment),\n    undefined, true);\n  if (ref === undefined) return;\n  if (IsUnresolvableReference(state.realm, ref)) return;\n  state.map[name] = true;\n  if (modified) state.functionInfo.modified[name] = true;\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\n// TODO doesn't check that `arguments` and `this` is in top function\nexport let ClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      state.functionInfo.usesArguments = true;\n      return;\n    }\n    if (path.scope.hasBinding(innerName, /*noGlobals*/true)) return;\n    visitName(state, innerName, false);\n  },\n\n  ThisExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    state.functionInfo.usesThis = true;\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    for (let name in path.getBindingIdentifiers()) {\n      if (path.scope.hasBinding(name, /*noGlobals*/true)) continue;\n      visitName(state, name, true);\n    }\n  }\n};\n\nexport let IdentifierCollector = {\n  ReferencedIdentifier(path: BabelTraversePath, state: Set<string>) {\n    state.add(path.node.name);\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: Set<string>) {\n    for (let name in path.getBindingIdentifiers()) {\n      state.add(name);\n    }\n  }\n};\n"]}