"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdentifierCollector = exports.ClosureRefVisitor = exports.ClosureRefReplacer = undefined;

var _realm = require("../realm.js");

var _index = require("../methods/index.js");

var _index2 = require("../values/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _babelTraverse = require("babel-traverse");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function markVisited(node, data) {
  node._renamedOnce = data;
} /**
   * Copyright (c) 2017-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

function shouldVisit(node, data) {
  return node._renamedOnce !== data;
}

// replaceWith causes the node to be re-analysed, so to prevent double replacement
// we add this property on the node to mark it such that it does not get replaced
// again on this pass
// TODO: Make this work when replacing with arbitrary BabelNodeExpressions. Currently
//       if the node that we're substituting contains identifiers as children,
//       they will be visited again and possibly transformed.
//       If necessary we could implement this by following node.parentPath and checking
//       if any parent nodes are marked visited, but that seem unnecessary right now.let closureRefReplacer = {
var ClosureRefReplacer = exports.ClosureRefReplacer = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (ignorePath(path)) return;

    var serializedBindings = state.serializedBindings;
    var innerName = path.node.name;
    if (path.scope.hasBinding(innerName, /*noGlobals*/true)) return;

    var serializedBinding = serializedBindings[innerName];
    if (serializedBinding && shouldVisit(path.node, serializedBindings)) {
      markVisited(serializedBinding.serializedValue, serializedBindings);
      path.replaceWith(serializedBinding.serializedValue);
    }
  },
  CallExpression: function CallExpression(path, state) {
    // Here we apply the require optimization by replacing require calls with their
    // corresponding initialized modules.
    var requireReturns = state.requireReturns;
    if (!state.isRequire || !state.isRequire(path.scope, path.node)) return;
    state.requireStatistics.count++;
    if (state.modified[path.node.callee.name]) return;

    var moduleId = path.node.arguments[0].value;
    var new_node = requireReturns.get(moduleId);
    if (new_node !== undefined) {
      markVisited(new_node, state.serializedBindings);
      path.replaceWith(new_node);
      state.requireStatistics.replaced++;
    }
  },
  "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path, state) {
    var serializedBindings = state.serializedBindings;
    var ids = path.getBindingIdentifierPaths();

    for (var innerName in ids) {
      var nestedPath = ids[innerName];
      if (path.scope.hasBinding(innerName, /*noGlobals*/true)) return;

      var serializedBinding = serializedBindings[innerName];
      if (serializedBinding && shouldVisit(nestedPath.node, serializedBindings)) {
        markVisited(serializedBinding.serializedValue, serializedBindings);
        nestedPath.replaceWith(serializedBinding.serializedValue);
      }
    }
  }
};

function visitName(state, name, modified) {
  var doesNotMatter = true;
  var ref = state.tryQuery(function () {
    return (0, _index.ResolveBinding)(state.realm, name, doesNotMatter, state.val.$Environment);
  }, undefined, true);
  if (ref === undefined) return;
  if ((0, _index.IsUnresolvableReference)(state.realm, ref)) return;
  state.map[name] = true;
  if (modified) state.functionInfo.modified[name] = true;
}

function ignorePath(path) {
  var parent = path.parent;
  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);
}

// TODO doesn't check that `arguments` and `this` is in top function
var ClosureRefVisitor = exports.ClosureRefVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    if (ignorePath(path)) return;

    var innerName = path.node.name;
    if (innerName === "arguments") {
      state.functionInfo.usesArguments = true;
      return;
    }
    if (path.scope.hasBinding(innerName, /*noGlobals*/true)) return;
    visitName(state, innerName, false);
  },
  ThisExpression: function ThisExpression(path, state) {
    state.functionInfo.usesThis = true;
  },
  "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path, state) {
    for (var _name in path.getBindingIdentifiers()) {
      if (path.scope.hasBinding(_name, /*noGlobals*/true)) continue;
      visitName(state, _name, true);
    }
  }
};

var IdentifierCollector = exports.IdentifierCollector = {
  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
    state.add(path.node.name);
  },
  "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path, state) {
    for (var _name2 in path.getBindingIdentifiers()) {
      state.add(_name2);
    }
  }
};
//# sourceMappingURL=visitors.js.map