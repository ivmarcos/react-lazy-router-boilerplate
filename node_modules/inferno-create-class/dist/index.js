"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var inferno_component_1 = require("inferno-component");
var inferno_shared_1 = require("inferno-shared");
// don't autobind these methods since they already have guaranteed context.
var AUTOBIND_BLACKLIST = new Set();
AUTOBIND_BLACKLIST.add('constructor');
AUTOBIND_BLACKLIST.add('render');
AUTOBIND_BLACKLIST.add('shouldComponentUpdate');
AUTOBIND_BLACKLIST.add('componentWillReceiveProps');
AUTOBIND_BLACKLIST.add('componentWillUpdate');
AUTOBIND_BLACKLIST.add('componentDidUpdate');
AUTOBIND_BLACKLIST.add('componentWillMount');
AUTOBIND_BLACKLIST.add('componentDidMount');
AUTOBIND_BLACKLIST.add('componentWillUnmount');
AUTOBIND_BLACKLIST.add('componentDidUnmount');
function extend(base, props) {
    for (var key in props) {
        if (!inferno_shared_1.isNullOrUndef(props[key])) {
            base[key] = props[key];
        }
    }
    return base;
}
function bindAll(ctx) {
    for (var i in ctx) {
        var v = ctx[i];
        if (typeof v === 'function' && !v.__bound && !AUTOBIND_BLACKLIST.has(i)) {
            (ctx[i] = v.bind(ctx)).__bound = true;
        }
    }
}
function collateMixins(mixins, keyed) {
    if (keyed === void 0) { keyed = {}; }
    for (var i = 0, len = mixins.length; i < len; i++) {
        var mixin = mixins[i];
        // Surprise: Mixins can have mixins
        if (mixin.mixins) {
            // Recursively collate sub-mixins
            collateMixins(mixin.mixins, keyed);
        }
        for (var key in mixin) {
            if (mixin.hasOwnProperty(key) && typeof mixin[key] === 'function') {
                (keyed[key] || (keyed[key] = [])).push(mixin[key]);
            }
        }
    }
    return keyed;
}
function multihook(hooks, mergeFn) {
    return function () {
        var ret;
        for (var i = 0, len = hooks.length; i < len; i++) {
            var hook = hooks[i];
            var r = hook.apply(this, arguments);
            if (mergeFn) {
                ret = mergeFn(ret, r);
            }
            else if (!inferno_shared_1.isUndefined(r)) {
                ret = r;
            }
        }
        return ret;
    };
}
function mergeNoDupes(previous, current) {
    if (!inferno_shared_1.isUndefined(current)) {
        if (!inferno_shared_1.isObject(current)) {
            inferno_shared_1.throwError('Expected Mixin to return value to be an object or null.');
        }
        if (!previous) {
            previous = {};
        }
        for (var key in current) {
            if (current.hasOwnProperty(key)) {
                if (previous.hasOwnProperty(key)) {
                    inferno_shared_1.throwError("Mixins return duplicate key " + key + " in their return values");
                }
                previous[key] = current[key];
            }
        }
    }
    return previous;
}
function applyMixin(key, inst, mixin) {
    var hooks = inferno_shared_1.isUndefined(inst[key]) ? mixin : mixin.concat(inst[key]);
    if (key === 'getDefaultProps' || key === 'getInitialState' || key === 'getChildContext') {
        inst[key] = multihook(hooks, mergeNoDupes);
    }
    else {
        inst[key] = multihook(hooks);
    }
}
function applyMixins(Cl, mixins) {
    for (var key in mixins) {
        if (mixins.hasOwnProperty(key)) {
            var mixin = mixins[key];
            var inst = void 0;
            if (key === 'getDefaultProps') {
                inst = Cl;
            }
            else {
                inst = Cl.prototype;
            }
            if (inferno_shared_1.isFunction(mixin[0])) {
                applyMixin(key, inst, mixin);
            }
            else {
                inst[key] = mixin;
            }
        }
    }
}
function createClass(obj) {
    var Cl = (function (_super) {
        __extends(Cl, _super);
        function Cl(props, context) {
            var _this = _super.call(this, props, context) || this;
            bindAll(_this);
            if (_this.getInitialState) {
                _this.state = _this.getInitialState();
            }
            return _this;
        }
        Cl.prototype.replaceState = function (nextState, callback) {
            this.setState(nextState, callback);
        };
        Cl.prototype.isMounted = function () {
            return !this._unmounted;
        };
        return Cl;
    }(inferno_component_1.default));
    Cl.displayName = obj.displayName || 'Component';
    Cl.propTypes = obj.propTypes;
    Cl.mixins = obj.mixins && collateMixins(obj.mixins);
    Cl.getDefaultProps = obj.getDefaultProps;
    extend(Cl.prototype, obj);
    if (obj.statics) {
        extend(Cl, obj.statics);
    }
    if (obj.mixins) {
        applyMixins(Cl, collateMixins(obj.mixins));
    }
    Cl.defaultProps = inferno_shared_1.isUndefined(Cl.getDefaultProps) ? undefined : Cl.getDefaultProps();
    return Cl;
}
exports.default = createClass;
